import "c";
import "std";

import "bubby";
import "nbnet";

# Simplified Permuted Congruential Generator algorithms (32 and 64 bit).
# Originally created by Christopher Wellons[1].
#
# [1]: https://nullprogram.com/blog/2017/09/21/
var spcg32_state = 0xBADF00D01DC0FFEEu64;
var spcg64_state = (:[2]u64)[0xBADF00D01DC0FFEE, 0xCAFED00DCAFEBABE];

func spcg32(s: *u64) u32 {
    var m: u64 = 0x9b60933458e17d7d;
    var a: u64 = 0xd737232eeccdf7ed;
    *s = *s *% m +% a;
    var shift = 29 - (*s >> 61);
    return (:u32)(*s >> (:usize)shift);
}

func spcg64(s: *[2]u64) u64 {
    var m:  u64 = 0x9b60933458e17d7d;
    var a0: u64 = 0xd737232eeccdf7ed;
    var a1: u64 = 0x8b260b70b8e98891;
    var p0: u64 = s.*[0];
    var p1: u64 = s.*[1];
    s.*[0] = p0 *% m +% a0;
    s.*[1] = p1 *% m +% a1;
    var r0 = 29 - (p0 >> 61);
    var r1 = 29 - (p1 >> 61);
    var hi = p0 >> (:usize)r0;
    var lo = p1 >> (:usize)r1;
    return (hi << 32) | (lo & 0xFFFFFFFF);
}

func random32() u32 {
    return spcg32(&spcg32_state);
}

func random64() u64 {
    return spcg64(&spcg64_state);
}

func d6() sint {
    return (:sint)(random32() % 6 + 1);
}

func xstr_to_int[[T]](str: []byte) T {
    var parsed = T::init_from_str(str, 0);
    return parsed.value();
}

func int_to_bubby[[T]](int: T) bubby::value {
    return bubby::value::init_str_from_format("{}", (:[]std::formatter)[std::formatter::init[[T]](&int)]);
}

enum player {
    NIL = 0;
    RED = 1;
    BLUE = 2;
    WHITE = 3;
    ORANGE = 4;
}

func name_to_player(name: []byte) player {
    if std::str::eq(name, "RED") {
        return ::player::RED;
    }
    if std::str::eq(name, "BLUE") {
        return ::player::BLUE;
    }
    if std::str::eq(name, "WHITE") {
        return ::player::WHITE;
    }
    if std::str::eq(name, "ORANGE") {
        return ::player::ORANGE;
    }

    return ::player::NIL;
}

func player_to_name(player: player) []byte {
    switch player {
    ::player::NIL {
        return "SPECTATOR";
    }
    ::player::RED {
        return "RED";
    }
    ::player::BLUE {
        return "BLUE";
    }
    ::player::WHITE {
        return "WHITE";
    }
    ::player::ORANGE {
        return "ORANGE";
    }
    }

    std::unreachable(fileof(), lineof());
    return std::zeroed[[[]byte]]();
}

func player_to_bubby(player: player) bubby::value {
    var name = player_to_name(player);
    return bubby::value::init_str(name);
}

func bubby_to_player(value: *bubby::value) player {
    var name = value.*.str();
    return name_to_player(name);
}

# Hex position using the cube coordinate system satisfying q + r + s == 0.
struct hex {
    var q: sint;
    var r: sint;
    var s: sint;

    func init(q: sint, r: sint, s: sint) hex {
        assert q + r + s == 0;
        return (:hex){.q = q, .r = r, .s = s};
    }

    func init_round(q_fractional: f32, r_fractional: f32, s_fractional: f32) hex {
        var q_rounded = f32::round(q_fractional);
        var r_rounded = f32::round(r_fractional);
        var s_rounded = f32::round(s_fractional);

        var q_diff = f32::abs(q_rounded - q_fractional);
        var r_diff = f32::abs(r_rounded - r_fractional);
        var s_diff = f32::abs(s_rounded - s_fractional);

        var q = (:sint)q_rounded;
        var r = (:sint)r_rounded;
        var s = (:sint)s_rounded;
        if q_diff > r_diff and q_diff > s_diff {
            q = (:sint)-r_rounded - (:sint)s_rounded;
        }
        elif r_diff > s_diff {
            r = (:sint)-q_rounded - (:sint)s_rounded;
        }
        else {
            s = (:sint)-q_rounded - (:sint)r_rounded;
        }

        return hex::init(q, r, s);
    }

    func hash(self: *hex) usize {
        var h = self.*.q.hash() +% self.*.q.hash() +% self.*.s.hash();
        return h *% h;
    }

    func compare(lhs: *hex, rhs: *hex) ssize {
        var cmp = sint::cmp(lhs.*.q, rhs.*.q);
        if cmp != 0 {
            return cmp;
        }

        var cmp = sint::cmp(lhs.*.r, rhs.*.r);
        if cmp != 0 {
            return cmp;
        }

        var cmp = sint::cmp(lhs.*.s, rhs.*.s);
        if cmp != 0 {
            return cmp;
        }

        return 0;
    }

    func format(self: *hex, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            return std::write_format(
                writer,
                "(q={}, r={}, s={})",
                (:[]std::formatter)[
                    std::formatter::init[[sint]](&self.*.q),
                    std::formatter::init[[sint]](&self.*.r),
                    std::formatter::init[[sint]](&self.*.s)]);
        }

        return std::result[[void, std::error]]::init_value(void::VALUE);
    }

    func init_from_bubby(value: *bubby::value) hex {
        var q = xstr_to_int[[sint]](value.*.vec().*.data()[0].str());
        var r = xstr_to_int[[sint]](value.*.vec().*.data()[1].str());
        var s = -q - r;
        return hex::init(q, r, s);
    }

    func to_bubby(self: *hex) bubby::value {
        var out = bubby::value::init_vec();
        out.vec().*.push(int_to_bubby[[sint]](self.*.q));
        out.vec().*.push(int_to_bubby[[sint]](self.*.r));
        return out;
    }

    func subtract(lhs: hex, rhs: hex) hex {
        return hex::init(lhs.q - rhs.q, lhs.r - rhs.r, lhs.s - rhs.s);
    }

    func distance(a: hex, b: hex) sint {
        var vec = hex::subtract(a, b);
        return (sint::abs(vec.q) + sint::abs(vec.r) + sint::abs(vec.s)) / 2;
    }
}

enum resource {
    BRICK;
    ORE;
    SHEEP;
    WHEAT;
    WOOD;

    func data(self: *resource) []byte {
        switch *self {
        BRICK {
            return "brick";
        }
        ORE {
            return "ore";
        }
        SHEEP {
            return "sheep";
        }
        WHEAT {
            return "wheat";
        }
        WOOD {
            return "wood";
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[[]byte]]();
    }

    func cstr(self: *resource) *byte {
        return startof(self.*.data());
    }

    func format(self: *resource, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            return std::write_all(writer, self.*.data());
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }
}

struct tile {
    var hex: hex;
    var kind: enum {
        DESERT;
        OCEAN;

        FOREST;
        FIELD;
        HILL;
        MOUNTAIN;
        PASTURE;
    };
    var number: sint;

    let SELF: tile = uninit;

    func init(hex: hex, kind: typeof(SELF.kind), number: sint) tile {
        return (:tile){
            .hex = hex,
            .kind = kind,
            .number = number,
        };
    }

    func resource(self: *tile) std::optional[[::resource]] {
        switch self.*.kind {
        tile::DESERT or tile::OCEAN {
            return std::optional[[::resource]]::EMPTY;
        }
        tile::FOREST {
            return std::optional[[::resource]]::init_value(::resource::WOOD);
        }
        tile::FIELD {
            return std::optional[[::resource]]::init_value(::resource::WHEAT);
        }
        tile::HILL {
            return std::optional[[::resource]]::init_value(::resource::BRICK);
        }
        tile::MOUNTAIN {
            return std::optional[[::resource]]::init_value(::resource::ORE);
        }
        tile::PASTURE {
            return std::optional[[::resource]]::init_value(::resource::SHEEP);
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[std::optional[[::resource]]]]();
    }

    func format(self: *tile, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        var kind = "<error>";
        switch self.*.kind {
        tile::DESERT {
            kind = "desert";
        }
        tile::OCEAN {
            kind = "ocean";
        }
        tile::FOREST {
            kind = "forest";
        }
        tile::FIELD {
            kind = "field";
        }
        tile::HILL {
            kind = "hill";
        }
        tile::MOUNTAIN {
            kind = "mountain";
        }
        tile::PASTURE {
            kind = "pasture";
        }
        }

        if std::str::eq(fmt, "") {
            return std::write_all(writer, kind);
        }

        if std::str::eq(fmt, "verbose") {
            var resource = self.*.resource();
            if resource.is_empty() {
                return std::write_all(writer, kind);
            }

            var resource = resource.value();
            return std::write_format(
                writer,
                "{} ({}, {})",
                (:[]std::formatter)[
                    std::formatter::init[[[]byte]](&kind),
                    std::formatter::init[[::resource]](&resource),
                    std::formatter::init[[sint]](&self.*.number)]);
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }

    func init_from_bubby(value: *bubby::value) tile {
        var hex = hex::init_from_bubby(value.*.map_xlookup_str("hex"));
        var number = xstr_to_int[[sint]](value.*.map_xlookup_str("number").*.str());
        var kind = value.*.map_xlookup_str("kind").*.str();
        if std::str::eq(kind, "desert") {
            return tile::init(hex, tile::DESERT, number);
        }
        if std::str::eq(kind, "ocean") {
            return tile::init(hex, tile::OCEAN, number);
        }
        if std::str::eq(kind, "forest") {
            return tile::init(hex, tile::FOREST, number);
        }
        if std::str::eq(kind, "field") {
            return tile::init(hex, tile::FIELD, number);
        }
        if std::str::eq(kind, "hill") {
            return tile::init(hex, tile::HILL, number);
        }
        if std::str::eq(kind, "mountain") {
            return tile::init(hex, tile::MOUNTAIN, number);
        }
        if std::str::eq(kind, "pasture") {
            return tile::init(hex, tile::PASTURE, number);
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[tile]]();
    }

    func to_bubby(self: *tile) bubby::value {
        var out = bubby::value::init_map();
        out.map().*.insert(bubby::value::init_str("hex"), self.*.hex.to_bubby());
        switch self.*.kind {
        tile::DESERT {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("desert"));
        }
        tile::OCEAN {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("ocean"));
        }
        tile::FOREST {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("forest"));
        }
        tile::FIELD {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("field"));
        }
        tile::HILL {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("hill"));
        }
        tile::MOUNTAIN {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("mountain"));
        }
        tile::PASTURE {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("pasture"));
        }
        }
        out.map().*.insert(bubby::value::init_str("number"), int_to_bubby[[sint]](self.*.number));
        return out;
    }
}

struct edge {
    var hexes: [2]hex;

    func init(a: hex, b: hex) edge {
        assert hex::distance(a, b) == 1;

        var hexes = (:[2]hex)[a, b];
        std::sort[[hex]](hexes[0:countof(hexes)]);

        return (:edge){
            .hexes = hexes,
        };
    }

    func hash(self: *edge) usize {
        var hash = 0u;
        for i in countof(self.*.hexes) {
            hash = hash +% self.*.hexes[i].hash();
        }
        return hash;
    }

    func compare(lhs: *edge, rhs: *edge) ssize {
        var cmp = hex::compare(&lhs.*.hexes[0], &rhs.*.hexes[0]);
        if cmp != 0 {
            return cmp;
        }

        var cmp = hex::compare(&lhs.*.hexes[1], &rhs.*.hexes[1]);
        if cmp != 0 {
            return cmp;
        }

        return 0;
    }

    func format(self: *edge, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            for i in countof(self.*.hexes) {
                if i != 0 {
                    std::print(writer, ", ");
                }
                std::print_format(
                    writer,
                    "{}",
                    (:[]std::formatter)[
                        std::formatter::init[[hex]](&self.*.hexes[i])]);
            }

            return std::result[[void, std::error]]::init_value(void::VALUE);
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }

    func init_from_bubby(value: *bubby::value) edge {
        return edge::init(
            hex::init_from_bubby(&value.*.vec().*.data()[0]),
            hex::init_from_bubby(&value.*.vec().*.data()[1]));
    }

    func to_bubby(self: *edge) bubby::value {
        var out = bubby::value::init_vec();
        for i in countof(self.*.hexes) {
            out.vec().*.push(self.*.hexes[i].to_bubby());
        }
        return out;
    }
}

struct node {
    var hexes: [3]hex;

    func init(a: hex, b: hex, c: hex) node {
        assert hex::distance(a, b) == 1;
        assert hex::distance(b, c) == 1;
        assert hex::distance(c, a) == 1;

        var hexes = (:[3]hex)[a, b, c];
        std::sort[[hex]](hexes[0:countof(hexes)]);

        return (:node){
            .hexes = hexes,
        };
    }

    func hash(self: *node) usize {
        var hash = 0u;
        for i in countof(self.*.hexes) {
            hash = hash +% self.*.hexes[i].hash();
        }
        return hash;
    }

    func compare(lhs: *node, rhs: *node) ssize {
        var cmp = hex::compare(&lhs.*.hexes[0], &rhs.*.hexes[0]);
        if cmp != 0 {
            return cmp;
        }

        var cmp = hex::compare(&lhs.*.hexes[1], &rhs.*.hexes[1]);
        if cmp != 0 {
            return cmp;
        }

        var cmp = hex::compare(&lhs.*.hexes[2], &rhs.*.hexes[2]);
        if cmp != 0 {
            return cmp;
        }

        return 0;
    }

    func format(self: *node, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            for i in countof(self.*.hexes) {
                if i != 0 {
                    std::print(writer, ", ");
                }
                std::print_format(
                    writer,
                    "{}",
                    (:[]std::formatter)[
                        std::formatter::init[[hex]](&self.*.hexes[i])]);
            }

            return std::result[[void, std::error]]::init_value(void::VALUE);
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }

    func init_from_bubby(value: *bubby::value) node {
        return node::init(
            hex::init_from_bubby(&value.*.vec().*.data()[0]),
            hex::init_from_bubby(&value.*.vec().*.data()[1]),
            hex::init_from_bubby(&value.*.vec().*.data()[2]));
    }

    func to_bubby(self: *node) bubby::value {
        var out = bubby::value::init_vec();
        for i in countof(self.*.hexes) {
            out.vec().*.push(self.*.hexes[i].to_bubby());
        }
        return out;
    }
}

struct port {
    var hex: hex;
    var nodes: [2]node;
    var kind: enum {
        ANY;
        BRICK;
        ORE;
        SHEEP;
        WHEAT;
        WOOD;
    };

    let SELF: port = uninit;

    func init(hex: hex, a: node, b: node, kind: typeof(SELF.kind)) port {
        assert std::eq[[::hex]](&hex, &a.hexes[0])
            or std::eq[[::hex]](&hex, &a.hexes[1])
            or std::eq[[::hex]](&hex, &a.hexes[2]);
        assert std::eq[[::hex]](&hex, &b.hexes[0])
            or std::eq[[::hex]](&hex, &b.hexes[1])
            or std::eq[[::hex]](&hex, &b.hexes[2]);
        assert std::ne[[node]](&a, &b);

        var nodes = (:[2]node)[a, b];
        std::sort[[node]](nodes[0:countof(nodes)]);

        return (:port){
            .hex = hex,
            .nodes = nodes,
            .kind = kind,
        };
    }

    func hash(self: *port) usize {
        return self.*.hex.hash();
    }

    func compare(lhs: *port, rhs: *port) ssize {
        return std::compare[[hex]](&lhs.*.hex, &rhs.*.hex);
    }

    func init_from_bubby(value: *bubby::value) port {
        var hex = hex::init_from_bubby(value.*.map_xlookup_str("hex"));
        var node_a = node::init_from_bubby(&value.*.map_xlookup_str("nodes").*.vec().*.data()[0]);
        var node_b = node::init_from_bubby(&value.*.map_xlookup_str("nodes").*.vec().*.data()[1]);
        var kind = value.*.map_xlookup_str("kind").*.str();
        if std::str::eq(kind, "any") {
            return port::init(hex, node_a, node_b, port::ANY);
        }
        if std::str::eq(kind, "brick") {
            return port::init(hex, node_a, node_b, port::BRICK);
        }
        if std::str::eq(kind, "ore") {
            return port::init(hex, node_a, node_b, port::ORE);
        }
        if std::str::eq(kind, "sheep") {
            return port::init(hex, node_a, node_b, port::SHEEP);
        }
        if std::str::eq(kind, "wheat") {
            return port::init(hex, node_a, node_b, port::WHEAT);
        }
        if std::str::eq(kind, "wood") {
            return port::init(hex, node_a, node_b, port::WOOD);
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[port]]();
    }

    func to_bubby(self: *port) bubby::value {
        var out = bubby::value::init_map();
        out.map().*.insert(bubby::value::init_str("hex"), self.*.hex.to_bubby());
        out.map().*.insert(bubby::value::init_str("nodes"), bubby::value::init_vec());
        out.map_xlookup_str("nodes").*.vec().*.push(self.*.nodes[0].to_bubby());
        out.map_xlookup_str("nodes").*.vec().*.push(self.*.nodes[1].to_bubby());
        switch self.*.kind {
        port::ANY {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("any"));
        }
        port::BRICK {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("brick"));
        }
        port::ORE {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("ore"));
        }
        port::SHEEP {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("sheep"));
        }
        port::WHEAT {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("wheat"));
        }
        port::WOOD {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("wood"));
        }
        }
        return out;
    }
}

struct road {
    var player: player;
    var edge: edge;

    func init(player: player, edge: edge) road {
        return (:road){
            .edge = edge,
            .player = player,
        };
    }

    func hash(self: *road) usize {
        return self.*.edge.hash();
    }

    func compare(lhs: *road, rhs: *road) ssize {
        return std::compare[[edge]](&lhs.*.edge, &rhs.*.edge);
    }

    func init_from_bubby(value: *bubby::value) road {
        return road::init(
            (:player)xstr_to_int[[ssize]](value.*.map_xlookup_str("player").*.str()),
            edge::init_from_bubby(value.*.map_xlookup_str("edge")));
    }

    func to_bubby(self: *road) bubby::value {
        var out = bubby::value::init_map();
        out.map_insert_str("player", int_to_bubby[[ssize]]((:ssize)self.*.player));
        out.map_insert_str("edge", self.*.edge.to_bubby());
        return out;
    }
}

struct town {
    var player: player;
    var node: node;
    var kind: enum {
        SETTLEMENT;
        CITY;
    };

    let SELF: town = uninit;

    func init(player: player, node: node, kind: typeof(SELF.kind)) town {
        return (:town){
            .player = player,
            .node = node,
            .kind = kind,
        };
    }

    func hash(self: *town) usize {
        return self.*.node.hash();
    }

    func compare(lhs: *town, rhs: *town) ssize {
        return std::compare[[node]](&lhs.*.node, &rhs.*.node);
    }

    func init_from_bubby(value: *bubby::value) town {
        var player = (:player)xstr_to_int[[ssize]](value.*.map_xlookup_str("player").*.str());
        var node = node::init_from_bubby(value.*.map_xlookup_str("node"));
        var kind = value.*.map_xlookup_str("kind").*.str();
        if std::str::eq(kind, "settlement") {
            return town::init(player, node, town::SETTLEMENT);
        }
        if std::str::eq(kind, "city") {
            return town::init(player, node, town::CITY);
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[town]]();
    }

    func to_bubby(self: *town) bubby::value {
        var out = bubby::value::init_map();
        out.map_insert_str("player", int_to_bubby[[ssize]]((:ssize)self.*.player));
        out.map_insert_str("node", self.*.node.to_bubby());
        switch self.*.kind {
        town::SETTLEMENT {
            out.map_insert_str("kind", bubby::value::init_str("settlement"));
        }
        town::CITY {
            out.map_insert_str("kind", bubby::value::init_str("city"));
        }
        }
        return out;
    }
}

struct board {
    var tiles: std::hash_map[[hex, tile]];
    var edges: std::hash_set[[edge]];
    var nodes: std::hash_set[[node]];
    var ports: std::hash_set[[port]];
    var roads: std::hash_map[[edge, road]];
    var towns: std::hash_map[[node, town]];
    var robber: hex;
    var d6_a: sint;
    var d6_b: sint;

    func init() board {
        var tiles = std::hash_map[[hex, tile]]::init();
        var edges = std::hash_set[[edge]]::init();
        var nodes = std::hash_set[[node]]::init();
        var ports = std::hash_set[[port]]::init();
        var roads = std::hash_map[[edge, road]]::init();
        var towns = std::hash_map[[node, town]]::init();
        var robber = hex::init(+0, +0, +0);
        var d6 = (:sint)1;

        return (:board){
            .tiles = tiles,
            .edges = edges,
            .nodes = nodes,
            .ports = ports,
            .roads = roads,
            .towns = towns,
            .robber = robber,
            .d6_a = d6,
            .d6_b = d6,
        };
    }

    func init_assign(from: *board) board {
        var self = board::init();
        board::assign(&self, from);
        return self;
    }

    func init_starter_map_for_beginners() board {
        var tiles = init_starter_map_for_beginners_tiles();
        var edges = init_edges(&tiles);
        var nodes = init_nodes(&tiles);
        var ports = init_starter_map_for_beginners_ports();
        var roads = init_starter_map_for_beginners_roads();
        var towns = init_starter_map_for_beginners_towns();
        var robber = hex::init(+0, +0, +0);
        var d6 = (:sint)1;

        return (:board){
            .tiles = tiles,
            .edges = edges,
            .nodes = nodes,
            .ports = ports,
            .roads = roads,
            .towns = towns,
            .robber = robber,
            .d6_a = d6,
            .d6_b = d6,
        };
    }

    func fini(self: *board) void {
        self.*.tiles.fini();
        self.*.edges.fini();
        self.*.nodes.fini();
        self.*.ports.fini();
        self.*.roads.fini();
        self.*.towns.fini();
    }

    func assign(self: *board, from: *board) void {
        std::hash_map[[hex, tile]]::assign(&self.*.tiles, &from.*.tiles);
        std::hash_set[[edge]]::assign(&self.*.edges, &from.*.edges);
        std::hash_set[[node]]::assign(&self.*.nodes, &from.*.nodes);
        std::hash_set[[port]]::assign(&self.*.ports, &from.*.ports);
        std::hash_map[[edge, road]]::assign(&self.*.roads, &from.*.roads);
        std::hash_map[[node, town]]::assign(&self.*.towns, &from.*.towns);
        self.*.robber = from.*.robber;
        self.*.d6_a = from.*.d6_a;
        self.*.d6_b = from.*.d6_b;
    }

    func init_from_bubby(value: *bubby::value) board {
        var self = board::init();
        var tiles = value.*.map_xlookup_str("tiles");
        var iter = std::hash_set_iterator[[bubby::value]]::init(tiles.*.set());
        for iter.advance() {
            var tile = tile::init_from_bubby(iter.current());
            self.tiles.insert(tile.hex, tile);
        }
        self.edges.fini();
        self.edges = init_edges(&self.tiles);
        self.nodes.fini();
        self.nodes = init_nodes(&self.tiles);
        var ports = value.*.map_xlookup_str("ports");
        var iter = std::hash_set_iterator[[bubby::value]]::init(ports.*.set());
        for iter.advance() {
            var port = port::init_from_bubby(iter.current());
            self.ports.insert(port);
        }
        var roads = value.*.map_xlookup_str("roads");
        var iter = std::hash_set_iterator[[bubby::value]]::init(roads.*.set());
        for iter.advance() {
            var road = road::init_from_bubby(iter.current());
            self.roads.insert(road.edge, road);
        }
        var towns = value.*.map_xlookup_str("towns");
        var iter = std::hash_set_iterator[[bubby::value]]::init(towns.*.set());
        for iter.advance() {
            var town = town::init_from_bubby(iter.current());
            self.towns.insert(town.node, town);
        }
        self.robber = hex::init_from_bubby(value.*.map_xlookup_str("robber"));
        self.d6_a = xstr_to_int[[sint]](value.*.map_xlookup_str("d6-a").*.str());
        self.d6_b = xstr_to_int[[sint]](value.*.map_xlookup_str("d6-b").*.str());
        return self;
    }

    func to_bubby(self: *board) bubby::value {
        var out = bubby::value::init_map();
        out.map_insert_str("tiles", bubby::value::init_set());
        var iter = std::hash_map_iterator[[hex, tile]]::init(&self.*.tiles);
        for iter.advance() {
            var tile = iter.current().*.value.*.to_bubby();
            out.map_xlookup_str("tiles").*.set_insert(tile);
        }
        out.map_insert_str("ports", bubby::value::init_set());
        var iter = std::hash_set_iterator[[port]]::init(&self.*.ports);
        for iter.advance() {
            var port = iter.current().*.to_bubby();
            out.map_xlookup_str("ports").*.set_insert(port);
        }
        out.map_insert_str("roads", bubby::value::init_set());
        var iter = std::hash_map_iterator[[edge, road]]::init(&self.*.roads);
        for iter.advance() {
            var road = iter.current().*.value.*.to_bubby();
            out.map_xlookup_str("roads").*.set_insert(road);
        }
        out.map_insert_str("towns", bubby::value::init_set());
        var iter = std::hash_map_iterator[[node, town]]::init(&self.*.towns);
        for iter.advance() {
            var town = iter.current().*.value.*.to_bubby();
            out.map_xlookup_str("towns").*.set_insert(town);
        }
        out.map_insert_str("robber", self.*.robber.to_bubby());
        out.map_insert_str("d6-a", int_to_bubby[[sint]](self.*.d6_a));
        out.map_insert_str("d6-b", int_to_bubby[[sint]](self.*.d6_b));
        return out;
    }
}

func insert_tile(tiles: *std::hash_map[[hex, tile]], tile: tile) void {
    tiles.*.insert(tile.hex, tile);
}

func insert_road(roads: *std::hash_map[[edge, road]], road: road) void {
    roads.*.insert(road.edge, road);
}

func insert_town(towns: *std::hash_map[[node, town]], town: town) void {
    towns.*.insert(town.node, town);
}

func init_starter_map_for_beginners_tiles() std::hash_map[[hex, tile]] {
    var tiles = std::hash_map[[hex, tile]]::init();

    # top row
    insert_tile(&tiles, tile::init(hex::init(+0, -2, +2), tile::MOUNTAIN, 10));
    insert_tile(&tiles, tile::init(hex::init(+1, -2, +1), tile::PASTURE, 2));
    insert_tile(&tiles, tile::init(hex::init(+2, -2, +0), tile::FOREST, 9));
    # top-middle row
    insert_tile(&tiles, tile::init(hex::init(-1, -1, +2), tile::FIELD, 12));
    insert_tile(&tiles, tile::init(hex::init(+0, -1, +1), tile::HILL, 6));
    insert_tile(&tiles, tile::init(hex::init(+1, -1, +0), tile::PASTURE, 4));
    insert_tile(&tiles, tile::init(hex::init(+2, -1, -1), tile::HILL, 10));
    # middle row
    insert_tile(&tiles, tile::init(hex::init(-2, +0, +2), tile::FIELD, 9));
    insert_tile(&tiles, tile::init(hex::init(-1, +0, +1), tile::FOREST, 11));
    insert_tile(&tiles, tile::init(hex::init(+0, +0, +0), tile::DESERT, -1));
    insert_tile(&tiles, tile::init(hex::init(+1, +0, -1), tile::FOREST, 3));
    insert_tile(&tiles, tile::init(hex::init(+2, +0, -2), tile::MOUNTAIN, 8));
    # bottom-middle row
    insert_tile(&tiles, tile::init(hex::init(-2, +1, +1), tile::FOREST, 8));
    insert_tile(&tiles, tile::init(hex::init(-1, +1, +0), tile::MOUNTAIN, 3));
    insert_tile(&tiles, tile::init(hex::init(+0, +1, -1), tile::FIELD, 4));
    insert_tile(&tiles, tile::init(hex::init(+1, +1, -2), tile::PASTURE, 5));
    # bottom row
    insert_tile(&tiles, tile::init(hex::init(-2, +2, +0), tile::HILL, 5));
    insert_tile(&tiles, tile::init(hex::init(-1, +2, -1), tile::FIELD, 6));
    insert_tile(&tiles, tile::init(hex::init(+0, +2, -2), tile::PASTURE, 11));
    # adjacent ocean
    insert_tile(&tiles, tile::init(hex::init(+0, -3, +3), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+1, -3, +2), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+2, -3, +1), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+3, -3, +0), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-1, -2, +3), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+3, -2, -1), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-2, -1, +3), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+3, -1, -2), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-3, +0, +3), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+3, +0, -3), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-3, +1, +2), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+2, +1, -3), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-3, +2, +1), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+1, +2, -3), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-3, +3, +0), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-2, +3, -1), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-1, +3, -2), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+0, +3, -3), tile::OCEAN, -1));

    return tiles;
}

func init_edges(tiles: *std::hash_map[[hex, tile]]) std::hash_set[[edge]] {
    var edges = std::hash_set[[edge]]::init();

    var iter_i = std::hash_map_iterator[[hex, tile]]::init(tiles);
    for iter_i.advance() {
        var iter_j = std::hash_map_iterator[[hex, tile]]::init(tiles);
        for iter_j.advance() {
            if hex::distance(*iter_i.current().*.key, *iter_j.current().*.key) != 1 {
                continue;
            }
            var edge = edge::init(
                *iter_i.current().*.key,
                *iter_j.current().*.key);
            edges.insert(edge);
        }
    }

    return edges;
}

func init_nodes(tiles: *std::hash_map[[hex, tile]]) std::hash_set[[node]] {
    var nodes = std::hash_set[[node]]::init();

    var iter_i = std::hash_map_iterator[[hex, tile]]::init(tiles);
    for iter_i.advance() {
        var iter_j = std::hash_map_iterator[[hex, tile]]::init(tiles);
        for iter_j.advance() {
            var iter_k = std::hash_map_iterator[[hex, tile]]::init(tiles);
            for iter_k.advance() {
                if hex::distance(*iter_i.current().*.key, *iter_j.current().*.key) != 1 {
                    continue;
                }
                if hex::distance(*iter_j.current().*.key, *iter_k.current().*.key) != 1 {
                    continue;
                }
                if hex::distance(*iter_k.current().*.key, *iter_i.current().*.key) != 1 {
                    continue;
                }
                var node = node::init(
                    *iter_i.current().*.key,
                    *iter_j.current().*.key,
                    *iter_k.current().*.key);
                nodes.insert(node);
            }
        }
    }

    return nodes;
}

func init_starter_map_for_beginners_ports() std::hash_set[[port]] {
    var ports = std::hash_set[[port]]::init();

    ports.insert(port::init(
        hex::init(+3, +0, -3),
        node::init(
            hex::init(+2, +0, -2),
            hex::init(+2, +1, -3),
            hex::init(+3, +0, -3)),
        node::init(
            hex::init(+2, +0, -2),
            hex::init(+3, -1, -2),
            hex::init(+3, +0, -3)),
        port::ANY));

    ports.insert(port::init(
        hex::init(+3, -2, -1),
        node::init(
            hex::init(+2, -2, +0),
            hex::init(+2, -1, -1),
            hex::init(+3, -2, -1)),
        node::init(
            hex::init(+2, -1, -1),
            hex::init(+3, -2, -1),
            hex::init(+3, -1, -2)),
        port::ORE));

    ports.insert(port::init(
        hex::init(+2, -3, +1),
        node::init(
            hex::init(+1, -3, +2),
            hex::init(+1, -2, +1),
            hex::init(+2, -3, +1)),
        node::init(
            hex::init(+1, -2, +1),
            hex::init(+2, -3, +1),
            hex::init(+2, -2, +0)),
        port::WHEAT));

    ports.insert(port::init(
        hex::init(+0, -3, +3),
        node::init(
            hex::init(-1, -2, +3),
            hex::init(+0, -3, +3),
            hex::init(+0, -2, +2)),
        node::init(
            hex::init(+0, -3, +3),
            hex::init(+0, -2, +2),
            hex::init(+1, -3, +2)),
        port::ANY));

    ports.insert(port::init(
        hex::init(-2, -1, +3),
        node::init(
            hex::init(-2, -1, +3),
            hex::init(-2, +0, +2),
            hex::init(-1, -1, +2)),
        node::init(
            hex::init(-2, -1, +3),
            hex::init(-1, -2, +3),
            hex::init(-1, -1, +2)),
        port::WOOD));

    ports.insert(port::init(
        hex::init(-3, +1, +2),
        node::init(
            hex::init(-3, +1, +2),
            hex::init(-3, +2, +1),
            hex::init(-2, +1, +1)),
        node::init(
            hex::init(-3, +1, +2),
            hex::init(-2, +0, +2),
            hex::init(-2, +1, +1)),
        port::BRICK));

    ports.insert(port::init(
        hex::init(-3, +3, +0),
        node::init(
            hex::init(-3, +2, +1),
            hex::init(-3, +3, +0),
            hex::init(-2, +2, +0)),
        node::init(
            hex::init(-3, +3, +0),
            hex::init(-2, +2, +0),
            hex::init(-2, +3, -1)),
        port::ANY));

    ports.insert(port::init(
        hex::init(-1, +3, -2),
        node::init(
            hex::init(-2, +3, -1),
            hex::init(-1, +2, -1),
            hex::init(-1, +3, -2)),
        node::init(
            hex::init(-1, +2, -1),
            hex::init(-1, +3, -2),
            hex::init(+0, +2, -2)),
        port::ANY));

    ports.insert(port::init(
        hex::init(+1, +2, -3),
        node::init(
            hex::init(+0, +2, -2),
            hex::init(+1, +1, -2),
            hex::init(+1, +2, -3)),
        node::init(
            hex::init(+1, +1, -2),
            hex::init(+1, +2, -3),
            hex::init(+2, +1, -3)),
        port::SHEEP));

    return ports;
}

func init_starter_map_for_beginners_roads() std::hash_map[[edge, road]] {
    var roads = std::hash_map[[edge, road]]::init();

    # Red starting position.
    insert_road(&roads, road::init(
        player::RED,
        edge::init(
            hex::init(-2, +1, +1),
            hex::init(-1, +0, +1))));
    insert_road(&roads, road::init(
        player::RED,
        edge::init(
            hex::init(+0, -1, +1),
            hex::init(+1, -2, +1))));

    # Blue starting position.
    insert_road(&roads, road::init(
        player::BLUE,
        edge::init(
            hex::init(-2, +2, +0),
            hex::init(-1, +1, +0))));
    insert_road(&roads, road::init(
        player::BLUE,
        edge::init(
            hex::init(+0, +1, -1),
            hex::init(+1, +1, -2))));

    # White starting position.
    insert_road(&roads, road::init(
        player::WHITE,
        edge::init(
            hex::init(-1, -1, +2),
            hex::init(-1, +0, +1))));
    insert_road(&roads, road::init(
        player::WHITE,
        edge::init(
            hex::init(+1, +0, -1),
            hex::init(+2, +0, -2))));

    # Orange starting position.
    insert_road(&roads, road::init(
        player::ORANGE,
        edge::init(
            hex::init(-1, +2, -1),
            hex::init(+0, +1, -1))));
    insert_road(&roads, road::init(
        player::ORANGE,
        edge::init(
            hex::init(+1, -1, +0),
            hex::init(+2, -2, +0))));

    return roads;
}

func init_starter_map_for_beginners_towns() std::hash_map[[node, town]] {
    var towns = std::hash_map[[node, town]]::init();

    # Red starting position.
    insert_town(&towns, town::init(
        player::RED,
        node::init(
            hex::init(-2, +0, +2),
            hex::init(-2, +1, +1),
            hex::init(-1, +0, +1)),
        town::SETTLEMENT));
    insert_town(&towns, town::init(
        player::RED,
        node::init(
            hex::init(+0, -2, +2),
            hex::init(+0, -1, +1),
            hex::init(+1, -2, +1)),
        town::SETTLEMENT));

    # Blue starting position.
    insert_town(&towns, town::init(
        player::BLUE,
        node::init(
            hex::init(-2, +1, +1),
            hex::init(-2, +2, +0),
            hex::init(-1, +1, +0)),
        town::SETTLEMENT));
    insert_town(&towns, town::init(
        player::BLUE,
        node::init(
            hex::init(+0, +1, -1),
            hex::init(+0, +2, -2),
            hex::init(+1, +1, -2)),
        town::SETTLEMENT));

    # White starting position.
    insert_town(&towns, town::init(
        player::WHITE,
        node::init(
            hex::init(-1, -1, +2),
            hex::init(-1, +0, +1),
            hex::init(+0, -1, +1)),
        town::SETTLEMENT));
    insert_town(&towns, town::init(
        player::WHITE,
        node::init(
            hex::init(+1, +0, -1),
            hex::init(+1, +1, -2),
            hex::init(+2, +0, -2)),
        town::SETTLEMENT));

    # Orange starting position.
    insert_town(&towns, town::init(
        player::ORANGE,
        node::init(
            hex::init(-1, +1, +0),
            hex::init(-1, +2, -1),
            hex::init(+0, +1, -1)),
        town::SETTLEMENT));
    insert_town(&towns, town::init(
        player::ORANGE,
        node::init(
            hex::init(+1, -1, +0),
            hex::init(+2, -2, +0),
            hex::init(+2, -1, -1)),
        town::SETTLEMENT));

    return towns;
}

func adjacent_edges_to_edge(target: edge, edges: *std::hash_set[[edge]], nodes: *std::hash_set[[node]]) std::hash_set[[edge]] {
    var out = std::hash_set[[edge]]::init();

    var adjacent_nodes = adjacent_nodes_to_edge(target, nodes);
    defer adjacent_nodes.fini();

    var iter = std::hash_set_iterator[[node]]::init(&adjacent_nodes);
    for iter.advance() {
        var adjacent_edges = adjacent_edges_to_node(*iter.current(), edges);
        defer adjacent_edges.fini();

        var iter = std::hash_set_iterator[[edge]]::init(&adjacent_edges);
        for iter.advance() {
            if not std::eq[[edge]](&target, iter.current()) {
                out.insert(*iter.current());
            }
        }
    }

    return out;
}

func adjacent_nodes_to_edge(target: edge, nodes: *std::hash_set[[node]]) std::hash_set[[node]] {
    var out = std::hash_set[[node]]::init();

    var a = std::hash_set[[hex]]::init();
    defer a.fini();
    a.insert(target.hexes[0]);
    a.insert(target.hexes[1]);

    var iter = std::hash_set_iterator[[node]]::init(nodes);
    for iter.advance() {
        var b = std::hash_set[[hex]]::init();
        defer b.fini();
        b.insert(iter.current().*.hexes[0]);
        b.insert(iter.current().*.hexes[1]);
        b.insert(iter.current().*.hexes[2]);

        var intersection = std::hash_set[[hex]]::init_intersection(&a, &b);
        defer intersection.fini();
        if intersection.count() == 2 {
            out.insert(*iter.current());
        }
    }

    return out;
}

func adjacent_edges_to_node(target: node, edges: *std::hash_set[[edge]]) std::hash_set[[edge]] {
    var out = std::hash_set[[edge]]::init();

    var a = std::hash_set[[hex]]::init();
    defer a.fini();
    a.insert(target.hexes[0]);
    a.insert(target.hexes[1]);
    a.insert(target.hexes[2]);

    var iter = std::hash_set_iterator[[edge]]::init(edges);
    for iter.advance() {
        var b = std::hash_set[[hex]]::init();
        defer b.fini();
        b.insert(iter.current().*.hexes[0]);
        b.insert(iter.current().*.hexes[1]);

        var intersection = std::hash_set[[hex]]::init_intersection(&a, &b);
        defer intersection.fini();
        if intersection.count() == 2 {
            out.insert(*iter.current());
        }
    }

    return out;
}

func adjacent_nodes_to_node(target: node, nodes: *std::hash_set[[node]]) std::hash_set[[node]] {
    var out = std::hash_set[[node]]::init();

    var a = std::hash_set[[hex]]::init();
    defer a.fini();
    a.insert(target.hexes[0]);
    a.insert(target.hexes[1]);
    a.insert(target.hexes[2]);

    var iter = std::hash_set_iterator[[node]]::init(nodes);
    for iter.advance() {
        var b = std::hash_set[[hex]]::init();
        defer b.fini();
        b.insert(iter.current().*.hexes[0]);
        b.insert(iter.current().*.hexes[1]);
        b.insert(iter.current().*.hexes[2]);

        var intersection = std::hash_set[[hex]]::init_intersection(&a, &b);
        defer intersection.fini();
        if intersection.count() == 2 {
            out.insert(*iter.current());
        }
    }

    return out;
}

struct hand {
    var brick: sint;
    var ore: sint;
    var sheep: sint;
    var wheat: sint;
    var wood: sint;

    func init_from_bubby(value: *bubby::value) hand {
        var self: hand = uninit;
        self.brick = xstr_to_int[[sint]](value.*.map_xlookup_str("brick").*.str());
        self.ore = xstr_to_int[[sint]](value.*.map_xlookup_str("ore").*.str());
        self.sheep = xstr_to_int[[sint]](value.*.map_xlookup_str("sheep").*.str());
        self.wheat = xstr_to_int[[sint]](value.*.map_xlookup_str("wheat").*.str());
        self.wood = xstr_to_int[[sint]](value.*.map_xlookup_str("wood").*.str());
        return self;
    }

    func to_bubby(self: *hand) bubby::value {
        var out = bubby::value::init_map();
        out.map_insert_str("brick", int_to_bubby[[sint]](self.*.brick));
        out.map_insert_str("ore", int_to_bubby[[sint]](self.*.ore));
        out.map_insert_str("sheep", int_to_bubby[[sint]](self.*.sheep));
        out.map_insert_str("wheat", int_to_bubby[[sint]](self.*.wheat));
        out.map_insert_str("wood", int_to_bubby[[sint]](self.*.wood));
        return out;
    }

    func resources(self: *hand) sint {
        return self.*.brick + self.*.ore + self.*.sheep + self.*.wheat + self.*.wood;
    }
}

enum phase {
    RESOURCE_PRODUCTION;
    MAIN;

    func init_from_bubby(value: *bubby::value) phase {
        if std::str::eq(value.*.str(), "resource-production") {
            return RESOURCE_PRODUCTION;
        }
        if std::str::eq(value.*.str(), "main") {
            return MAIN;
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[phase]]();
    }

    func to_bubby(self: *phase) bubby::value {
        switch *self {
        RESOURCE_PRODUCTION {
            return bubby::value::init_str("resource-production");
        }
        MAIN {
            return bubby::value::init_str("main");
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[bubby::value]]();
    }
}

struct turn {
    var player: player;
    var phase: phase;

    func init(player: player) turn {
        return (:turn){
            .player = player,
            .phase = phase::RESOURCE_PRODUCTION,
        };
    }

    func init_from_bubby(value: *bubby::value) turn {
        var out: turn = uninit;
        out.player = bubby_to_player(value.*.map_xlookup_str("player"));
        out.phase = phase::init_from_bubby(value.*.map_xlookup_str("phase"));
        return out;
    }

    func to_bubby(self: *turn) bubby::value {
        var out = bubby::value::init_map();
        out.map().*.insert(bubby::value::init_str("player"), player_to_bubby(self.*.player));
        out.map().*.insert(bubby::value::init_str("phase"), self.*.phase.to_bubby());
        return out;
    }
}

let BUSY_CODE = (:sint)42; # nbnet busy code

struct message {
    let TYPE: u8 = 0;
    let SIZE: usize = 4096 * 4;

    var len: uint;
    var buf: [SIZE]char;

    func create() *message {
        return std::new[[message]]();
    }

    func destroy(self: *message) void {
        std::delete[[message]](self);
    }

    func serialize(self: *message, stream: *NBN_Stream) sint {
        stream.*.serialize_uint_func(stream, &self.*.len, 0, (:uint)SIZE);
        stream.*.serialize_bytes_func(stream, (:*u8)&self.*.buf[0], self.*.len);
        return 0;
    }
}

struct client_message {
    var kind: enum {
        ROLL;
        END_TURN;
        BUILD_ROAD;
        BUILD_TOWN;
        MOVE_ROBBER;
        SELECT_PLAYER;
    };
    var data: union {
        var build_road: road;
        var build_town: town;
        var move_robber: hex;
        var select_player: player;
    };

    let SELF: client_message = uninit;

    func init_roll() client_message {
        return (:client_message){
            .kind = client_message::ROLL,
            .data = uninit,
        };
    }

    func init_end_turn() client_message {
        return (:client_message){
            .kind = client_message::END_TURN,
            .data = uninit,
        };
    }

    func init_build_road(road: road) client_message {
        return (:client_message){
            .kind = client_message::BUILD_ROAD,
            .data = (:typeof(SELF.data)){.build_road = road},
        };
    }

    func init_build_town(town: town) client_message {
        return (:client_message){
            .kind = client_message::BUILD_TOWN,
            .data = (:typeof(SELF.data)){.build_town = town},
        };
    }

    func init_move_robber(hex: hex) client_message {
        return (:client_message){
            .kind = client_message::MOVE_ROBBER,
            .data = (:typeof(SELF.data)){.move_robber = hex},
        };
    }

    func init_select_player(selected: player) client_message {
        return (:client_message){
            .kind = client_message::SELECT_PLAYER,
            .data = (:typeof(SELF.data)){.select_player = selected},
        };
    }

    func init_from_bubby(value: *bubby::value) client_message {
        var kind = value.*.map_xlookup_str("kind");
        if std::str::eq(kind.*.str(), "roll") {
            return client_message::init_roll();
        }
        if std::str::eq(kind.*.str(), "end-turn") {
            return client_message::init_end_turn();
        }
        if std::str::eq(kind.*.str(), "build-road") {
            var road = road::init_from_bubby(value.*.map_xlookup_str("data"));
            return client_message::init_build_road(road);
        }
        if std::str::eq(kind.*.str(), "build-town") {
            var town = town::init_from_bubby(value.*.map_xlookup_str("data"));
            return client_message::init_build_town(town);
        }
        if std::str::eq(kind.*.str(), "move-robber") {
            var hex = hex::init_from_bubby(value.*.map_xlookup_str("data"));
            return client_message::init_move_robber(hex);
        }
        if std::str::eq(kind.*.str(), "select-player") {
            var selected = bubby_to_player(value.*.map_xlookup_str("data"));
            return client_message::init_select_player(selected);
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[client_message]]();
    }

    func to_bubby(self: *client_message) bubby::value {
        var out = bubby::value::init_map();
        switch self.*.kind {
        client_message::ROLL {
            out.map_insert_str("kind", bubby::value::init_str("roll"));
        }
        client_message::END_TURN {
            out.map_insert_str("kind", bubby::value::init_str("end-turn"));
        }
        client_message::BUILD_ROAD {
            out.map_insert_str("kind", bubby::value::init_str("build-road"));
            out.map_insert_str("data", self.*.data.build_road.to_bubby());
        }
        client_message::BUILD_TOWN {
            out.map_insert_str("kind", bubby::value::init_str("build-town"));
            out.map_insert_str("data", self.*.data.build_town.to_bubby());
        }
        client_message::MOVE_ROBBER {
            out.map_insert_str("kind", bubby::value::init_str("move-robber"));
            out.map_insert_str("data", self.*.data.move_robber.to_bubby());
        }
        client_message::SELECT_PLAYER {
            out.map_insert_str("kind", bubby::value::init_str("select-player"));
            out.map_insert_str("data", player_to_bubby(self.*.data.select_player));
        }
        }
        return out;
    }
}

struct server_message {
    var kind: enum {
        LOG;
        HAND;
        STATE;
        PLAYER;
        ACCEPTED;
        REJECTED;
    };
    var data: union {
        var log: std::string;
        var hand: hand;
        var state: struct {
            var board: board;
            var r_resources: sint;
            var b_resources: sint;
            var w_resources: sint;
            var o_resources: sint;
            var turn: turn;
        };
        var player: player;
        var accepted: std::string;
        var rejected: std::string;
    };

    let SELF: server_message = uninit;

    func init_log(text: []byte) server_message {
        return (:server_message){
            .kind = server_message::LOG,
            .data = (:typeof(SELF.data)){.log = std::string::init_from_str(text)},
        };
    }

    func init_log_format(format: []byte, args: []std::formatter) server_message {
        return (:server_message){
            .kind = server_message::LOG,
            .data = (:typeof(SELF.data)){.log = std::string::init_from_format(format, args)},
        };
    }

    func init_hand(hand: hand) server_message {
        return (:server_message){
            .kind = server_message::HAND,
            .data = (:typeof(SELF.data)){.hand = hand},
        };
    }

    func init_state(board: *board, r_resources: sint, b_resources: sint, w_resources: sint, o_resources: sint, turn: turn) server_message {
        return (:server_message){
            .kind = server_message::STATE,
            .data = (:typeof(SELF.data)){
                .state = (:typeof(SELF.data.state)){
                    .board = ::board::init_assign(board),
                    .r_resources = r_resources,
                    .b_resources = b_resources,
                    .w_resources = w_resources,
                    .o_resources = o_resources,
                    .turn = turn,
                }
            },
        };
    }

    func init_player(player: player) server_message {
        return (:server_message){
            .kind = server_message::PLAYER,
            .data = (:typeof(SELF.data)){.player = player},
        };
    }

    func init_accepted(text: []byte) server_message {
        return (:server_message){
            .kind = server_message::ACCEPTED,
            .data = (:typeof(SELF.data)){.accepted = std::string::init_from_str(text)},
        };
    }

    func init_accepted_format(format: []byte, args: []std::formatter) server_message {
        return (:server_message){
            .kind = server_message::ACCEPTED,
            .data = (:typeof(SELF.data)){.accepted = std::string::init_from_format(format, args)},
        };
    }

    func init_rejected(text: []byte) server_message {
        return (:server_message){
            .kind = server_message::REJECTED,
            .data = (:typeof(SELF.data)){.rejected = std::string::init_from_str(text)},
        };
    }

    func init_rejected_format(format: []byte, args: []std::formatter) server_message {
        return (:server_message){
            .kind = server_message::REJECTED,
            .data = (:typeof(SELF.data)){.rejected = std::string::init_from_format(format, args)},
        };
    }

    func fini(self: *server_message) void {
        switch self.*.kind {
        server_message::LOG {
            self.*.data.log.fini();
        }
        server_message::HAND {
            # nothing
        }
        server_message::STATE {
            self.*.data.state.board.fini();
        }
        server_message::PLAYER {
            # nothing
        }
        server_message::ACCEPTED {
            self.*.data.accepted.fini();
        }
        server_message::REJECTED {
            self.*.data.rejected.fini();
        }
        }
    }

    func init_from_bubby(value: *bubby::value) server_message {
        var kind = value.*.map_xlookup_str("kind").*.str();
        if std::str::eq(kind, "log") {
            return server_message::init_log(value.*.map_xlookup_str("data").*.str());
        }
        if std::str::eq(kind, "hand") {
            var hand = hand::init_from_bubby(value.*.map_xlookup_str("data"));
            return server_message::init_hand(hand);
        }
        if std::str::eq(kind, "state") {
            var state = value.*.map_xlookup_str("data");
            var board = board::init_from_bubby(state.*.map_xlookup_str("board"));
            defer board.fini();
            var r_resources = xstr_to_int[[sint]](state.*.map_xlookup_str("r-resources").*.str());
            var b_resources = xstr_to_int[[sint]](state.*.map_xlookup_str("b-resources").*.str());
            var w_resources = xstr_to_int[[sint]](state.*.map_xlookup_str("w-resources").*.str());
            var o_resources = xstr_to_int[[sint]](state.*.map_xlookup_str("o-resources").*.str());
            var turn = turn::init_from_bubby(state.*.map_xlookup_str("turn"));
            return server_message::init_state(&board, r_resources, b_resources, w_resources, o_resources, turn);
        }
        if std::str::eq(kind, "player") {
            var player = bubby_to_player(value.*.map_xlookup_str("data"));
            return server_message::init_player(player);
        }
        if std::str::eq(kind, "accepted") {
            return server_message::init_accepted(value.*.map_xlookup_str("data").*.str());
        }
        if std::str::eq(kind, "rejected") {
            return server_message::init_rejected(value.*.map_xlookup_str("data").*.str());
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[server_message]]();
    }

    func to_bubby(self: *server_message) bubby::value {
        var out = bubby::value::init_map();
        switch self.*.kind {
        server_message::LOG {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("log"));
            out.map().*.insert(bubby::value::init_str("data"), bubby::value::init_str(self.*.data.log.data()));
        }
        server_message::HAND {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("hand"));
            out.map().*.insert(bubby::value::init_str("data"), self.*.data.hand.to_bubby());
        }
        server_message::STATE {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("state"));
            var state = bubby::value::init_map();
            state.map().*.insert(bubby::value::init_str("board"), self.*.data.state.board.to_bubby());
            state.map().*.insert(bubby::value::init_str("r-resources"), int_to_bubby[[sint]](self.*.data.state.r_resources));
            state.map().*.insert(bubby::value::init_str("b-resources"), int_to_bubby[[sint]](self.*.data.state.b_resources));
            state.map().*.insert(bubby::value::init_str("w-resources"), int_to_bubby[[sint]](self.*.data.state.w_resources));
            state.map().*.insert(bubby::value::init_str("o-resources"), int_to_bubby[[sint]](self.*.data.state.o_resources));
            state.map().*.insert(bubby::value::init_str("turn"), self.*.data.state.turn.to_bubby());
            out.map().*.insert(bubby::value::init_str("data"), state);
        }
        server_message::PLAYER{
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("player"));
            out.map().*.insert(bubby::value::init_str("data"), player_to_bubby(self.*.data.player));
        }
        server_message::ACCEPTED {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("accepted"));
            out.map().*.insert(bubby::value::init_str("data"), bubby::value::init_str(self.*.data.accepted.data()));
        }
        server_message::REJECTED {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("rejected"));
            out.map().*.insert(bubby::value::init_str("data"), bubby::value::init_str(self.*.data.rejected.data()));
        }
        }
        return out;
    }
}

struct message_sender_itable[[MESSAGE]] {
    var send: func(*any, *MESSAGE) void;
}

struct message_sender[[MESSAGE]] {
    var itable: *message_sender_itable[[MESSAGE]];
    var object: *any;

    func init[[T]](object: *T) message_sender[[MESSAGE]] {
        let itable = (:message_sender_itable[[MESSAGE]]){
            .send = T::send,
        };
        return (:message_sender[[MESSAGE]]){
            .itable = &itable,
            .object = object,
        };
    }

    func send(self: *message_sender[[MESSAGE]], message: *MESSAGE) void {
        self.*.itable.*.send(self.*.object, message);
    }
}
