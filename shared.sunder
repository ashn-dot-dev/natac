import "c";
import "std";

import "bubby";

enum player {
    NIL = 0;
    RED = 1;
    BLUE = 2;
    WHITE = 3;
    ORANGE = 4;
}

# Hex position using the cube coordinate system satisfying q + r + s == 0.
struct hex {
    var q: sint;
    var r: sint;
    var s: sint;

    func init(q: sint, r: sint, s: sint) hex {
        assert q + r + s == 0;
        return (:hex){.q = q, .r = r, .s = s};
    }

    func init_round(q_fractional: f32, r_fractional: f32, s_fractional: f32) hex {
        var q_rounded = f32::round(q_fractional);
        var r_rounded = f32::round(r_fractional);
        var s_rounded = f32::round(s_fractional);

        var q_diff = f32::abs(q_rounded - q_fractional);
        var r_diff = f32::abs(r_rounded - r_fractional);
        var s_diff = f32::abs(s_rounded - s_fractional);

        var q = (:sint)q_rounded;
        var r = (:sint)r_rounded;
        var s = (:sint)s_rounded;
        if q_diff > r_diff and q_diff > s_diff {
            q = (:sint)-r_rounded - (:sint)s_rounded;
        }
        elif r_diff > s_diff {
            r = (:sint)-q_rounded - (:sint)s_rounded;
        }
        else {
            s = (:sint)-q_rounded - (:sint)r_rounded;
        }

        return hex::init(q, r, s);
    }

    func hash(self: *hex) usize {
        var h = self.*.q.hash() +% self.*.q.hash() +% self.*.s.hash();
        return h *% h;
    }

    func compare(lhs: *hex, rhs: *hex) ssize {
        var cmp = sint::cmp(lhs.*.q, rhs.*.q);
        if cmp != 0 {
            return cmp;
        }

        var cmp = sint::cmp(lhs.*.r, rhs.*.r);
        if cmp != 0 {
            return cmp;
        }

        var cmp = sint::cmp(lhs.*.s, rhs.*.s);
        if cmp != 0 {
            return cmp;
        }

        return 0;
    }

    func format(self: *hex, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            return std::write_format(
                writer,
                "(q={}, r={}, s={})",
                (:[]std::formatter)[
                    std::formatter::init[[sint]](&self.*.q),
                    std::formatter::init[[sint]](&self.*.r),
                    std::formatter::init[[sint]](&self.*.s)]);
        }

        return std::result[[void, std::error]]::init_value(void::VALUE);
    }

    func init_from_bubby(value: *bubby::value) hex {
        var q = (:sint)value.*.vec().*.data()[0].int();
        var r = (:sint)value.*.vec().*.data()[1].int();
        var s = -q - r;
        return hex::init(q, r, s);
    }

    func to_bubby(self: *hex) bubby::value {
        var out = bubby::value::init_vec();
        out.vec().*.push(bubby::value::init_int((:s64)self.*.q));
        out.vec().*.push(bubby::value::init_int((:s64)self.*.r));
        return out;
    }

    func subtract(lhs: hex, rhs: hex) hex {
        return hex::init(lhs.q - rhs.q, lhs.r - rhs.r, lhs.s - rhs.s);
    }

    func distance(a: hex, b: hex) sint {
        var vec = hex::subtract(a, b);
        return (sint::abs(vec.q) + sint::abs(vec.r) + sint::abs(vec.s)) / 2;
    }
}

enum resource {
    BRICK;
    ORE;
    SHEEP;
    WHEAT;
    WOOD;

    func data(self: *resource) []byte {
        switch *self {
        BRICK {
            return "brick";
        }
        ORE {
            return "ore";
        }
        SHEEP {
            return "sheep";
        }
        WHEAT {
            return "wheat";
        }
        WOOD {
            return "wood";
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[[]byte]]();
    }

    func cstr(self: *resource) *byte {
        return startof(self.*.data());
    }

    func format(self: *resource, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            return std::write_all(writer, self.*.data());
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }
}

struct tile {
    var hex: hex;
    var kind: enum {
        DESERT;
        OCEAN;

        FOREST;
        FIELD;
        HILL;
        MOUNTAIN;
        PASTURE;
    };
    var number_token: sint;

    let SELF: tile = uninit;

    func init(hex: hex, kind: typeof(SELF.kind), number_token: sint) tile {
        return (:tile){
            .hex = hex,
            .kind = kind,
            .number_token = number_token,
        };
    }

    func resource(self: *tile) std::optional[[::resource]] {
        switch self.*.kind {
        tile::DESERT or tile::OCEAN {
            return std::optional[[::resource]]::EMPTY;
        }
        tile::FOREST {
            return std::optional[[::resource]]::init_value(::resource::WOOD);
        }
        tile::FIELD {
            return std::optional[[::resource]]::init_value(::resource::WHEAT);
        }
        tile::HILL {
            return std::optional[[::resource]]::init_value(::resource::BRICK);
        }
        tile::MOUNTAIN {
            return std::optional[[::resource]]::init_value(::resource::ORE);
        }
        tile::PASTURE {
            return std::optional[[::resource]]::init_value(::resource::SHEEP);
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[std::optional[[::resource]]]]();
    }

    func format(self: *tile, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        var kind = "<error>";
        switch self.*.kind {
        tile::DESERT {
            kind = "desert";
        }
        tile::OCEAN {
            kind = "ocean";
        }
        tile::FOREST {
            kind = "forest";
        }
        tile::FIELD {
            kind = "field";
        }
        tile::HILL {
            kind = "hill";
        }
        tile::MOUNTAIN {
            kind = "mountain";
        }
        tile::PASTURE {
            kind = "pasture";
        }
        }

        if std::str::eq(fmt, "") {
            return std::write_all(writer, kind);
        }

        if std::str::eq(fmt, "verbose") {
            var resource = self.*.resource();
            if resource.is_empty() {
                return std::write_all(writer, kind);
            }

            var resource = resource.value();
            return std::write_format(
                writer,
                "{} ({}, {})",
                (:[]std::formatter)[
                    std::formatter::init[[[]byte]](&kind),
                    std::formatter::init[[::resource]](&resource),
                    std::formatter::init[[sint]](&self.*.number_token)]);
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }

    func init_from_bubby(value: *bubby::value) tile {
        var hex = hex::init_from_bubby(value.*.map_xlookup_str("hex"));
        var number = (:sint)value.*.map_xlookup_str("number").*.int();
        var kind = value.*.map_xlookup_str("kind").*.str();
        if std::str::eq(kind, "desert") {
            return tile::init(hex, tile::DESERT, number);
        }
        elif std::str::eq(kind, "ocean") {
            return tile::init(hex, tile::OCEAN, number);
        }
        elif std::str::eq(kind, "forest") {
            return tile::init(hex, tile::FOREST, number);
        }
        elif std::str::eq(kind, "field") {
            return tile::init(hex, tile::FIELD, number);
        }
        elif std::str::eq(kind, "hill") {
            return tile::init(hex, tile::HILL, number);
        }
        elif std::str::eq(kind, "mountain") {
            return tile::init(hex, tile::MOUNTAIN, number);
        }
        elif std::str::eq(kind, "pasture") {
            return tile::init(hex, tile::PASTURE, number);
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[tile]]();
    }

    func to_bubby(self: *tile) bubby::value {
        var out = bubby::value::init_map();
        out.map().*.insert(bubby::value::init_str("hex"), self.*.hex.to_bubby());
        switch self.*.kind {
        tile::DESERT {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("desert"));
        }
        tile::OCEAN {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("ocean"));
        }
        tile::FOREST {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("forest"));
        }
        tile::FIELD {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("field"));
        }
        tile::HILL {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("hill"));
        }
        tile::MOUNTAIN {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("mountain"));
        }
        tile::PASTURE {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("pasture"));
        }
        }
        out.map().*.insert(bubby::value::init_str("number"), bubby::value::init_int((:s64)self.*.number_token));
        return out;
    }
}

struct edge {
    var hexes: [2]hex;

    func init(a: hex, b: hex) edge {
        assert hex::distance(a, b) == 1;

        var hexes = (:[2]hex)[a, b];
        std::sort[[hex]](hexes[0:countof(hexes)]);

        return (:edge){
            .hexes = hexes,
        };
    }

    func hash(self: *edge) usize {
        var hash = 0u;
        for i in countof(self.*.hexes) {
            hash = hash +% self.*.hexes[i].hash();
        }
        return hash;
    }

    func compare(lhs: *edge, rhs: *edge) ssize {
        var cmp = hex::compare(&lhs.*.hexes[0], &rhs.*.hexes[0]);
        if cmp != 0 {
            return cmp;
        }

        var cmp = hex::compare(&lhs.*.hexes[1], &rhs.*.hexes[1]);
        if cmp != 0 {
            return cmp;
        }

        return 0;
    }

    func format(self: *edge, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            for i in countof(self.*.hexes) {
                if i != 0 {
                    std::print(writer, ", ");
                }
                std::print_format(
                    writer,
                    "{}",
                    (:[]std::formatter)[
                        std::formatter::init[[hex]](&self.*.hexes[i])]);
            }

            return std::result[[void, std::error]]::init_value(void::VALUE);
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }

    func init_from_bubby(value: *bubby::value) edge {
        return edge::init(
            hex::init_from_bubby(&value.*.vec().*.data()[0]),
            hex::init_from_bubby(&value.*.vec().*.data()[1]));
    }

    func to_bubby(self: *edge) bubby::value {
        var out = bubby::value::init_vec();
        for i in countof(self.*.hexes) {
            out.vec().*.push(self.*.hexes[i].to_bubby());
        }
        return out;
    }
}

struct node {
    var hexes: [3]hex;

    func init(a: hex, b: hex, c: hex) node {
        assert hex::distance(a, b) == 1;
        assert hex::distance(b, c) == 1;
        assert hex::distance(c, a) == 1;

        var hexes = (:[3]hex)[a, b, c];
        std::sort[[hex]](hexes[0:countof(hexes)]);

        return (:node){
            .hexes = hexes,
        };
    }

    func hash(self: *node) usize {
        var hash = 0u;
        for i in countof(self.*.hexes) {
            hash = hash +% self.*.hexes[i].hash();
        }
        return hash;
    }

    func compare(lhs: *node, rhs: *node) ssize {
        var cmp = hex::compare(&lhs.*.hexes[0], &rhs.*.hexes[0]);
        if cmp != 0 {
            return cmp;
        }

        var cmp = hex::compare(&lhs.*.hexes[1], &rhs.*.hexes[1]);
        if cmp != 0 {
            return cmp;
        }

        var cmp = hex::compare(&lhs.*.hexes[2], &rhs.*.hexes[2]);
        if cmp != 0 {
            return cmp;
        }

        return 0;
    }

    func format(self: *node, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            for i in countof(self.*.hexes) {
                if i != 0 {
                    std::print(writer, ", ");
                }
                std::print_format(
                    writer,
                    "{}",
                    (:[]std::formatter)[
                        std::formatter::init[[hex]](&self.*.hexes[i])]);
            }

            return std::result[[void, std::error]]::init_value(void::VALUE);
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }

    func init_from_bubby(value: *bubby::value) node {
        return node::init(
            hex::init_from_bubby(&value.*.vec().*.data()[0]),
            hex::init_from_bubby(&value.*.vec().*.data()[1]),
            hex::init_from_bubby(&value.*.vec().*.data()[2]));
    }

    func to_bubby(self: *node) bubby::value {
        var out = bubby::value::init_vec();
        for i in countof(self.*.hexes) {
            out.vec().*.push(self.*.hexes[i].to_bubby());
        }
        return out;
    }
}

struct port {
    var hex: hex;
    var nodes: [2]node;
    var kind: enum {
        ANY;
        BRICK;
        ORE;
        SHEEP;
        WHEAT;
        WOOD;
    };

    let SELF: port = uninit;

    func init(hex: hex, a: node, b: node, kind: typeof(SELF.kind)) port {
        assert std::eq[[::hex]](&hex, &a.hexes[0])
            or std::eq[[::hex]](&hex, &a.hexes[1])
            or std::eq[[::hex]](&hex, &a.hexes[2]);
        assert std::eq[[::hex]](&hex, &b.hexes[0])
            or std::eq[[::hex]](&hex, &b.hexes[1])
            or std::eq[[::hex]](&hex, &b.hexes[2]);
        assert std::ne[[node]](&a, &b);

        var nodes = (:[2]node)[a, b];
        std::sort[[node]](nodes[0:countof(nodes)]);

        return (:port){
            .hex = hex,
            .nodes = nodes,
            .kind = kind,
        };
    }

    func hash(self: *port) usize {
        return self.*.hex.hash();
    }

    func compare(lhs: *port, rhs: *port) ssize {
        return std::compare[[hex]](&lhs.*.hex, &rhs.*.hex);
    }

    func init_from_bubby(value: *bubby::value) port {
        var hex = hex::init_from_bubby(value.*.map_xlookup_str("hex"));
        var node_a = node::init_from_bubby(&value.*.map_xlookup_str("nodes").*.vec().*.data()[0]);
        var node_b = node::init_from_bubby(&value.*.map_xlookup_str("nodes").*.vec().*.data()[1]);
        var kind = value.*.map_xlookup_str("kind").*.str();
        if std::str::eq(kind, "any") {
            return port::init(hex, node_a, node_b, port::ANY);
        }
        if std::str::eq(kind, "brick") {
            return port::init(hex, node_a, node_b, port::BRICK);
        }
        if std::str::eq(kind, "ore") {
            return port::init(hex, node_a, node_b, port::ORE);
        }
        if std::str::eq(kind, "sheep") {
            return port::init(hex, node_a, node_b, port::SHEEP);
        }
        if std::str::eq(kind, "wheat") {
            return port::init(hex, node_a, node_b, port::WHEAT);
        }
        if std::str::eq(kind, "wood") {
            return port::init(hex, node_a, node_b, port::WOOD);
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[port]]();
    }

    func to_bubby(self: *port) bubby::value {
        var out = bubby::value::init_map();
        out.map().*.insert(bubby::value::init_str("hex"), self.*.hex.to_bubby());
        out.map().*.insert(bubby::value::init_str("nodes"), bubby::value::init_vec());
        out.map_xlookup_str("nodes").*.vec().*.push(self.*.nodes[0].to_bubby());
        out.map_xlookup_str("nodes").*.vec().*.push(self.*.nodes[1].to_bubby());
        switch self.*.kind {
        port::ANY {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("any"));
        }
        port::BRICK {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("brick"));
        }
        port::ORE {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("ore"));
        }
        port::SHEEP {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("sheep"));
        }
        port::WHEAT {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("wheat"));
        }
        port::WOOD {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("wood"));
        }
        }
        return out;
    }
}

struct road {
    var player: player;
    var edge: edge;

    func init(player: player, edge: edge) road {
        return (:road){
            .edge = edge,
            .player = player,
        };
    }

    func init_from_bubby(value: *bubby::value) road {
        return road::init(
            (:player)value.*.map_xlookup_str("player").*.int(),
            edge::init_from_bubby(value.*.map_xlookup_str("edge")));
    }

    func to_bubby(self: *road) bubby::value {
        var out = bubby::value::init_map();
        out.map_insert_str("player", bubby::value::init_int((:s64)self.*.player));
        out.map_insert_str("edge", self.*.edge.to_bubby());
        return out;
    }
}

struct town {
    var player: player;
    var node: node;
    var kind: enum {
        SETTLEMENT;
        CITY;
    };

    let SELF: town = uninit;

    func init(player: player, node: node, kind: typeof(SELF.kind)) town {
        return (:town){
            .player = player,
            .node = node,
            .kind = kind,
        };
    }

    func init_from_bubby(value: *bubby::value) town {
        var kind_value = value.*.map_xlookup_str("kind");
        var kind = town::SETTLEMENT;
        if std::str::eq(kind_value.*.str(), "settlement") {
            kind = town::SETTLEMENT;
        }
        elif std::str::eq(kind_value.*.str(), "city") {
            kind = town::CITY;
        }

        return town::init(
            (:player)value.*.map_xlookup_str("player").*.int(),
            node::init_from_bubby(value.*.map_xlookup_str("node")),
            kind);
    }

    func to_bubby(self: *town) bubby::value {
        var out = bubby::value::init_map();
        out.map_insert_str("player", bubby::value::init_int((:s64)self.*.player));
        out.map_insert_str("node", self.*.node.to_bubby());
        switch self.*.kind {
        town::SETTLEMENT {
            out.map_insert_str("kind", bubby::value::init_str("settlement"));
        }
        town::CITY {
            out.map_insert_str("kind", bubby::value::init_str("city"));
        }
        }
        return out;
    }
}

struct board {
    var tiles: std::hash_map[[hex, tile]];
    var edges: std::hash_set[[edge]];
    var nodes: std::hash_set[[node]];
    var ports: std::hash_set[[port]];
    var roads: std::hash_map[[edge, road]];
    var towns: std::hash_map[[node, town]];
    var robber: hex;

    func init() board {
        var tiles = std::hash_map[[hex, tile]]::init();
        var edges = std::hash_set[[edge]]::init();
        var nodes = std::hash_set[[node]]::init();
        var ports = std::hash_set[[port]]::init();
        var roads = std::hash_map[[edge, road]]::init();
        var towns = std::hash_map[[node, town]]::init();
        var robber = hex::init(+0, +0, +0);

        return (:board){
            .tiles = tiles,
            .edges = edges,
            .nodes = nodes,
            .ports = ports,
            .roads = roads,
            .towns = towns,
            .robber = robber,
        };
    }

    func init_assign(from: *board) board {
        var self = board::init();
        board::assign(&self, from);
        return self;
    }

    func init_starter_map_for_beginners() board {
        var tiles = init_tiles();
        var edges = init_edges(&tiles);
        var nodes = init_nodes(&tiles);
        var ports = init_ports();
        var roads = init_roads();
        var towns = init_towns();
        var robber = hex::init(+0, +0, +0);

        return (:board){
            .tiles = tiles,
            .edges = edges,
            .nodes = nodes,
            .ports = ports,
            .roads = roads,
            .towns = towns,
            .robber = robber,
        };
    }

    func fini(self: *board) void {
        self.*.tiles.fini();
        self.*.edges.fini();
        self.*.nodes.fini();
        self.*.ports.fini();
        self.*.roads.fini();
        self.*.towns.fini();
    }

    func assign(self: *board, from: *board) void {
        std::hash_map[[hex, tile]]::assign(&self.*.tiles, &from.*.tiles);
        std::hash_set[[edge]]::assign(&self.*.edges, &from.*.edges);
        std::hash_set[[node]]::assign(&self.*.nodes, &from.*.nodes);
        std::hash_set[[port]]::assign(&self.*.ports, &from.*.ports);
        std::hash_map[[edge, road]]::assign(&self.*.roads, &from.*.roads);
        std::hash_map[[node, town]]::assign(&self.*.towns, &from.*.towns);
        self.*.robber = from.*.robber;
    }

    func init_from_bubby(value: *bubby::value) board {
        var self = board::init();
        var tiles = value.*.map_xlookup_str("tiles");
        var iter = std::hash_set_iterator[[bubby::value]]::init(tiles.*.set());
        for iter.advance() {
            var tile = tile::init_from_bubby(iter.current());
            self.tiles.insert(tile.hex, tile);
        }
        self.edges.fini();
        self.edges = init_edges(&self.tiles);
        self.nodes.fini();
        self.nodes = init_nodes(&self.tiles);
        var ports = value.*.map_xlookup_str("ports");
        var iter = std::hash_set_iterator[[bubby::value]]::init(ports.*.set());
        for iter.advance() {
            var port = port::init_from_bubby(iter.current());
            self.ports.insert(port);
        }
        var roads = value.*.map_xlookup_str("roads");
        var iter = std::hash_set_iterator[[bubby::value]]::init(roads.*.set());
        for iter.advance() {
            var road = road::init_from_bubby(iter.current());
            self.roads.insert(road.edge, road);
        }
        var towns = value.*.map_xlookup_str("towns");
        var iter = std::hash_set_iterator[[bubby::value]]::init(towns.*.set());
        for iter.advance() {
            var town = town::init_from_bubby(iter.current());
            self.towns.insert(town.node, town);
        }
        self.robber = hex::init_from_bubby(value.*.map_xlookup_str("robber"));
        return self;
    }

    func to_bubby(self: *board) bubby::value {
        var out = bubby::value::init_map();
        out.map_insert_str("tiles", bubby::value::init_set());
        var iter = std::hash_map_iterator[[hex, tile]]::init(&self.*.tiles);
        for iter.advance() {
            var tile = iter.current().*.value.*.to_bubby();
            out.map_xlookup_str("tiles").*.set_insert(tile);
        }
        out.map_insert_str("ports", bubby::value::init_set());
        var iter = std::hash_set_iterator[[port]]::init(&self.*.ports);
        for iter.advance() {
            var port = iter.current().*.to_bubby();
            out.map_xlookup_str("ports").*.set_insert(port);
        }
        out.map_insert_str("roads", bubby::value::init_set());
        var iter = std::hash_map_iterator[[edge, road]]::init(&self.*.roads);
        for iter.advance() {
            var road = iter.current().*.value.*.to_bubby();
            out.map_xlookup_str("roads").*.set_insert(road);
        }
        out.map_insert_str("towns", bubby::value::init_set());
        var iter = std::hash_map_iterator[[node, town]]::init(&self.*.towns);
        for iter.advance() {
            var town = iter.current().*.value.*.to_bubby();
            out.map_xlookup_str("towns").*.set_insert(town);
        }
        out.map_insert_str("robber", self.*.robber.to_bubby());
        return out;
    }
}

func insert_tile(tiles: *std::hash_map[[hex, tile]], tile: tile) void {
    tiles.*.insert(tile.hex, tile);
}

func insert_road(roads: *std::hash_map[[edge, road]], road: road) void {
    roads.*.insert(road.edge, road);
}

func insert_town(towns: *std::hash_map[[node, town]], town: town) void {
    towns.*.insert(town.node, town);
}

func init_tiles() std::hash_map[[hex, tile]] {
    var tiles = std::hash_map[[hex, tile]]::init();

    # top row
    insert_tile(&tiles, tile::init(hex::init(+0, -2, +2), tile::MOUNTAIN, 10));
    insert_tile(&tiles, tile::init(hex::init(+1, -2, +1), tile::PASTURE, 2));
    insert_tile(&tiles, tile::init(hex::init(+2, -2, +0), tile::FOREST, 9));
    # top-middle row
    insert_tile(&tiles, tile::init(hex::init(-1, -1, +2), tile::FIELD, 12));
    insert_tile(&tiles, tile::init(hex::init(+0, -1, +1), tile::HILL, 6));
    insert_tile(&tiles, tile::init(hex::init(+1, -1, +0), tile::PASTURE, 4));
    insert_tile(&tiles, tile::init(hex::init(+2, -1, -1), tile::HILL, 10));
    # middle row
    insert_tile(&tiles, tile::init(hex::init(-2, +0, +2), tile::FIELD, 9));
    insert_tile(&tiles, tile::init(hex::init(-1, +0, +1), tile::FOREST, 11));
    insert_tile(&tiles, tile::init(hex::init(+0, +0, +0), tile::DESERT, -1));
    insert_tile(&tiles, tile::init(hex::init(+1, +0, -1), tile::FOREST, 3));
    insert_tile(&tiles, tile::init(hex::init(+2, +0, -2), tile::MOUNTAIN, 8));
    # bottom-middle row
    insert_tile(&tiles, tile::init(hex::init(-2, +1, +1), tile::FOREST, 8));
    insert_tile(&tiles, tile::init(hex::init(-1, +1, +0), tile::MOUNTAIN, 3));
    insert_tile(&tiles, tile::init(hex::init(+0, +1, -1), tile::FIELD, 4));
    insert_tile(&tiles, tile::init(hex::init(+1, +1, -2), tile::PASTURE, 5));
    # bottom row
    insert_tile(&tiles, tile::init(hex::init(-2, +2, +0), tile::HILL, 5));
    insert_tile(&tiles, tile::init(hex::init(-1, +2, -1), tile::FIELD, 6));
    insert_tile(&tiles, tile::init(hex::init(+0, +2, -2), tile::PASTURE, 11));
    # adjacent ocean
    insert_tile(&tiles, tile::init(hex::init(+0, -3, +3), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+1, -3, +2), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+2, -3, +1), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+3, -3, +0), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-1, -2, +3), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+3, -2, -1), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-2, -1, +3), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+3, -1, -2), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-3, +0, +3), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+3, +0, -3), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-3, +1, +2), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+2, +1, -3), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-3, +2, +1), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+1, +2, -3), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-3, +3, +0), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-2, +3, -1), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-1, +3, -2), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+0, +3, -3), tile::OCEAN, -1));

    return tiles;
}

func init_edges(tiles: *std::hash_map[[hex, tile]]) std::hash_set[[edge]] {
    var edges = std::hash_set[[edge]]::init();

    var iter_i = std::hash_map_iterator[[hex, tile]]::init(tiles);
    for iter_i.advance() {
        var iter_j = std::hash_map_iterator[[hex, tile]]::init(tiles);
        for iter_j.advance() {
            if hex::distance(*iter_i.current().*.key, *iter_j.current().*.key) != 1 {
                continue;
            }
            var edge = edge::init(
                *iter_i.current().*.key,
                *iter_j.current().*.key);
            edges.insert(edge);
        }
    }

    return edges;
}

func init_nodes(tiles: *std::hash_map[[hex, tile]]) std::hash_set[[node]] {
    var nodes = std::hash_set[[node]]::init();

    var iter_i = std::hash_map_iterator[[hex, tile]]::init(tiles);
    for iter_i.advance() {
        var iter_j = std::hash_map_iterator[[hex, tile]]::init(tiles);
        for iter_j.advance() {
            var iter_k = std::hash_map_iterator[[hex, tile]]::init(tiles);
            for iter_k.advance() {
                if hex::distance(*iter_i.current().*.key, *iter_j.current().*.key) != 1 {
                    continue;
                }
                if hex::distance(*iter_j.current().*.key, *iter_k.current().*.key) != 1 {
                    continue;
                }
                if hex::distance(*iter_k.current().*.key, *iter_i.current().*.key) != 1 {
                    continue;
                }
                var node = node::init(
                    *iter_i.current().*.key,
                    *iter_j.current().*.key,
                    *iter_k.current().*.key);
                nodes.insert(node);
            }
        }
    }

    return nodes;
}

func init_ports() std::hash_set[[port]] {
    var ports = std::hash_set[[port]]::init();

    ports.insert(port::init(
        hex::init(+3, +0, -3),
        node::init(
            hex::init(+2, +0, -2),
            hex::init(+2, +1, -3),
            hex::init(+3, +0, -3)),
        node::init(
            hex::init(+2, +0, -2),
            hex::init(+3, -1, -2),
            hex::init(+3, +0, -3)),
        port::ANY));

    ports.insert(port::init(
        hex::init(+3, -2, -1),
        node::init(
            hex::init(+2, -2, +0),
            hex::init(+2, -1, -1),
            hex::init(+3, -2, -1)),
        node::init(
            hex::init(+2, -1, -1),
            hex::init(+3, -2, -1),
            hex::init(+3, -1, -2)),
        port::ORE));

    ports.insert(port::init(
        hex::init(+2, -3, +1),
        node::init(
            hex::init(+1, -3, +2),
            hex::init(+1, -2, +1),
            hex::init(+2, -3, +1)),
        node::init(
            hex::init(+1, -2, +1),
            hex::init(+2, -3, +1),
            hex::init(+2, -2, +0)),
        port::WHEAT));

    ports.insert(port::init(
        hex::init(+0, -3, +3),
        node::init(
            hex::init(-1, -2, +3),
            hex::init(+0, -3, +3),
            hex::init(+0, -2, +2)),
        node::init(
            hex::init(+0, -3, +3),
            hex::init(+0, -2, +2),
            hex::init(+1, -3, +2)),
        port::ANY));

    ports.insert(port::init(
        hex::init(-2, -1, +3),
        node::init(
            hex::init(-2, -1, +3),
            hex::init(-2, +0, +2),
            hex::init(-1, -1, +2)),
        node::init(
            hex::init(-2, -1, +3),
            hex::init(-1, -2, +3),
            hex::init(-1, -1, +2)),
        port::WOOD));

    ports.insert(port::init(
        hex::init(-3, +1, +2),
        node::init(
            hex::init(-3, +1, +2),
            hex::init(-3, +2, +1),
            hex::init(-2, +1, +1)),
        node::init(
            hex::init(-3, +1, +2),
            hex::init(-2, +0, +2),
            hex::init(-2, +1, +1)),
        port::BRICK));

    ports.insert(port::init(
        hex::init(-3, +3, +0),
        node::init(
            hex::init(-3, +2, +1),
            hex::init(-3, +3, +0),
            hex::init(-2, +2, +0)),
        node::init(
            hex::init(-3, +3, +0),
            hex::init(-2, +2, +0),
            hex::init(-2, +3, -1)),
        port::ANY));

    ports.insert(port::init(
        hex::init(-1, +3, -2),
        node::init(
            hex::init(-2, +3, -1),
            hex::init(-1, +2, -1),
            hex::init(-1, +3, -2)),
        node::init(
            hex::init(-1, +2, -1),
            hex::init(-1, +3, -2),
            hex::init(+0, +2, -2)),
        port::ANY));

    ports.insert(port::init(
        hex::init(+1, +2, -3),
        node::init(
            hex::init(+0, +2, -2),
            hex::init(+1, +1, -2),
            hex::init(+1, +2, -3)),
        node::init(
            hex::init(+1, +1, -2),
            hex::init(+1, +2, -3),
            hex::init(+2, +1, -3)),
        port::SHEEP));

    return ports;
}

func init_roads() std::hash_map[[edge, road]] {
    var roads = std::hash_map[[edge, road]]::init();

    # Red starting position.
    insert_road(&roads, road::init(
        player::RED,
        edge::init(
            hex::init(-2, +1, +1),
            hex::init(-1, +0, +1))));
    insert_road(&roads, road::init(
        player::RED,
        edge::init(
            hex::init(+0, -1, +1),
            hex::init(+1, -2, +1))));

    # Blue starting position.
    insert_road(&roads, road::init(
        player::BLUE,
        edge::init(
            hex::init(-2, +2, +0),
            hex::init(-1, +1, +0))));
    insert_road(&roads, road::init(
        player::BLUE,
        edge::init(
            hex::init(+0, +1, -1),
            hex::init(+1, +1, -2))));

    # White starting position.
    insert_road(&roads, road::init(
        player::WHITE,
        edge::init(
            hex::init(-1, -1, +2),
            hex::init(-1, +0, +1))));
    insert_road(&roads, road::init(
        player::WHITE,
        edge::init(
            hex::init(+1, +0, -1),
            hex::init(+2, +0, -2))));

    # Orange starting position.
    insert_road(&roads, road::init(
        player::ORANGE,
        edge::init(
            hex::init(-1, +2, -1),
            hex::init(+0, +1, -1))));
    insert_road(&roads, road::init(
        player::ORANGE,
        edge::init(
            hex::init(+1, -1, +0),
            hex::init(+2, -2, +0))));

    return roads;
}

func init_towns() std::hash_map[[node, town]] {
    var towns = std::hash_map[[node, town]]::init();

    # Red starting position.
    insert_town(&towns, town::init(
        player::RED,
        node::init(
            hex::init(-2, +0, +2),
            hex::init(-2, +1, +1),
            hex::init(-1, +0, +1)),
        town::SETTLEMENT));
    insert_town(&towns, town::init(
        player::RED,
        node::init(
            hex::init(+0, -2, +2),
            hex::init(+0, -1, +1),
            hex::init(+1, -2, +1)),
        town::SETTLEMENT));

    # Blue starting position.
    insert_town(&towns, town::init(
        player::BLUE,
        node::init(
            hex::init(-2, +1, +1),
            hex::init(-2, +2, +0),
            hex::init(-1, +1, +0)),
        town::SETTLEMENT));
    insert_town(&towns, town::init(
        player::BLUE,
        node::init(
            hex::init(+0, +1, -1),
            hex::init(+0, +2, -2),
            hex::init(+1, +1, -2)),
        town::SETTLEMENT));

    # White starting position.
    insert_town(&towns, town::init(
        player::WHITE,
        node::init(
            hex::init(-1, -1, +2),
            hex::init(-1, +0, +1),
            hex::init(+0, -1, +1)),
        town::SETTLEMENT));
    insert_town(&towns, town::init(
        player::WHITE,
        node::init(
            hex::init(+1, +0, -1),
            hex::init(+1, +1, -2),
            hex::init(+2, +0, -2)),
        town::SETTLEMENT));

    # Orange starting position.
    insert_town(&towns, town::init(
        player::ORANGE,
        node::init(
            hex::init(-1, +1, +0),
            hex::init(-1, +2, -1),
            hex::init(+0, +1, -1)),
        town::SETTLEMENT));
    insert_town(&towns, town::init(
        player::ORANGE,
        node::init(
            hex::init(+1, -1, +0),
            hex::init(+2, -2, +0),
            hex::init(+2, -1, -1)),
        town::SETTLEMENT));

    return towns;
}

let BUSY_CODE = (:sint)42; # nbnet busy code

struct client_message {
    var kind: enum {
        BUILD_ROAD;
        BUILD_TOWN;
        REMOVE_ROAD;
        REMOVE_TOWN;
    };
    var data: union {
        var build_road: road;
        var build_town: town;
        var remove_road: edge;
        var remove_town: node;
    };

    let SELF: client_message = uninit;

    func init_build_road(road: road) client_message {
        return (:client_message){
            .kind = client_message::BUILD_ROAD,
            .data = (:typeof(SELF.data)){.build_road = road},
        };
    }

    func init_build_town(town: town) client_message {
        return (:client_message){
            .kind = client_message::BUILD_TOWN,
            .data = (:typeof(SELF.data)){.build_town = town},
        };
    }

    func init_remove_road(road: edge) client_message {
        return (:client_message){
            .kind = client_message::REMOVE_ROAD,
            .data = (:typeof(SELF.data)){.remove_road = road},
        };
    }

    func init_remove_town(town: node) client_message {
        return (:client_message){
            .kind = client_message::REMOVE_TOWN,
            .data = (:typeof(SELF.data)){.remove_town = town},
        };
    }

    func init_from_bubby(value: *bubby::value) client_message {
        var kind = value.*.map_xlookup_str("kind");
        if std::str::eq(kind.*.str(), "build road") {
            var road = road::init_from_bubby(value.*.map_xlookup_str("data"));
            return client_message::init_build_road(road);
        }
        if std::str::eq(kind.*.str(), "build town") {
            var town = town::init_from_bubby(value.*.map_xlookup_str("data"));
            return client_message::init_build_town(town);
        }
        if std::str::eq(kind.*.str(), "remove road") {
            var edge = edge::init_from_bubby(value.*.map_xlookup_str("data"));
            return client_message::init_remove_road(edge);
        }
        if std::str::eq(kind.*.str(), "remove town") {
            var node = node::init_from_bubby(value.*.map_xlookup_str("data"));
            return client_message::init_remove_town(node);
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[client_message]]();
    }

    func to_bubby(self: *client_message) bubby::value {
        var out = bubby::value::init_map();
        switch self.*.kind {
        client_message::BUILD_ROAD {
            out.map_insert_str("kind", bubby::value::init_str("build road"));
            out.map_insert_str("data", self.*.data.build_road.to_bubby());
        }
        client_message::BUILD_TOWN {
            out.map_insert_str("kind", bubby::value::init_str("build town"));
            out.map_insert_str("data", self.*.data.build_town.to_bubby());
        }
        client_message::REMOVE_ROAD {
            out.map_insert_str("kind", bubby::value::init_str("remove road"));
            out.map_insert_str("data", self.*.data.remove_road.to_bubby());
        }
        client_message::REMOVE_TOWN {
            out.map_insert_str("kind", bubby::value::init_str("remove town"));
            out.map_insert_str("data", self.*.data.remove_town.to_bubby());
        }
        }
        return out;
    }
}

struct server_message {
    var board: board;

    func init(board: *board) server_message {
        var board_copy = ::board::init_assign(board);

        return (:server_message){
            .board = board_copy,
        };
    }

    func fini(self: *server_message) void {
        self.*.board.fini();
    }

    func init_from_bubby(value: *bubby::value) server_message {
        var board = board::init_from_bubby(value);
        defer board.fini();
        return server_message::init(&board);
    }

    func to_bubby(self: *server_message) bubby::value {
        return self.*.board.to_bubby();
    }
}

struct message_sender_itable[[MESSAGE]] {
    var send: func(*any, *MESSAGE) void;
}

struct message_sender[[MESSAGE]] {
    var itable: *message_sender_itable[[MESSAGE]];
    var object: *any;

    func init[[T]](object: *T) message_sender[[MESSAGE]] {
        let itable = (:message_sender_itable[[MESSAGE]]){
            .send = T::send,
        };
        return (:message_sender[[MESSAGE]]){
            .itable = &itable,
            .object = object,
        };
    }

    func send(self: *message_sender[[MESSAGE]], message: *MESSAGE) void {
        self.*.itable.*.send(self.*.object, message);
    }
}
