import "c";
import "std";

import "bubby";
import "nbnet";

# Dan Bernstein's original djb2 implementation.
#
# Source: http://www.cse.yorku.ca/~oz/hash.html
func djb2(str: []byte) u64 {
    var hash = 5381u64;
    for i in countof(str) {
        hash = ((hash << 5) +% hash) +% (:u64)str[i];
    }
    return hash;
}

# Simplified Permuted Congruential Generator algorithms (32 and 64 bit).
# Originally created by Christopher Wellons.
#
# Source: https://nullprogram.com/blog/2017/09/21/
var spcg32_state = 0xBADF00D01DC0FFEEu64;
var spcg64_state = (:[2]u64)[0xBADF00D01DC0FFEE, 0xCAFED00DCAFEBABE];

func spcg32(s: *u64) u32 {
    var m: u64 = 0x9b60933458e17d7d;
    var a: u64 = 0xd737232eeccdf7ed;
    *s = *s *% m +% a;
    var shift = 29 - (*s >> 61);
    return (:u32)(*s >> (:usize)shift);
}

func spcg64(s: *[2]u64) u64 {
    var m:  u64 = 0x9b60933458e17d7d;
    var a0: u64 = 0xd737232eeccdf7ed;
    var a1: u64 = 0x8b260b70b8e98891;
    var p0: u64 = s.*[0];
    var p1: u64 = s.*[1];
    s.*[0] = p0 *% m +% a0;
    s.*[1] = p1 *% m +% a1;
    var r0 = 29 - (p0 >> 61);
    var r1 = 29 - (p1 >> 61);
    var hi = p0 >> (:usize)r0;
    var lo = p1 >> (:usize)r1;
    return (hi << 32) | (lo & 0xFFFFFFFF);
}

func random32() u32 {
    return spcg32(&spcg32_state);
}

func random64() u64 {
    return spcg64(&spcg64_state);
}

func random_init(seed: []byte) void {
    spcg32_state = djb2(seed);
    spcg64_state = (:[2]u64)[
        (:u64)(random32() << 32) | (:u64)random32(),
        (:u64)(random32() << 32) | (:u64)random32(),
    ];
}

func random[[T]]() T {
    return (:T)random64();
}

func shuffle[[T]](slice: []T) void {
    if countof(slice) <= 1 {
        return;
    }

    var i = countof(slice) - 1;
    for i >= 1 {
        defer { i -= 1; }
        var j = random[[usize]]() % (i + 1);
        std::swap[[T]](&slice[i], &slice[j]);
    }
}

func d6() sint {
    return (:sint)(random64() % 6 + 1);
}

func xstr_to_bool(str: []byte) bool {
    var parsed = bool::init_from_str(str);
    return parsed.value();
}

func xstr_to_int[[T]](str: []byte) T {
    var parsed = T::init_from_str(str, 0);
    return parsed.value();
}

func bool_to_bubby(bool: bool) bubby::value {
    if bool {
        return bubby::value::init_str("true");
    }
    return bubby::value::init_str("false");
}

func int_to_bubby[[T]](int: T) bubby::value {
    return bubby::value::init_str_from_format("{}", (:[]std::formatter)[std::formatter::init[[T]](&int)]);
}

enum player {
    RED = 1;
    BLUE = 2;
    WHITE = 3;
    ORANGE = 4;
}

func name_to_player(name: []byte) player {
    if std::str::eq(name, "RED") {
        return ::player::RED;
    }
    if std::str::eq(name, "BLUE") {
        return ::player::BLUE;
    }
    if std::str::eq(name, "WHITE") {
        return ::player::WHITE;
    }
    if std::str::eq(name, "ORANGE") {
        return ::player::ORANGE;
    }

    std::unreachable(fileof(), lineof());
    return std::zeroed[[player]]();
}

func player_to_name(player: player) []byte {
    var out: []byte = uninit;
    switch player {
    ::player::RED {
        out = "RED";
    }
    ::player::BLUE {
        out = "BLUE";
    }
    ::player::WHITE {
        out = "WHITE";
    }
    ::player::ORANGE {
        out = "ORANGE";
    }
    }
    return out;
}

func player_to_bubby(player: player) bubby::value {
    var name = player_to_name(player);
    return bubby::value::init_str(name);
}

func bubby_to_player(value: *bubby::value) player {
    var name = value.*.str();
    return name_to_player(name);
}

# Hex position using the cube coordinate system satisfying q + r + s == 0.
struct hex {
    var q: sint;
    var r: sint;
    var s: sint;

    func init(q: sint, r: sint, s: sint) hex {
        assert q + r + s == 0;
        return (:hex){.q = q, .r = r, .s = s};
    }

    func init_round(q_fractional: f32, r_fractional: f32, s_fractional: f32) hex {
        var q_rounded = f32::round(q_fractional);
        var r_rounded = f32::round(r_fractional);
        var s_rounded = f32::round(s_fractional);

        var q_diff = f32::abs(q_rounded - q_fractional);
        var r_diff = f32::abs(r_rounded - r_fractional);
        var s_diff = f32::abs(s_rounded - s_fractional);

        var q = (:sint)q_rounded;
        var r = (:sint)r_rounded;
        var s = (:sint)s_rounded;
        if q_diff > r_diff and q_diff > s_diff {
            q = (:sint)-r_rounded - (:sint)s_rounded;
        }
        elif r_diff > s_diff {
            r = (:sint)-q_rounded - (:sint)s_rounded;
        }
        else {
            s = (:sint)-q_rounded - (:sint)r_rounded;
        }

        return hex::init(q, r, s);
    }

    func hash(self: *hex) usize {
        var h = self.*.q.hash() +% self.*.q.hash() +% self.*.s.hash();
        return h *% h;
    }

    func compare(lhs: *hex, rhs: *hex) ssize {
        var cmp = sint::cmp(lhs.*.q, rhs.*.q);
        if cmp != 0 {
            return cmp;
        }

        var cmp = sint::cmp(lhs.*.r, rhs.*.r);
        if cmp != 0 {
            return cmp;
        }

        var cmp = sint::cmp(lhs.*.s, rhs.*.s);
        if cmp != 0 {
            return cmp;
        }

        return 0;
    }

    func format(self: *hex, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            return std::write_format(
                writer,
                "(q={}, r={}, s={})",
                (:[]std::formatter)[
                    std::formatter::init[[sint]](&self.*.q),
                    std::formatter::init[[sint]](&self.*.r),
                    std::formatter::init[[sint]](&self.*.s)]);
        }

        return std::result[[void, std::error]]::init_value(void::VALUE);
    }

    func init_from_bubby(value: *bubby::value) hex {
        var q = xstr_to_int[[sint]](value.*.vec().*.data()[0].str());
        var r = xstr_to_int[[sint]](value.*.vec().*.data()[1].str());
        var s = -q - r;
        return hex::init(q, r, s);
    }

    func to_bubby(self: *hex) bubby::value {
        var out = bubby::value::init_vec();
        out.vec().*.push(int_to_bubby[[sint]](self.*.q));
        out.vec().*.push(int_to_bubby[[sint]](self.*.r));
        return out;
    }

    func subtract(lhs: hex, rhs: hex) hex {
        return hex::init(lhs.q - rhs.q, lhs.r - rhs.r, lhs.s - rhs.s);
    }

    func distance(a: hex, b: hex) sint {
        var vec = hex::subtract(a, b);
        return (sint::abs(vec.q) + sint::abs(vec.r) + sint::abs(vec.s)) / 2;
    }
}

enum resource {
    BRICK;
    ORE;
    SHEEP;
    WHEAT;
    WOOD;

    func data(self: *resource) []byte {
        switch *self {
        BRICK {
            return "brick";
        }
        ORE {
            return "ore";
        }
        SHEEP {
            return "sheep";
        }
        WHEAT {
            return "wheat";
        }
        WOOD {
            return "wood";
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[[]byte]]();
    }

    func cstr(self: *resource) *byte {
        return startof(self.*.data());
    }

    func format(self: *resource, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            return std::write_all(writer, self.*.data());
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }

    func init_from_bubby(value: *bubby::value) resource {
        for i in countof(RESOURCES) {
            if std::str::eq(value.*.str(), RESOURCES[i].data()) {
                return RESOURCES[i];
            }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[resource]]();
    }

    func to_bubby(self: *resource) bubby::value {
        return bubby::value::init_str(self.*.data());
    }
}

let RESOURCES = (:[]resource)[
    resource::BRICK,
    resource::ORE,
    resource::SHEEP,
    resource::WHEAT,
    resource::WOOD,
];

enum dev_card {
    KNIGHT;         # x14
    ROAD_BUILDING;  # x2
    YEAR_OF_PLENTY; # x2
    MONOPOLY;       # x2
    VICTORY_POINT;  # x5

    func init_from_bubby(value: *bubby::value) dev_card {
        if std::str::eq(value.*.str(), "knight") {
            return dev_card::KNIGHT;
        }
        if std::str::eq(value.*.str(), "road-building") {
            return dev_card::ROAD_BUILDING;
        }
        if std::str::eq(value.*.str(), "year-of-plenty") {
            return dev_card::YEAR_OF_PLENTY;
        }
        if std::str::eq(value.*.str(), "monopoly") {
            return dev_card::MONOPOLY;
        }
        if std::str::eq(value.*.str(), "victory-point") {
            return dev_card::VICTORY_POINT;
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[dev_card]]();
    }

    func to_bubby(self: *dev_card) bubby::value {
        switch *self {
        dev_card::KNIGHT {
            return bubby::value::init_str("knight");
        }
        dev_card::ROAD_BUILDING {
            return bubby::value::init_str("road-building");
        }
        dev_card::YEAR_OF_PLENTY {
            return bubby::value::init_str("year-of-plenty");
        }
        dev_card::MONOPOLY {
            return bubby::value::init_str("monopoly");
        }
        dev_card::VICTORY_POINT {
            return bubby::value::init_str("victory-point");
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[bubby::value]]();
    }
}

struct purchased_dev_card {
    var kind: dev_card;
    var turn: sint; # Turn the dev card was acquired.
    var used: bool; # True if the player has already used this dev card.

    func init_from_bubby(value: *bubby::value) purchased_dev_card {
        return (:purchased_dev_card){
            .kind = dev_card::init_from_bubby(value.*.map_xlookup_str("kind")),
            .turn = xstr_to_int[[sint]](value.*.map_xlookup_str("turn").*.str()),
            .used = xstr_to_bool(value.*.map_xlookup_str("used").*.str()),
        };
    }

    func to_bubby(self: *purchased_dev_card) bubby::value {
        var out = bubby::value::init_map();
        out.map_insert_str("kind", self.*.kind.to_bubby());
        out.map_insert_str("turn", int_to_bubby[[sint]](self.*.turn));
        out.map_insert_str("used", bool_to_bubby(self.*.used));
        return out;
    }
}

#   14 knight
#   02 road building
#   02 year of plenty
#   02 monopoly
# + 05 victory point
# -------------------
#   25 total
type dev_card_array           = [25]dev_card;
type purchased_dev_card_array = [25]purchased_dev_card;

struct tile {
    var hex: hex;
    var kind: enum {
        DESERT;
        OCEAN;

        FOREST;
        FIELD;
        HILL;
        MOUNTAIN;
        PASTURE;
    };
    var number: sint;

    let SELF: tile = uninit;

    func init(hex: hex, kind: typeof(SELF.kind), number: sint) tile {
        return (:tile){
            .hex = hex,
            .kind = kind,
            .number = number,
        };
    }

    func resource(self: *tile) std::optional[[::resource]] {
        switch self.*.kind {
        tile::DESERT or tile::OCEAN {
            return std::optional[[::resource]]::EMPTY;
        }
        tile::FOREST {
            return std::optional[[::resource]]::init_value(::resource::WOOD);
        }
        tile::FIELD {
            return std::optional[[::resource]]::init_value(::resource::WHEAT);
        }
        tile::HILL {
            return std::optional[[::resource]]::init_value(::resource::BRICK);
        }
        tile::MOUNTAIN {
            return std::optional[[::resource]]::init_value(::resource::ORE);
        }
        tile::PASTURE {
            return std::optional[[::resource]]::init_value(::resource::SHEEP);
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[std::optional[[::resource]]]]();
    }

    func format(self: *tile, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        var kind = "<error>";
        switch self.*.kind {
        tile::DESERT {
            kind = "desert";
        }
        tile::OCEAN {
            kind = "ocean";
        }
        tile::FOREST {
            kind = "forest";
        }
        tile::FIELD {
            kind = "field";
        }
        tile::HILL {
            kind = "hill";
        }
        tile::MOUNTAIN {
            kind = "mountain";
        }
        tile::PASTURE {
            kind = "pasture";
        }
        }

        if std::str::eq(fmt, "") {
            return std::write_all(writer, kind);
        }

        if std::str::eq(fmt, "verbose") {
            var resource = self.*.resource();
            if resource.is_empty() {
                return std::write_all(writer, kind);
            }

            var resource = resource.value();
            return std::write_format(
                writer,
                "{} ({}, {})",
                (:[]std::formatter)[
                    std::formatter::init[[[]byte]](&kind),
                    std::formatter::init[[::resource]](&resource),
                    std::formatter::init[[sint]](&self.*.number)]);
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }

    func init_from_bubby(value: *bubby::value) tile {
        var hex = hex::init_from_bubby(value.*.map_xlookup_str("hex"));
        var number = xstr_to_int[[sint]](value.*.map_xlookup_str("number").*.str());
        var kind = value.*.map_xlookup_str("kind").*.str();
        if std::str::eq(kind, "desert") {
            return tile::init(hex, tile::DESERT, number);
        }
        if std::str::eq(kind, "ocean") {
            return tile::init(hex, tile::OCEAN, number);
        }
        if std::str::eq(kind, "forest") {
            return tile::init(hex, tile::FOREST, number);
        }
        if std::str::eq(kind, "field") {
            return tile::init(hex, tile::FIELD, number);
        }
        if std::str::eq(kind, "hill") {
            return tile::init(hex, tile::HILL, number);
        }
        if std::str::eq(kind, "mountain") {
            return tile::init(hex, tile::MOUNTAIN, number);
        }
        if std::str::eq(kind, "pasture") {
            return tile::init(hex, tile::PASTURE, number);
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[tile]]();
    }

    func to_bubby(self: *tile) bubby::value {
        var out = bubby::value::init_map();
        out.map().*.insert(bubby::value::init_str("hex"), self.*.hex.to_bubby());
        switch self.*.kind {
        tile::DESERT {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("desert"));
        }
        tile::OCEAN {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("ocean"));
        }
        tile::FOREST {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("forest"));
        }
        tile::FIELD {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("field"));
        }
        tile::HILL {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("hill"));
        }
        tile::MOUNTAIN {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("mountain"));
        }
        tile::PASTURE {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("pasture"));
        }
        }
        out.map().*.insert(bubby::value::init_str("number"), int_to_bubby[[sint]](self.*.number));
        return out;
    }
}

struct edge {
    var hexes: [2]hex;

    func init(a: hex, b: hex) edge {
        assert hex::distance(a, b) == 1;

        var hexes = (:[2]hex)[a, b];
        std::sort[[hex]](hexes[0:countof(hexes)]);

        return (:edge){
            .hexes = hexes,
        };
    }

    func hash(self: *edge) usize {
        var hash = 0u;
        for i in countof(self.*.hexes) {
            hash = hash +% self.*.hexes[i].hash();
        }
        return hash;
    }

    func compare(lhs: *edge, rhs: *edge) ssize {
        var cmp = hex::compare(&lhs.*.hexes[0], &rhs.*.hexes[0]);
        if cmp != 0 {
            return cmp;
        }

        var cmp = hex::compare(&lhs.*.hexes[1], &rhs.*.hexes[1]);
        if cmp != 0 {
            return cmp;
        }

        return 0;
    }

    func format(self: *edge, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            for i in countof(self.*.hexes) {
                if i != 0 {
                    std::print(writer, ", ");
                }
                std::print_format(
                    writer,
                    "{}",
                    (:[]std::formatter)[
                        std::formatter::init[[hex]](&self.*.hexes[i])]);
            }

            return std::result[[void, std::error]]::init_value(void::VALUE);
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }

    func init_from_bubby(value: *bubby::value) edge {
        return edge::init(
            hex::init_from_bubby(&value.*.vec().*.data()[0]),
            hex::init_from_bubby(&value.*.vec().*.data()[1]));
    }

    func to_bubby(self: *edge) bubby::value {
        var out = bubby::value::init_vec();
        for i in countof(self.*.hexes) {
            out.vec().*.push(self.*.hexes[i].to_bubby());
        }
        return out;
    }
}

struct node {
    var hexes: [3]hex;

    func init(a: hex, b: hex, c: hex) node {
        assert hex::distance(a, b) == 1;
        assert hex::distance(b, c) == 1;
        assert hex::distance(c, a) == 1;

        var hexes = (:[3]hex)[a, b, c];
        std::sort[[hex]](hexes[0:countof(hexes)]);

        return (:node){
            .hexes = hexes,
        };
    }

    func hash(self: *node) usize {
        var hash = 0u;
        for i in countof(self.*.hexes) {
            hash = hash +% self.*.hexes[i].hash();
        }
        return hash;
    }

    func compare(lhs: *node, rhs: *node) ssize {
        var cmp = hex::compare(&lhs.*.hexes[0], &rhs.*.hexes[0]);
        if cmp != 0 {
            return cmp;
        }

        var cmp = hex::compare(&lhs.*.hexes[1], &rhs.*.hexes[1]);
        if cmp != 0 {
            return cmp;
        }

        var cmp = hex::compare(&lhs.*.hexes[2], &rhs.*.hexes[2]);
        if cmp != 0 {
            return cmp;
        }

        return 0;
    }

    func format(self: *node, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            for i in countof(self.*.hexes) {
                if i != 0 {
                    std::print(writer, ", ");
                }
                std::print_format(
                    writer,
                    "{}",
                    (:[]std::formatter)[
                        std::formatter::init[[hex]](&self.*.hexes[i])]);
            }

            return std::result[[void, std::error]]::init_value(void::VALUE);
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }

    func init_from_bubby(value: *bubby::value) node {
        return node::init(
            hex::init_from_bubby(&value.*.vec().*.data()[0]),
            hex::init_from_bubby(&value.*.vec().*.data()[1]),
            hex::init_from_bubby(&value.*.vec().*.data()[2]));
    }

    func to_bubby(self: *node) bubby::value {
        var out = bubby::value::init_vec();
        for i in countof(self.*.hexes) {
            out.vec().*.push(self.*.hexes[i].to_bubby());
        }
        return out;
    }
}

struct port {
    var hex: hex;
    var nodes: [2]node;
    var kind: enum {
        ANY;
        BRICK;
        ORE;
        SHEEP;
        WHEAT;
        WOOD;
    };

    let SELF: port = uninit;

    func init(hex: hex, a: node, b: node, kind: typeof(SELF.kind)) port {
        assert std::eq[[::hex]](&hex, &a.hexes[0])
            or std::eq[[::hex]](&hex, &a.hexes[1])
            or std::eq[[::hex]](&hex, &a.hexes[2]);
        assert std::eq[[::hex]](&hex, &b.hexes[0])
            or std::eq[[::hex]](&hex, &b.hexes[1])
            or std::eq[[::hex]](&hex, &b.hexes[2]);
        assert std::ne[[node]](&a, &b);

        var nodes = (:[2]node)[a, b];
        std::sort[[node]](nodes[0:countof(nodes)]);

        return (:port){
            .hex = hex,
            .nodes = nodes,
            .kind = kind,
        };
    }

    func hash(self: *port) usize {
        return self.*.hex.hash();
    }

    func compare(lhs: *port, rhs: *port) ssize {
        return std::compare[[hex]](&lhs.*.hex, &rhs.*.hex);
    }

    func init_from_bubby(value: *bubby::value) port {
        var hex = hex::init_from_bubby(value.*.map_xlookup_str("hex"));
        var node_a = node::init_from_bubby(&value.*.map_xlookup_str("nodes").*.vec().*.data()[0]);
        var node_b = node::init_from_bubby(&value.*.map_xlookup_str("nodes").*.vec().*.data()[1]);
        var kind = value.*.map_xlookup_str("kind").*.str();
        if std::str::eq(kind, "any") {
            return port::init(hex, node_a, node_b, port::ANY);
        }
        if std::str::eq(kind, "brick") {
            return port::init(hex, node_a, node_b, port::BRICK);
        }
        if std::str::eq(kind, "ore") {
            return port::init(hex, node_a, node_b, port::ORE);
        }
        if std::str::eq(kind, "sheep") {
            return port::init(hex, node_a, node_b, port::SHEEP);
        }
        if std::str::eq(kind, "wheat") {
            return port::init(hex, node_a, node_b, port::WHEAT);
        }
        if std::str::eq(kind, "wood") {
            return port::init(hex, node_a, node_b, port::WOOD);
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[port]]();
    }

    func to_bubby(self: *port) bubby::value {
        var out = bubby::value::init_map();
        out.map().*.insert(bubby::value::init_str("hex"), self.*.hex.to_bubby());
        out.map().*.insert(bubby::value::init_str("nodes"), bubby::value::init_vec());
        out.map_xlookup_str("nodes").*.vec().*.push(self.*.nodes[0].to_bubby());
        out.map_xlookup_str("nodes").*.vec().*.push(self.*.nodes[1].to_bubby());
        switch self.*.kind {
        port::ANY {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("any"));
        }
        port::BRICK {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("brick"));
        }
        port::ORE {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("ore"));
        }
        port::SHEEP {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("sheep"));
        }
        port::WHEAT {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("wheat"));
        }
        port::WOOD {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("wood"));
        }
        }
        return out;
    }
}

struct road {
    var player: player;
    var edge: edge;

    func init(player: player, edge: edge) road {
        return (:road){
            .edge = edge,
            .player = player,
        };
    }

    func hash(self: *road) usize {
        return self.*.edge.hash();
    }

    func compare(lhs: *road, rhs: *road) ssize {
        return std::compare[[edge]](&lhs.*.edge, &rhs.*.edge);
    }

    func init_from_bubby(value: *bubby::value) road {
        return road::init(
            (:player)xstr_to_int[[ssize]](value.*.map_xlookup_str("player").*.str()),
            edge::init_from_bubby(value.*.map_xlookup_str("edge")));
    }

    func to_bubby(self: *road) bubby::value {
        var out = bubby::value::init_map();
        out.map_insert_str("player", int_to_bubby[[ssize]]((:ssize)self.*.player));
        out.map_insert_str("edge", self.*.edge.to_bubby());
        return out;
    }
}

struct town {
    var player: player;
    var node: node;
    var kind: enum {
        SETTLEMENT;
        CITY;
    };

    let SELF: town = uninit;

    func init(player: player, node: node, kind: typeof(SELF.kind)) town {
        return (:town){
            .player = player,
            .node = node,
            .kind = kind,
        };
    }

    func hash(self: *town) usize {
        return self.*.node.hash();
    }

    func compare(lhs: *town, rhs: *town) ssize {
        return std::compare[[node]](&lhs.*.node, &rhs.*.node);
    }

    func init_from_bubby(value: *bubby::value) town {
        var player = (:player)xstr_to_int[[ssize]](value.*.map_xlookup_str("player").*.str());
        var node = node::init_from_bubby(value.*.map_xlookup_str("node"));
        var kind = value.*.map_xlookup_str("kind").*.str();
        if std::str::eq(kind, "settlement") {
            return town::init(player, node, town::SETTLEMENT);
        }
        if std::str::eq(kind, "city") {
            return town::init(player, node, town::CITY);
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[town]]();
    }

    func to_bubby(self: *town) bubby::value {
        var out = bubby::value::init_map();
        out.map_insert_str("player", int_to_bubby[[ssize]]((:ssize)self.*.player));
        out.map_insert_str("node", self.*.node.to_bubby());
        switch self.*.kind {
        town::SETTLEMENT {
            out.map_insert_str("kind", bubby::value::init_str("settlement"));
        }
        town::CITY {
            out.map_insert_str("kind", bubby::value::init_str("city"));
        }
        }
        return out;
    }
}

struct board {
    var tiles: std::hash_map[[hex, tile]];
    var edges: std::hash_set[[edge]];
    var nodes: std::hash_set[[node]];
    var ports: std::hash_set[[port]];
    var roads: std::hash_map[[edge, road]];
    var towns: std::hash_map[[node, town]];
    var robber: hex;
    var d6_a: sint;
    var d6_b: sint;

    func init() board {
        var tiles = std::hash_map[[hex, tile]]::init();
        var edges = std::hash_set[[edge]]::init();
        var nodes = std::hash_set[[node]]::init();
        var ports = std::hash_set[[port]]::init();
        var roads = std::hash_map[[edge, road]]::init();
        var towns = std::hash_map[[node, town]]::init();
        var robber = hex::init(+0, +0, +0);
        var d6 = (:sint)1;

        return (:board){
            .tiles = tiles,
            .edges = edges,
            .nodes = nodes,
            .ports = ports,
            .roads = roads,
            .towns = towns,
            .robber = robber,
            .d6_a = d6,
            .d6_b = d6,
        };
    }

    func init_assign(from: *board) board {
        var self = board::init();
        board::assign(&self, from);
        return self;
    }

    func init_starter_map_for_beginners() board {
        var tiles = init_starter_map_for_beginners_tiles();
        var edges = init_edges(&tiles);
        var nodes = init_nodes(&tiles);
        var ports = init_starter_map_for_beginners_ports();
        var roads = std::hash_map[[edge, road]]::init();
        var towns = std::hash_map[[node, town]]::init();
        var robber = hex::init(+0, +0, +0);
        var d6 = (:sint)1;

        return (:board){
            .tiles = tiles,
            .edges = edges,
            .nodes = nodes,
            .ports = ports,
            .roads = roads,
            .towns = towns,
            .robber = robber,
            .d6_a = d6,
            .d6_b = d6,
        };
    }

    func fini(self: *board) void {
        self.*.tiles.fini();
        self.*.edges.fini();
        self.*.nodes.fini();
        self.*.ports.fini();
        self.*.roads.fini();
        self.*.towns.fini();
    }

    func assign(self: *board, from: *board) void {
        std::hash_map[[hex, tile]]::assign(&self.*.tiles, &from.*.tiles);
        std::hash_set[[edge]]::assign(&self.*.edges, &from.*.edges);
        std::hash_set[[node]]::assign(&self.*.nodes, &from.*.nodes);
        std::hash_set[[port]]::assign(&self.*.ports, &from.*.ports);
        std::hash_map[[edge, road]]::assign(&self.*.roads, &from.*.roads);
        std::hash_map[[node, town]]::assign(&self.*.towns, &from.*.towns);
        self.*.robber = from.*.robber;
        self.*.d6_a = from.*.d6_a;
        self.*.d6_b = from.*.d6_b;
    }

    func init_from_bubby(value: *bubby::value) board {
        var self = board::init();
        var tiles = value.*.map_xlookup_str("tiles");
        var iter = std::hash_set_iterator[[bubby::value]]::init(tiles.*.set());
        for iter.advance() {
            var tile = tile::init_from_bubby(iter.current());
            self.tiles.insert(tile.hex, tile);
        }
        self.edges.fini();
        self.edges = init_edges(&self.tiles);
        self.nodes.fini();
        self.nodes = init_nodes(&self.tiles);
        var ports = value.*.map_xlookup_str("ports");
        var iter = std::hash_set_iterator[[bubby::value]]::init(ports.*.set());
        for iter.advance() {
            var port = port::init_from_bubby(iter.current());
            self.ports.insert(port);
        }
        var roads = value.*.map_xlookup_str("roads");
        var iter = std::hash_set_iterator[[bubby::value]]::init(roads.*.set());
        for iter.advance() {
            var road = road::init_from_bubby(iter.current());
            self.roads.insert(road.edge, road);
        }
        var towns = value.*.map_xlookup_str("towns");
        var iter = std::hash_set_iterator[[bubby::value]]::init(towns.*.set());
        for iter.advance() {
            var town = town::init_from_bubby(iter.current());
            self.towns.insert(town.node, town);
        }
        self.robber = hex::init_from_bubby(value.*.map_xlookup_str("robber"));
        self.d6_a = xstr_to_int[[sint]](value.*.map_xlookup_str("d6-a").*.str());
        self.d6_b = xstr_to_int[[sint]](value.*.map_xlookup_str("d6-b").*.str());
        return self;
    }

    func to_bubby(self: *board) bubby::value {
        var out = bubby::value::init_map();
        out.map_insert_str("tiles", bubby::value::init_set());
        var iter = std::hash_map_iterator[[hex, tile]]::init(&self.*.tiles);
        for iter.advance() {
            var tile = iter.current().*.value.*.to_bubby();
            out.map_xlookup_str("tiles").*.set_insert(tile);
        }
        out.map_insert_str("ports", bubby::value::init_set());
        var iter = std::hash_set_iterator[[port]]::init(&self.*.ports);
        for iter.advance() {
            var port = iter.current().*.to_bubby();
            out.map_xlookup_str("ports").*.set_insert(port);
        }
        out.map_insert_str("roads", bubby::value::init_set());
        var iter = std::hash_map_iterator[[edge, road]]::init(&self.*.roads);
        for iter.advance() {
            var road = iter.current().*.value.*.to_bubby();
            out.map_xlookup_str("roads").*.set_insert(road);
        }
        out.map_insert_str("towns", bubby::value::init_set());
        var iter = std::hash_map_iterator[[node, town]]::init(&self.*.towns);
        for iter.advance() {
            var town = iter.current().*.value.*.to_bubby();
            out.map_xlookup_str("towns").*.set_insert(town);
        }
        out.map_insert_str("robber", self.*.robber.to_bubby());
        out.map_insert_str("d6-a", int_to_bubby[[sint]](self.*.d6_a));
        out.map_insert_str("d6-b", int_to_bubby[[sint]](self.*.d6_b));
        return out;
    }
}

func insert_tile(tiles: *std::hash_map[[hex, tile]], tile: tile) void {
    tiles.*.insert(tile.hex, tile);
}

func insert_road(roads: *std::hash_map[[edge, road]], road: road) void {
    roads.*.insert(road.edge, road);
}

func insert_town(towns: *std::hash_map[[node, town]], town: town) void {
    towns.*.insert(town.node, town);
}

func init_starter_map_for_beginners_tiles() std::hash_map[[hex, tile]] {
    var tiles = std::hash_map[[hex, tile]]::init();

    # top row
    insert_tile(&tiles, tile::init(hex::init(+0, -2, +2), tile::MOUNTAIN, 10));
    insert_tile(&tiles, tile::init(hex::init(+1, -2, +1), tile::PASTURE, 2));
    insert_tile(&tiles, tile::init(hex::init(+2, -2, +0), tile::FOREST, 9));
    # top-middle row
    insert_tile(&tiles, tile::init(hex::init(-1, -1, +2), tile::FIELD, 12));
    insert_tile(&tiles, tile::init(hex::init(+0, -1, +1), tile::HILL, 6));
    insert_tile(&tiles, tile::init(hex::init(+1, -1, +0), tile::PASTURE, 4));
    insert_tile(&tiles, tile::init(hex::init(+2, -1, -1), tile::HILL, 10));
    # middle row
    insert_tile(&tiles, tile::init(hex::init(-2, +0, +2), tile::FIELD, 9));
    insert_tile(&tiles, tile::init(hex::init(-1, +0, +1), tile::FOREST, 11));
    insert_tile(&tiles, tile::init(hex::init(+0, +0, +0), tile::DESERT, -1));
    insert_tile(&tiles, tile::init(hex::init(+1, +0, -1), tile::FOREST, 3));
    insert_tile(&tiles, tile::init(hex::init(+2, +0, -2), tile::MOUNTAIN, 8));
    # bottom-middle row
    insert_tile(&tiles, tile::init(hex::init(-2, +1, +1), tile::FOREST, 8));
    insert_tile(&tiles, tile::init(hex::init(-1, +1, +0), tile::MOUNTAIN, 3));
    insert_tile(&tiles, tile::init(hex::init(+0, +1, -1), tile::FIELD, 4));
    insert_tile(&tiles, tile::init(hex::init(+1, +1, -2), tile::PASTURE, 5));
    # bottom row
    insert_tile(&tiles, tile::init(hex::init(-2, +2, +0), tile::HILL, 5));
    insert_tile(&tiles, tile::init(hex::init(-1, +2, -1), tile::FIELD, 6));
    insert_tile(&tiles, tile::init(hex::init(+0, +2, -2), tile::PASTURE, 11));
    # adjacent ocean
    insert_tile(&tiles, tile::init(hex::init(+0, -3, +3), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+1, -3, +2), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+2, -3, +1), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+3, -3, +0), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-1, -2, +3), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+3, -2, -1), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-2, -1, +3), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+3, -1, -2), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-3, +0, +3), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+3, +0, -3), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-3, +1, +2), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+2, +1, -3), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-3, +2, +1), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+1, +2, -3), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-3, +3, +0), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-2, +3, -1), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(-1, +3, -2), tile::OCEAN, -1));
    insert_tile(&tiles, tile::init(hex::init(+0, +3, -3), tile::OCEAN, -1));

    return tiles;
}

func init_edges(tiles: *std::hash_map[[hex, tile]]) std::hash_set[[edge]] {
    var edges = std::hash_set[[edge]]::init();

    var iter_i = std::hash_map_iterator[[hex, tile]]::init(tiles);
    for iter_i.advance() {
        var iter_j = std::hash_map_iterator[[hex, tile]]::init(tiles);
        for iter_j.advance() {
            if hex::distance(*iter_i.current().*.key, *iter_j.current().*.key) != 1 {
                continue;
            }
            var edge = edge::init(
                *iter_i.current().*.key,
                *iter_j.current().*.key);
            edges.insert(edge);
        }
    }

    return edges;
}

func init_nodes(tiles: *std::hash_map[[hex, tile]]) std::hash_set[[node]] {
    var nodes = std::hash_set[[node]]::init();

    var iter_i = std::hash_map_iterator[[hex, tile]]::init(tiles);
    for iter_i.advance() {
        var iter_j = std::hash_map_iterator[[hex, tile]]::init(tiles);
        for iter_j.advance() {
            var iter_k = std::hash_map_iterator[[hex, tile]]::init(tiles);
            for iter_k.advance() {
                if hex::distance(*iter_i.current().*.key, *iter_j.current().*.key) != 1 {
                    continue;
                }
                if hex::distance(*iter_j.current().*.key, *iter_k.current().*.key) != 1 {
                    continue;
                }
                if hex::distance(*iter_k.current().*.key, *iter_i.current().*.key) != 1 {
                    continue;
                }
                var node = node::init(
                    *iter_i.current().*.key,
                    *iter_j.current().*.key,
                    *iter_k.current().*.key);
                nodes.insert(node);
            }
        }
    }

    return nodes;
}

func init_starter_map_for_beginners_ports() std::hash_set[[port]] {
    var ports = std::hash_set[[port]]::init();

    ports.insert(port::init(
        hex::init(+3, +0, -3),
        node::init(
            hex::init(+2, +0, -2),
            hex::init(+2, +1, -3),
            hex::init(+3, +0, -3)),
        node::init(
            hex::init(+2, +0, -2),
            hex::init(+3, -1, -2),
            hex::init(+3, +0, -3)),
        port::ANY));

    ports.insert(port::init(
        hex::init(+3, -2, -1),
        node::init(
            hex::init(+2, -2, +0),
            hex::init(+2, -1, -1),
            hex::init(+3, -2, -1)),
        node::init(
            hex::init(+2, -1, -1),
            hex::init(+3, -2, -1),
            hex::init(+3, -1, -2)),
        port::ORE));

    ports.insert(port::init(
        hex::init(+2, -3, +1),
        node::init(
            hex::init(+1, -3, +2),
            hex::init(+1, -2, +1),
            hex::init(+2, -3, +1)),
        node::init(
            hex::init(+1, -2, +1),
            hex::init(+2, -3, +1),
            hex::init(+2, -2, +0)),
        port::WHEAT));

    ports.insert(port::init(
        hex::init(+0, -3, +3),
        node::init(
            hex::init(-1, -2, +3),
            hex::init(+0, -3, +3),
            hex::init(+0, -2, +2)),
        node::init(
            hex::init(+0, -3, +3),
            hex::init(+0, -2, +2),
            hex::init(+1, -3, +2)),
        port::ANY));

    ports.insert(port::init(
        hex::init(-2, -1, +3),
        node::init(
            hex::init(-2, -1, +3),
            hex::init(-2, +0, +2),
            hex::init(-1, -1, +2)),
        node::init(
            hex::init(-2, -1, +3),
            hex::init(-1, -2, +3),
            hex::init(-1, -1, +2)),
        port::WOOD));

    ports.insert(port::init(
        hex::init(-3, +1, +2),
        node::init(
            hex::init(-3, +1, +2),
            hex::init(-3, +2, +1),
            hex::init(-2, +1, +1)),
        node::init(
            hex::init(-3, +1, +2),
            hex::init(-2, +0, +2),
            hex::init(-2, +1, +1)),
        port::BRICK));

    ports.insert(port::init(
        hex::init(-3, +3, +0),
        node::init(
            hex::init(-3, +2, +1),
            hex::init(-3, +3, +0),
            hex::init(-2, +2, +0)),
        node::init(
            hex::init(-3, +3, +0),
            hex::init(-2, +2, +0),
            hex::init(-2, +3, -1)),
        port::ANY));

    ports.insert(port::init(
        hex::init(-1, +3, -2),
        node::init(
            hex::init(-2, +3, -1),
            hex::init(-1, +2, -1),
            hex::init(-1, +3, -2)),
        node::init(
            hex::init(-1, +2, -1),
            hex::init(-1, +3, -2),
            hex::init(+0, +2, -2)),
        port::ANY));

    ports.insert(port::init(
        hex::init(+1, +2, -3),
        node::init(
            hex::init(+0, +2, -2),
            hex::init(+1, +1, -2),
            hex::init(+1, +2, -3)),
        node::init(
            hex::init(+1, +1, -2),
            hex::init(+1, +2, -3),
            hex::init(+2, +1, -3)),
        port::SHEEP));

    return ports;
}

func adjacent_edges_to_edge(target: edge, edges: *std::hash_set[[edge]], nodes: *std::hash_set[[node]]) std::hash_set[[edge]] {
    var out = std::hash_set[[edge]]::init();

    var adjacent_nodes = adjacent_nodes_to_edge(target, nodes);
    defer adjacent_nodes.fini();

    var iter = std::hash_set_iterator[[node]]::init(&adjacent_nodes);
    for iter.advance() {
        var adjacent_edges = adjacent_edges_to_node(*iter.current(), edges);
        defer adjacent_edges.fini();

        var iter = std::hash_set_iterator[[edge]]::init(&adjacent_edges);
        for iter.advance() {
            if not std::eq[[edge]](&target, iter.current()) {
                out.insert(*iter.current());
            }
        }
    }

    return out;
}

func adjacent_nodes_to_edge(target: edge, nodes: *std::hash_set[[node]]) std::hash_set[[node]] {
    var out = std::hash_set[[node]]::init();

    var a = std::hash_set[[hex]]::init();
    defer a.fini();
    a.insert(target.hexes[0]);
    a.insert(target.hexes[1]);

    var iter = std::hash_set_iterator[[node]]::init(nodes);
    for iter.advance() {
        var b = std::hash_set[[hex]]::init();
        defer b.fini();
        b.insert(iter.current().*.hexes[0]);
        b.insert(iter.current().*.hexes[1]);
        b.insert(iter.current().*.hexes[2]);

        var intersection = std::hash_set[[hex]]::init_intersection(&a, &b);
        defer intersection.fini();
        if intersection.count() == 2 {
            out.insert(*iter.current());
        }
    }

    return out;
}

func adjacent_nodes_to_hex(target: hex, nodes: *std::hash_set[[node]]) std::hash_set[[node]] {
    var out = std::hash_set[[node]]::init();

    var iter = std::hash_set_iterator[[node]]::init(nodes);
    for iter.advance() {
        if std::eq[[hex]](&iter.current().*.hexes[0], &target)
        or std::eq[[hex]](&iter.current().*.hexes[1], &target)
        or std::eq[[hex]](&iter.current().*.hexes[2], &target) {
            out.insert(*iter.current());
        }
    }

    return out;
}

func adjacent_edges_to_node(target: node, edges: *std::hash_set[[edge]]) std::hash_set[[edge]] {
    var out = std::hash_set[[edge]]::init();

    var a = std::hash_set[[hex]]::init();
    defer a.fini();
    a.insert(target.hexes[0]);
    a.insert(target.hexes[1]);
    a.insert(target.hexes[2]);

    var iter = std::hash_set_iterator[[edge]]::init(edges);
    for iter.advance() {
        var b = std::hash_set[[hex]]::init();
        defer b.fini();
        b.insert(iter.current().*.hexes[0]);
        b.insert(iter.current().*.hexes[1]);

        var intersection = std::hash_set[[hex]]::init_intersection(&a, &b);
        defer intersection.fini();
        if intersection.count() == 2 {
            out.insert(*iter.current());
        }
    }

    return out;
}

func adjacent_nodes_to_node(target: node, nodes: *std::hash_set[[node]]) std::hash_set[[node]] {
    var out = std::hash_set[[node]]::init();

    var a = std::hash_set[[hex]]::init();
    defer a.fini();
    a.insert(target.hexes[0]);
    a.insert(target.hexes[1]);
    a.insert(target.hexes[2]);

    var iter = std::hash_set_iterator[[node]]::init(nodes);
    for iter.advance() {
        var b = std::hash_set[[hex]]::init();
        defer b.fini();
        b.insert(iter.current().*.hexes[0]);
        b.insert(iter.current().*.hexes[1]);
        b.insert(iter.current().*.hexes[2]);

        var intersection = std::hash_set[[hex]]::init_intersection(&a, &b);
        defer intersection.fini();
        if intersection.count() == 2 {
            out.insert(*iter.current());
        }
    }

    return out;
}

func n_to_1(board: *board, player: player, resource: resource) sint {
    var n: sint = 4;

    var iter = std::hash_set_iterator[[port]]::init(&board.*.ports);
    for iter.advance() {
        var port = *iter.current();
        for i in countof(port.nodes) {
            var town = board.*.towns.lookup(port.nodes[i]);
            if town.is_empty() {
                continue;
            }

            var town = *town.value();
            if town.player != player {
                continue;
            }

            if port.kind == ::port::ANY {
                n = typeof(n)::min(n, 3);
            }
            elif port.kind == ::port::BRICK and resource == ::resource::BRICK {
                n = typeof(n)::min(n, 2);
            }
            elif port.kind == ::port::ORE and resource == ::resource::ORE {
                n = typeof(n)::min(n, 2);
            }
            elif port.kind == ::port::SHEEP and resource == ::resource::SHEEP {
                n = typeof(n)::min(n, 2);
            }
            elif port.kind == ::port::WHEAT and resource == ::resource::WHEAT {
                n = typeof(n)::min(n, 2);
            }
            elif port.kind == ::port::WOOD and resource == ::resource::WOOD {
                n = typeof(n)::min(n, 2);
            }
        }
    }

    return n;
}

struct resources {
    var brick: sint;
    var ore: sint;
    var sheep: sint;
    var wheat: sint;
    var wood: sint;

    func init_from_bubby(value: *bubby::value) resources {
        var self: resources = uninit;
        self.brick = xstr_to_int[[sint]](value.*.map_xlookup_str("brick").*.str());
        self.ore = xstr_to_int[[sint]](value.*.map_xlookup_str("ore").*.str());
        self.sheep = xstr_to_int[[sint]](value.*.map_xlookup_str("sheep").*.str());
        self.wheat = xstr_to_int[[sint]](value.*.map_xlookup_str("wheat").*.str());
        self.wood = xstr_to_int[[sint]](value.*.map_xlookup_str("wood").*.str());
        return self;
    }

    func to_bubby(self: *resources) bubby::value {
        var out = bubby::value::init_map();
        out.map_insert_str("brick", int_to_bubby[[sint]](self.*.brick));
        out.map_insert_str("ore", int_to_bubby[[sint]](self.*.ore));
        out.map_insert_str("sheep", int_to_bubby[[sint]](self.*.sheep));
        out.map_insert_str("wheat", int_to_bubby[[sint]](self.*.wheat));
        out.map_insert_str("wood", int_to_bubby[[sint]](self.*.wood));
        return out;
    }

    func eq(lhs: *resources, rhs: *resources) bool {
        return lhs.*.brick == rhs.*.brick
            and lhs.*.ore == rhs.*.ore
            and lhs.*.sheep == rhs.*.sheep
            and lhs.*.wheat == rhs.*.wheat
            and lhs.*.wood == rhs.*.wood;
    }

    func count(self: *resources) sint {
        return self.*.brick + self.*.ore + self.*.sheep + self.*.wheat + self.*.wood;
    }

    func add(self: *resources, resource: resource, count: sint) void {
        self.*.resource(resource).* += count;
    }

    func sub(self: *resources, resource: resource, count: sint) void {
        self.*.resource(resource).* -= count;
    }

    func resource(self: *resources, resource: resource) *sint {
        var out: *sint = uninit;
        switch resource {
        ::resource::BRICK {
            out = &self.*.brick;
        }
        ::resource::ORE {
            out = &self.*.ore;
        }
        ::resource::SHEEP {
            out = &self.*.sheep;
        }
        ::resource::WHEAT {
            out = &self.*.wheat;
        }
        ::resource::WOOD {
            out = &self.*.wood;
        }
        }
        return out;
    }
}

struct trade {
    var give: resources; # From the trade-proposer's perspective.
    var recv: resources; # From the trade-proposer's perspective.

    func init_from_bubby(value: *bubby::value) trade {
        var give = resources::init_from_bubby(value.*.map_xlookup_str("give"));
        var recv = resources::init_from_bubby(value.*.map_xlookup_str("recv"));
        return (:trade){
            .give = give,
            .recv = recv,
        };
    }

    func to_bubby(self: *trade) bubby::value {
        var out = bubby::value::init_map();
        out.map_insert_str("give", self.*.give.to_bubby());
        out.map_insert_str("recv", self.*.recv.to_bubby());
        return out;
    }

    func eq(lhs: *trade, rhs: *trade) bool {
        return std::eq[[resources]](&lhs.*.give, &rhs.*.give) and std::eq[[resources]](&lhs.*.recv, &rhs.*.recv);
    }
}

struct hidden_player_info {
    var brick: sint;
    var ore: sint;
    var sheep: sint;
    var wheat: sint;
    var wood: sint;
    var dev_card_array: purchased_dev_card_array;
    var dev_card_count: usize;
    var victory_points: sint;

    func init_from_bubby(value: *bubby::value) hidden_player_info {
        var self: hidden_player_info = uninit;
        self.brick = xstr_to_int[[sint]](value.*.map_xlookup_str("brick").*.str());
        self.ore = xstr_to_int[[sint]](value.*.map_xlookup_str("ore").*.str());
        self.sheep = xstr_to_int[[sint]](value.*.map_xlookup_str("sheep").*.str());
        self.wheat = xstr_to_int[[sint]](value.*.map_xlookup_str("wheat").*.str());
        self.wood = xstr_to_int[[sint]](value.*.map_xlookup_str("wood").*.str());
        var dev_cards = value.*.map_xlookup_str("dev-cards").*.vec();
        assert dev_cards.*.count() <= countof(self.dev_card_array);
        for i in dev_cards.*.count() {
            self.dev_card_array[i] = purchased_dev_card::init_from_bubby(&dev_cards.*.data()[i]);
        }
        self.dev_card_count = dev_cards.*.count();
        self.victory_points = xstr_to_int[[sint]](value.*.map_xlookup_str("victory-points").*.str());
        return self;
    }

    func to_bubby(self: *hidden_player_info) bubby::value {
        var out = bubby::value::init_map();
        out.map_insert_str("brick", int_to_bubby[[sint]](self.*.brick));
        out.map_insert_str("ore", int_to_bubby[[sint]](self.*.ore));
        out.map_insert_str("sheep", int_to_bubby[[sint]](self.*.sheep));
        out.map_insert_str("wheat", int_to_bubby[[sint]](self.*.wheat));
        out.map_insert_str("wood", int_to_bubby[[sint]](self.*.wood));
        var dev_cards = bubby::value::init_vec();
        for i in self.*.dev_card_count {
            dev_cards.vec().*.push(self.*.dev_card_array[i].to_bubby());
        }
        out.map_insert_str("dev-cards", dev_cards);
        out.map_insert_str("victory-points", int_to_bubby[[sint]](self.*.victory_points));
        return out;
    }

    func resource_ref(self: *hidden_player_info, resource: resource) *sint {
        switch resource {
        ::resource::BRICK {
            return &self.*.brick;
        }
        ::resource::ORE {
            return &self.*.ore;
        }
        ::resource::SHEEP {
            return &self.*.sheep;
        }
        ::resource::WHEAT {
            return &self.*.wheat;
        }
        ::resource::WOOD {
            return &self.*.wood;
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[*sint]]();
    }

    func resource_count(self: *hidden_player_info) sint {
        return self.*.brick + self.*.ore + self.*.sheep + self.*.wheat + self.*.wood;
    }
}

struct public_player_info {
    var live: bool;
    var victory_points: sint;
    var resources: sint;
    var dev_cards: sint;
    var discarded: bool;
    var trade_submitted: bool;

    func init_from_bubby(value: *bubby::value) public_player_info {
        var self: public_player_info = uninit;
        self.live = xstr_to_bool(value.*.map_xlookup_str("live").*.str());
        self.victory_points = xstr_to_int[[sint]](value.*.map_xlookup_str("victory-points").*.str());
        self.resources = xstr_to_int[[sint]](value.*.map_xlookup_str("resources").*.str());
        self.dev_cards = xstr_to_int[[sint]](value.*.map_xlookup_str("dev-cards").*.str());
        self.discarded = xstr_to_bool(value.*.map_xlookup_str("discarded").*.str());
        self.trade_submitted = xstr_to_bool(value.*.map_xlookup_str("trade-submitted").*.str());
        return self;
    }

    func to_bubby(self: *public_player_info) bubby::value {
        var out = bubby::value::init_map();
        out.map_insert_str("live", bool_to_bubby(self.*.live));
        out.map_insert_str("victory-points", int_to_bubby[[sint]](self.*.victory_points));
        out.map_insert_str("resources", int_to_bubby[[sint]](self.*.resources));
        out.map_insert_str("dev-cards", int_to_bubby[[sint]](self.*.dev_cards));
        out.map_insert_str("discarded", bool_to_bubby(self.*.discarded));
        out.map_insert_str("trade-submitted", bool_to_bubby(self.*.trade_submitted));
        return out;
    }
}

enum phase {
    RESOURCE_PRODUCTION;
    DISCARD;
    ROBBER;
    STEAL;
    ROAD_BUILDING_1;
    ROAD_BUILDING_2;
    MAIN;
    TRADE;

    func init_from_bubby(value: *bubby::value) phase {
        if std::str::eq(value.*.str(), "resource-production") {
            return phase::RESOURCE_PRODUCTION;
        }
        if std::str::eq(value.*.str(), "discard") {
            return phase::DISCARD;
        }
        if std::str::eq(value.*.str(), "robber") {
            return phase::ROBBER;
        }
        if std::str::eq(value.*.str(), "steal") {
            return phase::STEAL;
        }
        if std::str::eq(value.*.str(), "road-building-1") {
            return phase::ROAD_BUILDING_1;
        }
        if std::str::eq(value.*.str(), "road-building-2") {
            return phase::ROAD_BUILDING_2;
        }
        if std::str::eq(value.*.str(), "main") {
            return phase::MAIN;
        }
        if std::str::eq(value.*.str(), "trade") {
            return phase::TRADE;
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[phase]]();
    }

    func to_bubby(self: *phase) bubby::value {
        switch *self {
        phase::RESOURCE_PRODUCTION {
            return bubby::value::init_str("resource-production");
        }
        phase::DISCARD {
            return bubby::value::init_str("discard");
        }
        phase::ROBBER {
            return bubby::value::init_str("robber");
        }
        phase::STEAL {
            return bubby::value::init_str("steal");
        }
        phase::ROAD_BUILDING_1 {
            return bubby::value::init_str("road-building-1");
        }
        phase::ROAD_BUILDING_2 {
            return bubby::value::init_str("road-building-2");
        }
        phase::MAIN {
            return bubby::value::init_str("main");
        }
        phase::TRADE {
            return bubby::value::init_str("trade");
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[bubby::value]]();
    }
}

struct turn {
    var number: sint;
    var player: player;
    var phase: phase;

    func init(number: sint, player: player) turn {
        return (:turn){
            .number = number,
            .player = player,
            .phase = phase::RESOURCE_PRODUCTION,
        };
    }

    func init_from_bubby(value: *bubby::value) turn {
        var out: turn = uninit;
        out.number = xstr_to_int[[sint]](value.*.map_xlookup_str("number").*.str());
        out.player = bubby_to_player(value.*.map_xlookup_str("player"));
        out.phase = phase::init_from_bubby(value.*.map_xlookup_str("phase"));
        return out;
    }

    func to_bubby(self: *turn) bubby::value {
        var out = bubby::value::init_map();
        out.map_insert_str("number", int_to_bubby[[sint]](self.*.number));
        out.map().*.insert(bubby::value::init_str("player"), player_to_bubby(self.*.player));
        out.map().*.insert(bubby::value::init_str("phase"), self.*.phase.to_bubby());
        return out;
    }
}

let BUSY_CODE = (:sint)42; # nbnet busy code

struct message {
    let TYPE: u8 = 0;
    let SIZE: usize = 4096 * 4;

    var len: uint;
    var buf: [SIZE]char;

    func create() *message {
        return std::new[[message]]();
    }

    func destroy(self: *message) void {
        std::delete[[message]](self);
    }

    func serialize(self: *message, stream: *NBN_Stream) sint {
        stream.*.serialize_uint_func(stream, &self.*.len, 0, (:uint)SIZE);
        stream.*.serialize_bytes_func(stream, (:*u8)&self.*.buf[0], self.*.len);
        return 0;
    }
}

struct client_message {
    var kind: enum {
        ROLL;
        END_TURN;
        BUILD_ROAD;
        BUILD_TOWN;
        BUY_DEV_CARD;
        USE_DEV_CARD_KNGIHT;
        USE_DEV_CARD_ROAD_BUILDING;
        USE_DEV_CARD_YEAR_OF_PLENTY;
        USE_DEV_CARD_MONOPOLY;
        MOVE_ROBBER;
        SELECT_PLAYER;
        SUBMIT_PLAYER;
        SUBMIT_RESOURCES;
        TRADE_N_FOR_1;
        TRADE_PLAYERS;
        TRADE_ACCEPT;
        TRADE_REJECT;
        TRADE_WITHDRAW;
    };
    var data: union {
        var build_road: road;
        var build_town: town;
        var use_dev_card_year_of_plenty: resources;
        var use_dev_card_monopoly: resource;
        var move_robber: hex;
        var select_player: player;
        var submit_player: player;
        var submit_resources: resources;
        var trade_n_for_1: struct {
            var give: resource;
            var recv: resource;
            var n: sint;
        };
        var trade_players: trade;
        var trade_accept: trade;
        var trade_reject: trade;
    };

    let SELF: client_message = uninit;

    func init_roll() client_message {
        return (:client_message){
            .kind = client_message::ROLL,
            .data = uninit,
        };
    }

    func init_end_turn() client_message {
        return (:client_message){
            .kind = client_message::END_TURN,
            .data = uninit,
        };
    }

    func init_build_road(road: road) client_message {
        return (:client_message){
            .kind = client_message::BUILD_ROAD,
            .data = (:typeof(SELF.data)){.build_road = road},
        };
    }

    func init_build_town(town: town) client_message {
        return (:client_message){
            .kind = client_message::BUILD_TOWN,
            .data = (:typeof(SELF.data)){.build_town = town},
        };
    }

    func init_buy_dev_card() client_message {
        return (:client_message){
            .kind = client_message::BUY_DEV_CARD,
            .data = uninit,
        };
    }

    func init_use_dev_card_knight() client_message {
        return (:client_message){
            .kind = client_message::USE_DEV_CARD_KNGIHT,
            .data = uninit,
        };
    }

    func init_use_dev_card_road_building() client_message {
        return (:client_message){
            .kind = client_message::USE_DEV_CARD_ROAD_BUILDING,
            .data = uninit,
        };
    }

    func init_use_dev_card_year_of_plenty(resources: resources) client_message {
        return (:client_message){
            .kind = client_message::USE_DEV_CARD_YEAR_OF_PLENTY,
            .data = (:typeof(SELF.data)){.use_dev_card_year_of_plenty = resources},
        };
    }

    func init_use_dev_card_monopoly(resource: resource) client_message {
        return (:client_message){
            .kind = client_message::USE_DEV_CARD_MONOPOLY,
            .data = (:typeof(SELF.data)){.use_dev_card_monopoly = resource},
        };
    }

    func init_move_robber(hex: hex) client_message {
        return (:client_message){
            .kind = client_message::MOVE_ROBBER,
            .data = (:typeof(SELF.data)){.move_robber = hex},
        };
    }

    func init_select_player(selected: player) client_message {
        return (:client_message){
            .kind = client_message::SELECT_PLAYER,
            .data = (:typeof(SELF.data)){.select_player = selected},
        };
    }

    func init_submit_player(player: player) client_message {
        return (:client_message){
            .kind = client_message::SUBMIT_PLAYER,
            .data = (:typeof(SELF.data)){.submit_player = player},
        };
    }

    func init_submit_resources(resources: resources) client_message {
        return (:client_message){
            .kind = client_message::SUBMIT_RESOURCES,
            .data = (:typeof(SELF.data)){.submit_resources = resources},
        };
    }

    func init_trade_n_for_1(give: resource, recv: resource, n: sint) client_message {
        var trade_n_for_1 = (:typeof(SELF.data.trade_n_for_1)){
            .give = give,
            .recv = recv,
            .n = n,
        };
        return (:client_message){
            .kind = client_message::TRADE_N_FOR_1,
            .data = (:typeof(SELF.data)){.trade_n_for_1 = trade_n_for_1},
        };
    }

    func init_trade_players(give: resources, recv: resources) client_message {
        var trade_players = (:trade){
            .give = give,
            .recv = recv,
        };
        return (:client_message){
            .kind = client_message::TRADE_PLAYERS,
            .data = (:typeof(SELF.data)){.trade_players = trade_players},
        };
    }

    func init_trade_accept(trade: trade) client_message {
        return (:client_message){
            .kind = client_message::TRADE_ACCEPT,
            .data = (:typeof(SELF.data)){.trade_accept = trade},
        };
    }

    func init_trade_reject(trade: trade) client_message {
        return (:client_message){
            .kind = client_message::TRADE_REJECT,
            .data = (:typeof(SELF.data)){.trade_reject = trade},
        };
    }

    func init_trade_withdraw() client_message {
        return (:client_message){
            .kind = client_message::TRADE_WITHDRAW,
            .data = uninit,
        };
    }

    func init_from_bubby(value: *bubby::value) client_message {
        var kind = value.*.map_xlookup_str("kind");
        if std::str::eq(kind.*.str(), "roll") {
            return client_message::init_roll();
        }
        if std::str::eq(kind.*.str(), "end-turn") {
            return client_message::init_end_turn();
        }
        if std::str::eq(kind.*.str(), "build-road") {
            var road = road::init_from_bubby(value.*.map_xlookup_str("data"));
            return client_message::init_build_road(road);
        }
        if std::str::eq(kind.*.str(), "build-town") {
            var town = town::init_from_bubby(value.*.map_xlookup_str("data"));
            return client_message::init_build_town(town);
        }
        if std::str::eq(kind.*.str(), "buy-dev-card") {
            return client_message::init_buy_dev_card();
        }
        if std::str::eq(kind.*.str(), "use-dev-card-knight") {
            return client_message::init_use_dev_card_knight();
        }
        if std::str::eq(kind.*.str(), "use-dev-card-year-of-plenty") {
            var resources = resources::init_from_bubby(value.*.map_xlookup_str("data"));
            return client_message::init_use_dev_card_year_of_plenty(resources);
        }
        if std::str::eq(kind.*.str(), "use-dev-card-monopoly") {
            var resource = resource::init_from_bubby(value.*.map_xlookup_str("data"));
            return client_message::init_use_dev_card_monopoly(resource);
        }
        if std::str::eq(kind.*.str(), "use-dev-card-road-building") {
            return client_message::init_use_dev_card_road_building();
        }
        if std::str::eq(kind.*.str(), "move-robber") {
            var hex = hex::init_from_bubby(value.*.map_xlookup_str("data"));
            return client_message::init_move_robber(hex);
        }
        if std::str::eq(kind.*.str(), "select-player") {
            var selected = bubby_to_player(value.*.map_xlookup_str("data"));
            return client_message::init_select_player(selected);
        }
        if std::str::eq(kind.*.str(), "submit-player") {
            var player = bubby_to_player(value.*.map_xlookup_str("data"));
            return client_message::init_submit_player(player);
        }
        if std::str::eq(kind.*.str(), "submit-resources") {
            var resources = resources::init_from_bubby(value.*.map_xlookup_str("data"));
            return client_message::init_submit_resources(resources);
        }
        if std::str::eq(kind.*.str(), "trade-n-for-1") {
            var data = value.*.map_xlookup_str("data");
            var give = resource::init_from_bubby(data.*.map_xlookup_str("give"));
            var recv = resource::init_from_bubby(data.*.map_xlookup_str("recv"));
            var n = xstr_to_int[[sint]](data.*.map_xlookup_str("n").*.str());
            return client_message::init_trade_n_for_1(give, recv, n);
        }
        if std::str::eq(kind.*.str(), "trade-players") {
            var data = value.*.map_xlookup_str("data");
            var give = resources::init_from_bubby(data.*.map_xlookup_str("give"));
            var recv = resources::init_from_bubby(data.*.map_xlookup_str("recv"));
            return client_message::init_trade_players(give, recv);
        }
        if std::str::eq(kind.*.str(), "trade-accept") {
            var trade = trade::init_from_bubby(value.*.map_xlookup_str("data"));
            return client_message::init_trade_accept(trade);
        }
        if std::str::eq(kind.*.str(), "trade-reject") {
            var trade = trade::init_from_bubby(value.*.map_xlookup_str("data"));
            return client_message::init_trade_reject(trade);
        }
        if std::str::eq(kind.*.str(), "trade-withdraw") {
            return client_message::init_trade_withdraw();
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[client_message]]();
    }

    func to_bubby(self: *client_message) bubby::value {
        var out = bubby::value::init_map();
        switch self.*.kind {
        client_message::ROLL {
            out.map_insert_str("kind", bubby::value::init_str("roll"));
        }
        client_message::END_TURN {
            out.map_insert_str("kind", bubby::value::init_str("end-turn"));
        }
        client_message::BUILD_ROAD {
            out.map_insert_str("kind", bubby::value::init_str("build-road"));
            out.map_insert_str("data", self.*.data.build_road.to_bubby());
        }
        client_message::BUILD_TOWN {
            out.map_insert_str("kind", bubby::value::init_str("build-town"));
            out.map_insert_str("data", self.*.data.build_town.to_bubby());
        }
        client_message::BUY_DEV_CARD {
            out.map_insert_str("kind", bubby::value::init_str("buy-dev-card"));
        }
        client_message::USE_DEV_CARD_KNGIHT {
            out.map_insert_str("kind", bubby::value::init_str("use-dev-card-knight"));
        }
        client_message::USE_DEV_CARD_YEAR_OF_PLENTY {
            out.map_insert_str("kind", bubby::value::init_str("use-dev-card-year-of-plenty"));
            out.map_insert_str("data", self.*.data.use_dev_card_year_of_plenty.to_bubby());
        }
        client_message::USE_DEV_CARD_MONOPOLY {
            out.map_insert_str("kind", bubby::value::init_str("use-dev-card-monopoly"));
            out.map_insert_str("data", self.*.data.use_dev_card_monopoly.to_bubby());
        }
        client_message::USE_DEV_CARD_ROAD_BUILDING {
            out.map_insert_str("kind", bubby::value::init_str("use-dev-card-road-building"));
        }
        client_message::MOVE_ROBBER {
            out.map_insert_str("kind", bubby::value::init_str("move-robber"));
            out.map_insert_str("data", self.*.data.move_robber.to_bubby());
        }
        client_message::SELECT_PLAYER {
            out.map_insert_str("kind", bubby::value::init_str("select-player"));
            out.map_insert_str("data", player_to_bubby(self.*.data.select_player));
        }
        client_message::SUBMIT_PLAYER {
            out.map_insert_str("kind", bubby::value::init_str("submit-player"));
            out.map_insert_str("data", player_to_bubby(self.*.data.submit_player));
        }
        client_message::SUBMIT_RESOURCES {
            out.map_insert_str("kind", bubby::value::init_str("submit-resources"));
            out.map_insert_str("data", self.*.data.submit_resources.to_bubby());
        }
        client_message::TRADE_N_FOR_1 {
            out.map_insert_str("kind", bubby::value::init_str("trade-n-for-1"));
            var data = bubby::value::init_map();
            data.map_insert_str("give", self.*.data.trade_n_for_1.give.to_bubby());
            data.map_insert_str("recv", self.*.data.trade_n_for_1.recv.to_bubby());
            data.map_insert_str("n", int_to_bubby[[sint]](self.*.data.trade_n_for_1.n));
            out.map_insert_str("data", data);
        }
        client_message::TRADE_PLAYERS {
            out.map_insert_str("kind", bubby::value::init_str("trade-players"));
            var data = bubby::value::init_map();
            data.map_insert_str("give", self.*.data.trade_players.give.to_bubby());
            data.map_insert_str("recv", self.*.data.trade_players.recv.to_bubby());
            out.map_insert_str("data", data);
        }
        client_message::TRADE_ACCEPT {
            out.map_insert_str("kind", bubby::value::init_str("trade-accept"));
            out.map_insert_str("data", self.*.data.trade_accept.to_bubby());
        }
        client_message::TRADE_REJECT {
            out.map_insert_str("kind", bubby::value::init_str("trade-reject"));
            out.map_insert_str("data", self.*.data.trade_reject.to_bubby());
        }
        client_message::TRADE_WITHDRAW {
            out.map_insert_str("kind", bubby::value::init_str("trade-withdraw"));
        }
        }
        return out;
    }
}

struct server_message {
    var kind: enum {
        LOG;
        INFO;
        STATE;
        PLAYER;
        REJECTED;
    };
    var data: union {
        var log: std::string;
        var info: hidden_player_info;
        var state: struct {
            var board: board;
            var turn_order: [4]player;
            var turn: turn;
            var trade: trade;
            var r: public_player_info;
            var b: public_player_info;
            var w: public_player_info;
            var o: public_player_info;
        };
        var player: player;
        var accepted: std::string;
        var rejected: std::string;
    };

    let SELF: server_message = uninit;

    func init_log(text: []byte) server_message {
        return (:server_message){
            .kind = server_message::LOG,
            .data = (:typeof(SELF.data)){.log = std::string::init_from_str(text)},
        };
    }

    func init_log_format(format: []byte, args: []std::formatter) server_message {
        return (:server_message){
            .kind = server_message::LOG,
            .data = (:typeof(SELF.data)){.log = std::string::init_from_format(format, args)},
        };
    }

    func init_info(info: hidden_player_info) server_message {
        return (:server_message){
            .kind = server_message::INFO,
            .data = (:typeof(SELF.data)){.info = info},
        };
    }

    func init_state(
        board: *board,
        turn_order: [4]player,
        turn: turn,
        trade: trade,
        r: public_player_info,
        b: public_player_info,
        w: public_player_info,
        o: public_player_info) server_message {
        return (:server_message){
            .kind = server_message::STATE,
            .data = (:typeof(SELF.data)){
                .state = (:typeof(SELF.data.state)){
                    .board = ::board::init_assign(board),
                    .turn_order = turn_order,
                    .turn = turn,
                    .trade = trade,
                    .r = r,
                    .b = b,
                    .w = w,
                    .o = o,
                }
            },
        };
    }

    func init_player(player: player) server_message {
        return (:server_message){
            .kind = server_message::PLAYER,
            .data = (:typeof(SELF.data)){.player = player},
        };
    }

    func init_rejected(text: []byte) server_message {
        return (:server_message){
            .kind = server_message::REJECTED,
            .data = (:typeof(SELF.data)){.rejected = std::string::init_from_str(text)},
        };
    }

    func init_rejected_format(format: []byte, args: []std::formatter) server_message {
        return (:server_message){
            .kind = server_message::REJECTED,
            .data = (:typeof(SELF.data)){.rejected = std::string::init_from_format(format, args)},
        };
    }

    func fini(self: *server_message) void {
        switch self.*.kind {
        server_message::LOG {
            self.*.data.log.fini();
        }
        server_message::INFO {
            # nothing
        }
        server_message::STATE {
            self.*.data.state.board.fini();
        }
        server_message::PLAYER {
            # nothing
        }
        server_message::REJECTED {
            self.*.data.rejected.fini();
        }
        }
    }

    func init_from_bubby(value: *bubby::value) server_message {
        var kind = value.*.map_xlookup_str("kind").*.str();
        if std::str::eq(kind, "log") {
            return server_message::init_log(value.*.map_xlookup_str("data").*.str());
        }
        if std::str::eq(kind, "info") {
            var info = hidden_player_info::init_from_bubby(value.*.map_xlookup_str("data"));
            return server_message::init_info(info);
        }
        if std::str::eq(kind, "state") {
            var state = value.*.map_xlookup_str("data");
            var board = board::init_from_bubby(state.*.map_xlookup_str("board"));
            defer board.fini();
            var turn_order = state.*.map_xlookup_str("turn-order").*.vec();
            assert turn_order.*.count() == 4;
            var turn_order = (:[4]player)[
                bubby_to_player(&turn_order.*.data()[0]),
                bubby_to_player(&turn_order.*.data()[1]),
                bubby_to_player(&turn_order.*.data()[2]),
                bubby_to_player(&turn_order.*.data()[3]),
            ];
            var turn = turn::init_from_bubby(state.*.map_xlookup_str("turn"));
            var trade = trade::init_from_bubby(state.*.map_xlookup_str("trade"));
            var r = public_player_info::init_from_bubby(state.*.map_xlookup_str("r"));
            var b = public_player_info::init_from_bubby(state.*.map_xlookup_str("b"));
            var w = public_player_info::init_from_bubby(state.*.map_xlookup_str("w"));
            var o = public_player_info::init_from_bubby(state.*.map_xlookup_str("o"));
            return server_message::init_state(
                &board,
                turn_order,
                turn,
                trade,
                r,
                b,
                w,
                o);
        }
        if std::str::eq(kind, "player") {
            var player = bubby_to_player(value.*.map_xlookup_str("data"));
            return server_message::init_player(player);
        }
        if std::str::eq(kind, "rejected") {
            return server_message::init_rejected(value.*.map_xlookup_str("data").*.str());
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[server_message]]();
    }

    func to_bubby(self: *server_message) bubby::value {
        var out = bubby::value::init_map();
        switch self.*.kind {
        server_message::LOG {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("log"));
            out.map().*.insert(bubby::value::init_str("data"), bubby::value::init_str(self.*.data.log.data()));
        }
        server_message::INFO {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("info"));
            out.map().*.insert(bubby::value::init_str("data"), self.*.data.info.to_bubby());
        }
        server_message::STATE {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("state"));
            var state = bubby::value::init_map();
            state.map().*.insert(bubby::value::init_str("board"), self.*.data.state.board.to_bubby());
            var turn_order = bubby::value::init_vec();
            turn_order.vec().*.push(player_to_bubby(self.*.data.state.turn_order[0]));
            turn_order.vec().*.push(player_to_bubby(self.*.data.state.turn_order[1]));
            turn_order.vec().*.push(player_to_bubby(self.*.data.state.turn_order[2]));
            turn_order.vec().*.push(player_to_bubby(self.*.data.state.turn_order[3]));
            state.map().*.insert(bubby::value::init_str("turn-order"), turn_order);
            state.map().*.insert(bubby::value::init_str("turn"), self.*.data.state.turn.to_bubby());
            state.map().*.insert(bubby::value::init_str("trade"), self.*.data.state.trade.to_bubby());
            state.map().*.insert(bubby::value::init_str("r"), self.*.data.state.r.to_bubby());
            state.map().*.insert(bubby::value::init_str("b"), self.*.data.state.b.to_bubby());
            state.map().*.insert(bubby::value::init_str("w"), self.*.data.state.w.to_bubby());
            state.map().*.insert(bubby::value::init_str("o"), self.*.data.state.o.to_bubby());
            out.map().*.insert(bubby::value::init_str("data"), state);
        }
        server_message::PLAYER{
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("player"));
            out.map().*.insert(bubby::value::init_str("data"), player_to_bubby(self.*.data.player));
        }
        server_message::REJECTED {
            out.map().*.insert(bubby::value::init_str("kind"), bubby::value::init_str("rejected"));
            out.map().*.insert(bubby::value::init_str("data"), bubby::value::init_str(self.*.data.rejected.data()));
        }
        }
        return out;
    }
}

enum reliability {
    RELIABILE;
    UNRELIABILE;
}

struct message_sender_itable[[MESSAGE]] {
    var send: func(*any, *MESSAGE, reliability) void;
}

struct message_sender[[MESSAGE]] {
    var itable: *message_sender_itable[[MESSAGE]];
    var object: *any;

    func init[[T]](object: *T) message_sender[[MESSAGE]] {
        let itable = (:message_sender_itable[[MESSAGE]]){
            .send = T::send,
        };
        return (:message_sender[[MESSAGE]]){
            .itable = &itable,
            .object = object,
        };
    }

    # Send a reliable message with this sender.
    func send(self: *message_sender[[MESSAGE]], message: *MESSAGE) void {
        self.*.itable.*.send(self.*.object, message, reliability::RELIABILE);
    }

    # Send a reliable message with this sender, then consume the message with
    # MESSAGE::fini (if defined).
    func sendc(self: *message_sender[[MESSAGE]], message: MESSAGE) void {
        self.*.send(&message);
        when defined(MESSAGE::fini) {
            message.fini();
        }
    }

    # Send an unreliable message with this sender.
    func send_unreliable(self: *message_sender[[MESSAGE]], message: *MESSAGE) void {
        self.*.itable.*.send(self.*.object, message, reliability::UNRELIABILE);
    }

    # Send an unreliable message with this sender, then consume the message
    # with MESSAGE::fini (if defined).
    func sendc_unreliable(self: *message_sender[[MESSAGE]], message: MESSAGE) void {
        self.*.send_unreliable(&message, );
        when defined(MESSAGE::fini) {
            message.fini();
        }
    }
}
