import "c";
import "std";

import "raylib";
import "smolui";

import "shared.sunder";

# The radius of the outer circle touching the corners of the hexagon.
let HEX_RADIUS = 48.0f32;

func feq(a: f32, b: f32) bool {
    let THRESHOLD: f32 = 0.0001;
    return f32::abs(a - b) < THRESHOLD;
}

func lerp(a: f32, b: f32, t: f32) f32 {
    return a * (1.0 - t) + (b * t);
}

func vec2_feq(a: Vector2, b: Vector2) bool {
    return feq(a.x, b.x) and feq(a.y, b.y);
}

func vec2_lerp(a: Vector2, b: Vector2, t: f32) Vector2 {
    return (:Vector2){
        .x = lerp(a.x, b.x, t),
        .y = lerp(a.y, b.y, t),
    };
}

func vec2_distance(a: Vector2, b: Vector2) f32 {
    var x_dist = a.x - b.x;
    var y_dist = a.y - b.y;
    return f32::sqrt(x_dist * x_dist + y_dist * y_dist);
}

func tile_color(tile: tile) Color {
    switch tile.kind {
    ::tile::DESERT {
        return (:Color){.r = 0xEE, .g = 0xCC, .b = 0x88, .a = 0xFF};
    }
    ::tile::OCEAN {
        return (:Color){.r = 0x66, .g = 0xBB, .b = 0xFF, .a = 0xFF};
    }
    ::tile::FOREST {
        return (:Color){.r = 0x11, .g = 0x55, .b = 0x11, .a = 0xFF};
    }
    ::tile::FIELD {
        return (:Color){.r = 0xDD, .g = 0xAA, .b = 0x22, .a = 0xFF};
    }
    ::tile::HILL {
        return (:Color){.r = 0xCC, .g = 0x55, .b = 0x44, .a = 0xFF};
    }
    ::tile::MOUNTAIN {
        return (:Color){.r = 0x88, .g = 0x88, .b = 0x88, .a = 0xFF};
    }
    ::tile::PASTURE {
        return (:Color){.r = 0x66, .g = 0xAA, .b = 0x66, .a = 0xFF};
    }
    }

    std::unreachable(fileof(), lineof());
    return std::zeroed[[Color]]();
}

func player_color(player: player) Color {
    switch player {
    ::player::NIL {
        return BLACK;
    }
    ::player::RED {
        return RED;
    }
    ::player::BLUE {
        return BLUE;
    }
    ::player::WHITE {
        return WHITE;
    }
    ::player::ORANGE {
        return ORANGE;
    }
    }

    std::unreachable(fileof(), lineof());
    return std::zeroed[[Color]]();
}

func point_to_pointy_hex(point: Vector2, radius: f32) hex {
    var q = (f32::sqrt(3.0)/3.0 * point.x - 1.0/3.0 * point.y) / radius;
    var r = (2.0/3.0 * point.y) / radius;
    var s = -q - r;

    return hex::init_round(q, r, s);
}

func pointy_hex_to_point(hex: hex, radius: f32) Vector2 {
    var x = radius * (f32::sqrt(3.0) * (:f32)hex.q + f32::sqrt(3.0)/2.0 * (:f32)hex.r);
    var y = radius * (3.0/2.0 * (:f32)hex.r);
    return (:Vector2){.x = x, .y = y};
}

func pointy_hex_vertices(hex: hex, radius: f32) [6]Vector2 {
    var result: [6]Vector2 = uninit;
    var center = pointy_hex_to_point(hex, radius);
    for i in 6 {
        var x = center.x + f32::cos(f32::degrees_to_radians((:f32)i * 360.0 / 6.0 + 30.0)) * radius;
        var y = center.y + f32::sin(f32::degrees_to_radians((:f32)i * 360.0 / 6.0 + 30.0)) * radius;
        result[i] = (:Vector2){.x = x, .y = y};
    }
    return result;
}

func edge_to_points(edge: edge, radius: f32) [2]Vector2 {
    var ret: [2]Vector2 = uninit;
    var cur = 0u;

    var vertices_a = pointy_hex_vertices(edge.hexes[0], radius);
    var vertices_b = pointy_hex_vertices(edge.hexes[1], radius);
    for i in countof(vertices_a) {
        for j in countof(vertices_b) {
            if vec2_feq(vertices_a[i], vertices_b[j]) {
                ret[cur] = vertices_a[i];
                cur = cur + 1;
            }
        }
    }

    return ret;
}

func node_to_point(node: node, radius: f32) Vector2 {
    var ret: Vector2 = uninit;

    var vertices_a = pointy_hex_vertices(node.hexes[0], radius);
    var vertices_b = pointy_hex_vertices(node.hexes[1], radius);
    var vertices_c = pointy_hex_vertices(node.hexes[2], radius);
    for i in countof(vertices_a) {
        for j in countof(vertices_b) {
            for k in countof(vertices_c) {
                if vec2_feq(vertices_a[i], vertices_b[j]) and vec2_feq(vertices_b[j], vertices_c[k]) {
                    ret = vertices_a[i];
                    break;
                }
            }
        }
    }

    return ret;
}

func draw_pointy_hexagon(center: Vector2, radius: f32, color: Color) void {
    let SIDES: sint = 6;
    let ANGLE: f32 = 30.0; # pointy-top orientation
    DrawPoly(center, SIDES, radius, ANGLE, color);
}

func draw_pointy_hexagon_outline(center: Vector2, radius: f32, color: Color) void {
    let SIDES: sint = 6;
    let ANGLE: f32 = 30.0; # pointy-top orientation
    DrawPolyLinesEx(center, SIDES, radius, ANGLE, radius / 8.0, color);
}

func draw_pointy_hexagon_border(center: Vector2, radius: f32, color: Color) void {
    let SIDES: sint = 6;
    let ANGLE: f32 = 30.0; # pointy-top orientation
    var thick: f32 = radius / 16.0;
    DrawPolyLinesEx(center, SIDES, radius + thick / 2.0, ANGLE, thick, color);
}

func draw_circle(center: Vector2, radius: f32, color: Color) void {
    DrawCircleV(center, radius, color);
}

func draw_circle_outline(center: Vector2, radius: f32, thickness: f32, color: Color) void {
    assert thickness <= radius;
    let SIDES: sint = 36;
    let ANGLE: f32 = 0.0;
    DrawPolyLinesEx(center, SIDES, radius, ANGLE, thickness, color);
}

func draw_rect(position: Vector2, w: f32, h: f32, color: Color) void {
    DrawRectangleV(position, (:Vector2){.x = w, .y = h}, color);
}

func draw_rect_outline(position: Vector2, w: f32, h: f32, thickness: f32, color: Color) void {
    assert thickness <= w;
    assert thickness <= h;
    # left side
    DrawRectangleV(
        (:Vector2){
            .x = position.x,
            .y = position.y,
        },
        (:Vector2){
            .x = thickness,
            .y = h,
        },
        color);
    # right side
    DrawRectangleV(
        (:Vector2){
            .x = position.x + w - thickness,
            .y = position.y,
        },
        (:Vector2){
            .x = thickness,
            .y = h,
        },
        color);
    # top side
    DrawRectangleV(
        (:Vector2){
            .x = position.x,
            .y = position.y,
        },
        (:Vector2){
            .x = w,
            .y = thickness,
        },
        color);
    # bottom side
    DrawRectangleV(
        (:Vector2){
            .x = position.x,
            .y = position.y + h - thickness,
        },
        (:Vector2){
            .x = w,
            .y = thickness,
        },
        color);
}

func draw_number_token(center: Vector2, number: sint, radius: f32, font: Font) void {
    var CIRCLE_RADIUS = radius / 2.0;
    let TAN = (:Color){.r = 0xDD, .g = 0xBB, .b = 0x88, .a = 0xFF};
    draw_circle(center, CIRCLE_RADIUS, TAN);
    # Need a little bit extra radius so that all pixels of the
    # outline will cover up the number token circle.
    var CIRCLE_OUTLINE_RADIUS = CIRCLE_RADIUS + 1.0;
    var CIRCLE_OUTLINE_THICKNESS = CIRCLE_RADIUS / 8.0;
    draw_circle_outline(center, CIRCLE_OUTLINE_RADIUS, CIRCLE_OUTLINE_THICKNESS, BLACK);

    var font_size = radius / 3.0;
    var size = measure_text_format(font, font_size,
        "{}",
        (:[]std::formatter)[
            std::formatter::init[[sint]](&number)]);
    var color = BLACK;
    if number == 6 or number == 8 {
        color = RED;
    }
    draw_text_format(font, font_size, color,
        (:Vector2){
            .x = center.x - size.x / 2.0,
            .y = center.y - size.y / 2.0,
        },
        "{}",
        (:[]std::formatter)[
            std::formatter::init[[sint]](&number)]);

    assert 2 <= number and number <= 12;
    let DOTS = (:[]usize)[
        0, # 0 (invalid)
        0, # 1 (invalid)
        1, # 2
        2, # 3
        3, # 4
        4, # 5
        5, # 6
        0, # 7 (invalid)
        5, # 8
        4, # 9
        3, # 10
        2, # 11
        1, # 12
    ];
    var distance = CIRCLE_RADIUS / 3.6;
    var width = (:f32)DOTS[(:usize)number] * distance;
    for i in DOTS[(:usize)number] {
        var position = (:Vector2){
            .x = center.x - width / 2.0 + distance * ((:f32)i + 0.5),
            .y = center.y + CIRCLE_RADIUS / 2.0,
        };
        draw_circle(position, distance / 4.0, color);
    }
}

func draw_port(port: port, radius: f32, font: Font) void {
    var center = pointy_hex_to_point(port.hex, radius);

    var a = node_to_point(port.nodes[0], radius);
    var b = node_to_point(port.nodes[1], radius);
    var thick: f32 = radius / 8.0;
    DrawLineEx(vec2_lerp(center, a, 0.49), vec2_lerp(center, a, 0.91), thick + 1.0, BLACK);
    DrawLineEx(vec2_lerp(center, a, 0.50), vec2_lerp(center, a, 0.90), thick, BROWN);
    DrawLineEx(vec2_lerp(center, b, 0.49), vec2_lerp(center, b, 0.91), thick + 1.0, BLACK);
    DrawLineEx(vec2_lerp(center, b, 0.50), vec2_lerp(center, b, 0.90), thick, BROWN);

    var text = "<error>";
    switch port.kind {
    ::port::ANY {
        text = "3:1";
    }
    ::port::BRICK {
        text = "brick 2:1";
    }
    ::port::ORE {
        text = "ore 2:1";
    }
    ::port::SHEEP {
        text = "sheep 2:1";
    }
    ::port::WHEAT {
        text = "wheat 2:1";
    }
    ::port::WOOD {
        text = "wood 2:1";
    }
    }
    var font_size = radius / 6.0;
    var size = measure_text_cstr(font, font_size, startof(text));
    var position = (:Vector2){.x = center.x - size.x / 2.0, .y = center.y - size.y / 2.0};
    draw_text_cstr(font, font_size, BLACK, position, startof(text));
}

func draw_road(a: Vector2, b: Vector2, radius: f32, color: Color) void {
    var thick: f32 = radius / 8.0;
    DrawLineEx(vec2_lerp(a, b, 0.09), vec2_lerp(a, b, 0.91), thick + 1.0, BLACK);
    DrawLineEx(vec2_lerp(a, b, 0.10), vec2_lerp(a, b, 0.90), thick, color);
}

func draw_settlement(center: Vector2, radius: f32, color: Color) void {
    var center = (:Vector2){
        .x = center.x,
        .y = center.y - radius / 8.0f32, # y-offset
    };
    var size = (:Vector2){
        .x = radius / 3.0,
        .y = radius / 4.0,
    };

    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0 - 1.0, .y = center.y},
        (:Vector2){.x = size.x + 2.0, .y = size.y + 1.0},
        BLACK);
    DrawTriangle(
        (:Vector2){.x = center.x - size.x / 2.0 - 1.2, .y = center.y},
        (:Vector2){.x = center.x + size.x / 2.0 + 1.2, .y = center.y},
        (:Vector2){.x = center.x, .y = center.y - size.y / 2.0 - 1.25},
        BLACK);

    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0, .y = center.y},
        (:Vector2){.x = size.x, .y = size.y},
        color);
    DrawTriangle(
        (:Vector2){.x = center.x - size.x / 2.0, .y = center.y},
        (:Vector2){.x = center.x + size.x / 2.0, .y = center.y},
        (:Vector2){.x = center.x, .y = center.y - size.y / 2.0},
        color);
}

func draw_city(center: Vector2, radius: f32, color: Color) void {
    var center = (:Vector2){
        .x = center.x,
        .y = center.y - radius / 8.0f32, # y-offset
    };
    var size = (:Vector2){
        .x = radius / 2.2,
        .y = radius / 4.0,
    };

    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0 - 1.0, .y = center.y - 1.0},
        (:Vector2){.x = size.x + 2.0, .y = size.y + 2.0},
        BLACK);
    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0 - 1.0, .y = center.y - size.y / 2.0},
        (:Vector2){.x = size.x / 2.0 + 2.0, .y = size.y / 2.0 + 1.0},
        BLACK);
    DrawTriangle(
        (:Vector2){.x = center.x - size.x / 2.0 - 1.0, .y = center.y - size.y / 2.0},
        (:Vector2){.x = center.x + 1.0, .y = center.y - size.y / 2.0},
        (:Vector2){.x = center.x - size.x / 4.0, .y = center.y - size.y - 1.0},
        BLACK);

    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0, .y = center.y},
        (:Vector2){.x = size.x, .y = size.y},
        color);
    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0, .y = center.y - size.y / 2.0},
        (:Vector2){.x = size.x / 2.0, .y = size.y / 2.0},
        color);
    DrawTriangle(
        (:Vector2){.x = center.x - size.x / 2.0, .y = center.y - size.y / 2.0},
        (:Vector2){.x = center.x, .y = center.y - size.y / 2.0},
        (:Vector2){.x = center.x - size.x / 4.0, .y = center.y - size.y},
        color);
}

func draw_robber(center: Vector2, radius: f32, outline: Color) void {
    var radius_h = radius / 6.0;
    var radius_v = radius / 3.0;
    var size = (:Vector2){
        .x = radius_h * 2.0,
        .y = radius_v / 2.0,
    };

    DrawEllipse(
        (:sint)center.x,
        (:sint)center.y,
        radius_h + 1.0,
        radius_v + 1.0,
        outline);
    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0 - 1.0, .y = center.y + radius_v - size.y / 2.0 - 1.0},
        (:Vector2){.x = size.x + 2.0, .y = size.y + 2.0},
        outline);
    DrawCircleV(
        (:Vector2){.x = center.x, .y = center.y - radius_v},
        radius_h * 0.9 + 1.0,
        outline);

    let COLOR = GRAY;
    DrawEllipse(
        (:sint)center.x,
        (:sint)center.y,
        radius_h,
        radius_v,
        COLOR);
    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0, .y = center.y + radius_v - size.y / 2.0},
        (:Vector2){.x = size.x, .y = size.y},
        COLOR);
    DrawCircleV(
        (:Vector2){.x = center.x, .y = center.y - radius_v},
        radius_h * 0.9,
        COLOR);
}

func measure_text(font: Font, size: f32, text: []byte) Vector2 {
    var s = std::string::init_from_str(text);
    defer s.fini();

    let SPACING = 0.0f32;
    return MeasureTextEx(font, s.cstr(), size, SPACING);
}

func draw_text(font: Font, size: f32, color: Color, position: Vector2, text: []byte) void {
    var s = std::string::init_from_str(text);
    defer s.fini();

    let SPACING = 0.0f32;
    DrawTextEx(font, s.cstr(), position, size, SPACING, color);
}

func measure_text_cstr(font: Font, size: f32, text: *byte) Vector2 {
    let SPACING = 0.0f32;
    return MeasureTextEx(font, text, size, SPACING);
}

func draw_text_cstr(font: Font, size: f32, color: Color, position: Vector2, text: *byte) void {
    let SPACING = 0.0f32;
    DrawTextEx(font, text, position, size, SPACING, color);
}

func measure_text_format(font: Font, size: f32, format: []byte, args: []std::formatter) Vector2 {
    var s = std::string::init_from_format(format, args);
    defer s.fini();

    let SPACING = 0.0f32;
    return MeasureTextEx(font, s.cstr(), size, SPACING);
}

func draw_text_format(font: Font, size: f32, color: Color, position: Vector2, format: []byte, args: []std::formatter) void {
    var s = std::string::init_from_format(format, args);
    defer s.fini();

    let SPACING = 0.0f32;
    DrawTextEx(font, s.cstr(), position, size, SPACING, color);
}

func draw_d6(font: Font, font_size: f32, position: Vector2, number: sint, fg: Color, bg: Color) void {
    assert 1 <= number and number <= 6;
    var side = font_size * 2.0;
    let BOARDER = 2.0f32;
    draw_rect(position, side, side, bg);
    draw_rect_outline(position, side, side, BOARDER, BLACK);
    var text_size = measure_text_format(font, font_size,
        "{}",
        (:[]std::formatter)[
            std::formatter::init[[sint]](&number)]);
    draw_text_format(
        font,
        font_size,
        fg,
        (:Vector2){
            .x = position.x + font_size - text_size.x / 2.0,
            .y = position.y + font_size - text_size.y / 2.0,
        },
        "{}",
        (:[]std::formatter)[std::formatter::init[[sint]](&number)]);
}

# NOTE: It appears that raylib 5.0 seems to have changed the behavior the
# Get(Screen|Render)(Width|Height) functions on MacOS from version 4.5,
# requiring the `screen_w` and `screen_h` helper functions to make Camera2D
# work properly in both non-fullscreen and fullscreen modes. At the time of
# writing (2023-12-03) I am not sure whether the current raylib 5.0 behavior is
# intended or whether the 4.5->5.0 behavior change is a bug.

func screen_w() f32 {
    if IsWindowFullscreen() {
        return (:f32)GetRenderWidth();
    }
    return (:f32)GetScreenWidth();
}

func screen_h() f32 {
    if IsWindowFullscreen() {
        return (:f32)GetRenderHeight();
    }
    return (:f32)GetScreenHeight();
}

func camera_zoom(radius: f32) f32 {
    # Return a camera zoom such that the board and board-adjacent ocean tiles
    # fit on the screen. Approximate the length of the board and board-adjacent
    # ocean tiles as six tile diameters (five board tiles plus two ocean tiles
    # on either side minus half a tile to somewhat account for radius overlap).
    return screen_h() / (6.5 * 2.0 * radius);
}

func camera(radius: f32) Camera2D {
    return (:Camera2D){
        .target = (:Vector2){
            .x = 0.0f32,
            .y = 0.0f32,
        },
        .offset = (:Vector2){
            .x = screen_w() / 2.0 - screen_w() / 6.0,
            .y = screen_h() / 2.0 - screen_h() / 8.0,
        },
        .rotation = 0.0f32,
        .zoom = camera_zoom(radius),
    };
}

struct client_state {
    var debug: bool;

    var font: Font;
    var font_size: f32;
    var ui_font: *Font;
    var ui_font_size: f32;
    var ui_log: std::string;
    var ui_log_updated: bool;
    var ui_resources_select: resources;
    var ui_main_build_road_selected: bool;
    var ui_main_build_town_selected: bool;
    var ui_main_play_dev_card_selected: bool;
    var ui_main_trade_with_bank_selected: bool;
    var ui_main_trade_with_bank_resource: std::optional[[resource]]; # x:1 resource->...
    var ui_main_trade_with_players_selected: bool;
    var ui_main_trade_with_players_give: resources;
    var ui_main_trade_with_players_recv: resources;
    var ui_main_trade_submitted: bool;
    var ui: smol::ui;

    var player: player;
    var pinfo: hidden_player_info;
    var board: board;
    var r: public_player_info;
    var b: public_player_info;
    var w: public_player_info;
    var o: public_player_info;
    var turn: turn;
    var trade: trade;

    var mouse: Vector2;
    var world: Vector2;
    var world_hex: hex;
    var world_tile: std::optional[[tile]];
    var world_edge: std::optional[[edge]];
    var world_node: std::optional[[node]];

    func init() client_state {
        let FONT_NUMCHARS: sint = '~' - ' ' + 1; # Printable ASCII
        let PUBLIC_PIXEL_TTF = embed("assets/PublicPixel.ttf");
        var font_size = 16.0f32;
        var font = LoadFontFromMemory(
            startof(".ttf"),
            (:*u8)startof(PUBLIC_PIXEL_TTF),
            (:sint)countof(PUBLIC_PIXEL_TTF),
            (:sint)font_size,
            std::ptr[[sint]]::NULL,
            FONT_NUMCHARS);

        let RUNESCAPE_UF_TTF = embed("assets/RuneScapeUF.ttf");
        var ui_font_size = 16.0f32;
        var ui_font = std::new[[Font]]();
        *ui_font = LoadFontFromMemory(
            startof(".ttf"),
            (:*u8)startof(RUNESCAPE_UF_TTF),
            (:sint)countof(RUNESCAPE_UF_TTF),
            (:sint)ui_font_size,
            std::ptr[[sint]]::NULL,
            FONT_NUMCHARS);

        var ctx = std::new[[mu_Context]]();
        mu_init(ctx);
        smol::setup_font(ctx, ui_font);
        var ui_log = std::string::init();
        var ui = smol::ui::init(ctx);

        var board = board::init();

        return (:client_state){
            .debug = false,

            .font = font,
            .font_size = font_size,
            .ui_font = ui_font,
            .ui_font_size = ui_font_size,
            .ui_log = ui_log,
            .ui_log_updated = false,
            .ui_resources_select = uninit,
            .ui_main_build_road_selected = false,
            .ui_main_build_town_selected = false,
            .ui_main_play_dev_card_selected = false,
            .ui_main_trade_with_bank_selected = false,
            .ui_main_trade_with_bank_resource = uninit,
            .ui_main_trade_with_players_selected = false,
            .ui_main_trade_with_players_give = uninit,
            .ui_main_trade_with_players_recv = uninit,
            .ui_main_trade_submitted = false,
            .ui = ui,

            .player = player::NIL,
            .pinfo = uninit,
            .board = board,
            .r = uninit,
            .b = uninit,
            .w = uninit,
            .o = uninit,
            .turn = uninit,
            .trade = uninit,

            .mouse = uninit,
            .world = uninit,
            .world_hex = uninit,
            .world_tile = uninit,
            .world_edge = uninit,
            .world_node = uninit,
        };
    }

    func fini(self: *client_state) void {
        std::delete[[mu_Context]](self.*.ui.context);
        self.*.ui_log.fini();
        UnloadFont(*self.*.ui_font);
        std::delete[[Font]](self.*.ui_font);
        UnloadFont(self.*.font);
        self.*.board.fini();
    }

    func p_info(self: *client_state, player: player) *public_player_info {
        switch player {
        ::player::NIL {
            std::unreachable(fileof(), lineof());
        }
        ::player::RED {
            return &self.*.r;
        }
        ::player::BLUE {
            return &self.*.b;
        }
        ::player::WHITE {
            return &self.*.w;
        }
        ::player::ORANGE {
            return &self.*.o;
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[*public_player_info]]();
    }

    func p_discarded(self: *client_state) *bool {
        switch self.*.player {
        player::NIL {
            std::unreachable(fileof(), lineof());
        }
        player::RED {
            return &self.*.r.discarded;
        }
        player::BLUE {
            return &self.*.b.discarded;
        }
        player::WHITE {
            return &self.*.w.discarded;
        }
        player::ORANGE {
            return &self.*.o.discarded;
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[*bool]]();
    }

    func p_trade_submitted(self: *client_state) *bool {
        switch self.*.player {
        player::NIL {
            std::unreachable(fileof(), lineof());
        }
        player::RED {
            return &self.*.r.trade_submitted;
        }
        player::BLUE {
            return &self.*.b.trade_submitted;
        }
        player::WHITE {
            return &self.*.w.trade_submitted;
        }
        player::ORANGE {
            return &self.*.o.trade_submitted;
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[*bool]]();
    }

    func update_from_server_message(self: *client_state, message: *server_message) void {
        switch message.*.kind {
        server_message::LOG {
            var log_writer = std::writer::init[[std::string]](&self.*.ui_log);
            std::print_line(log_writer, message.*.data.log.data());
            self.*.ui_log_updated = true;
        }
        server_message::INFO {
            self.*.pinfo = message.*.data.info;
        }
        server_message::STATE {
            board::assign(&self.*.board, &message.*.data.state.board);
            self.*.turn = message.*.data.state.turn;
            self.*.trade = message.*.data.state.trade;
            self.*.r = message.*.data.state.r;
            self.*.b = message.*.data.state.b;
            self.*.w = message.*.data.state.w;
            self.*.o = message.*.data.state.o;
        }
        server_message::PLAYER {
            self.*.player = message.*.data.player;
        }
        server_message::ACCEPTED {
            std::print_format_line(std::err(), "[ACTION ACCEPTED]: {}", (:[]std::formatter)[std::formatter::init[[std::string]](&message.*.data.accepted)]);
            if self.*.debug {
                var log_writer = std::writer::init[[std::string]](&self.*.ui_log);
                std::print_format_line(log_writer, "[ACTION ACCEPTED]: {}", (:[]std::formatter)[std::formatter::init[[std::string]](&message.*.data.accepted)]);
                self.*.ui_log_updated = true;
            }
        }
        server_message::REJECTED {
            std::print_format_line(std::err(), "[ACTION REJECTED]: {}", (:[]std::formatter)[std::formatter::init[[std::string]](&message.*.data.rejected)]);
            if self.*.debug {
                var log_writer = std::writer::init[[std::string]](&self.*.ui_log);
                std::print_format_line(log_writer, "[ACTION REJECTED]: {}", (:[]std::formatter)[std::formatter::init[[std::string]](&message.*.data.rejected)]);
                self.*.ui_log_updated = true;
            }
        }
        }
    }
}

# In HTML this input element is has type "number", but elsewhere it is referred
# to as a spinner for some reason. I'm calling it a "UI Number Select" for now.
#
# https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/number
# https://jqueryui.com/spinner/
# https://www.mathworks.com/help/matlab/ref/uispinner.html
func ui_number_select(ui: *smol::ui, value: *sint, min: sint, max: sint) void {
    ui.*.push_id(&value, sizeof(typeof(value)));
    ui.*.layout_begin_column();

    var button_w: sint = 32;
    ui.*.layout_row((:[]sint)[button_w, button_w, -1], 0);

    if ui.*.button("-1") {
        *value -= 1;
    }
    if ui.*.button("+1") {
        *value += 1;
    }
    *value = sint::max(min, *value);
    *value = sint::min(max, *value);

    ui.*.begin_panel_ex("PANEL", smol::OPT_NOSCROLL); # XXX: Duplicate IDs?
    var s = std::string::init_from_format("{}", (:[]std::formatter)[std::formatter::init[[sint]](value)]);
    defer s.fini();
    ui.*.text(s.data());
    ui.*.end_panel();

    ui.*.layout_end_column();
    ui.*.pop_id();
}

let UI_BORDER: sint = 8;

# XXX: Uses ui_main_play_dev_card_selected even though this can be called for
# the resource production. This should be renamed to ui_play_dev_card_selected,
# or something similar. Or better yet, use a variant to handle UI state.
func ui_window_play_dev_card(cstate: *client_state, sender: *message_sender[[client_message]]) void {
    var screen_w = screen_w();
    var screen_h = screen_h();

    var ui_w = (:sint)screen_w / 4;
    var ui_h = (:sint)screen_h / 4;
    var ui_x = (:sint)screen_w * 2 / 3 - ui_w - 2 * UI_BORDER;
    var ui_y = (:sint)screen_h - ui_h - UI_BORDER;

    sender; # TODO: Use `sender` for the eventual client messages.

    if cstate.*.ui.begin_window_ex("Play a Development Card", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        # Re-set cached window rect in case the screen was resized.
        var win = cstate.*.ui.get_current_container();
        win.*.rect.w = ui_w;
        win.*.rect.h = ui_h;
        win.*.rect.x = ui_x;
        win.*.rect.y = ui_y;

        # Window Content
        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        if cstate.*.ui.button("Play Knight") {
            sender.*.sendc(client_message::init_use_dev_card_knight());
            cstate.*.ui_main_play_dev_card_selected = false;
        }
        if cstate.*.ui.button("Play Road Building") {
            std::print_line(std::err(), "TODO: Play Road Building...");
            cstate.*.ui_main_play_dev_card_selected = false;
        }
        if cstate.*.ui.button("Play Year of Plenty") {
            std::print_line(std::err(), "TODO: Play Year of Plenty...");
            cstate.*.ui_main_play_dev_card_selected = false;
        }
        if cstate.*.ui.button("Play Monopoly") {
            std::print_line(std::err(), "TODO: Play Monopoly...");
            cstate.*.ui_main_play_dev_card_selected = false;
        }
        if cstate.*.ui.button("Back") {
            cstate.*.ui_main_play_dev_card_selected = false;
        }

        cstate.*.ui.end_window();
    }
}

func client_update(cstate: *client_state, sender: *message_sender[[client_message]]) void {
    # Collect basic information about the state of the window/camera, position
    # of the mouse in screen space & world space, and objects that the mouse is
    # currently hovering over.
    var camera = camera(HEX_RADIUS);

    var mouse = GetMousePosition();
    var world = GetScreenToWorld2D(mouse, camera);
    var world_hex = point_to_pointy_hex(world, HEX_RADIUS);

    var world_tile = std::optional[[tile]]::EMPTY;
    var iter = std::hash_map_iterator[[hex, tile]]::init(&cstate.*.board.tiles);
    for iter.advance() {
        if std::eq[[hex]](iter.current().*.key, &world_hex) {
            world_tile = std::optional[[tile]]::init_value(*iter.current().*.value);
            break;
        }
    }

    var world_edge = std::optional[[edge]]::EMPTY;
    var iter = std::hash_set_iterator[[edge]]::init(&cstate.*.board.edges);
    for iter.advance() {
        var found = true;
        for i in countof(iter.current().*.hexes) {
            let DISTANCE = HEX_RADIUS * 1.15;
            var hex = iter.current().*.hexes[i];
            if vec2_distance(world, pointy_hex_to_point(hex, HEX_RADIUS)) > DISTANCE {
                found = false;
                break;
            }
        }

        if found {
            world_edge = std::optional[[edge]]::init_value(*iter.current());
            break;
        }
    }

    var world_node = std::optional[[node]]::EMPTY;
    var iter = std::hash_set_iterator[[node]]::init(&cstate.*.board.nodes);
    for iter.advance() {
        var found = true;
        for i in countof(iter.current().*.hexes) {
            let DISTANCE = HEX_RADIUS * 1.15;
            var hex = iter.current().*.hexes[i];
            if vec2_distance(world, pointy_hex_to_point(hex, HEX_RADIUS)) > DISTANCE {
                found = false;
                break;
            }
        }

        if found {
            world_node = std::optional[[node]]::init_value(*iter.current());
            break;
        }
    }

    cstate.*.mouse = mouse;
    cstate.*.world = world;
    cstate.*.world_hex = world_hex;
    cstate.*.world_tile = world_tile;
    cstate.*.world_edge = world_edge;
    cstate.*.world_node = world_node;

    # Actions processed regardless of the client's current player state.
    if IsKeyPressed(KEY_F3) {
        cstate.*.debug = not cstate.*.debug;
    }
    if IsKeyPressed(KEY_F4) {
        ToggleFullscreen();
    }
    if IsKeyPressed(KEY_ZERO) {
        sender.*.sendc(client_message::init_select_player(player::NIL));
    }
    if IsKeyPressed(KEY_ONE) {
        sender.*.sendc(client_message::init_select_player(player::RED));
    }
    if IsKeyPressed(KEY_TWO) {
        sender.*.sendc(client_message::init_select_player(player::BLUE));
    }
    if IsKeyPressed(KEY_THREE) {
        sender.*.sendc(client_message::init_select_player(player::WHITE));
    }
    if IsKeyPressed(KEY_FOUR) {
        sender.*.sendc(client_message::init_select_player(player::ORANGE));
    }

    # Begin UI
    var screen_w = screen_w();
    var screen_h = screen_h();
    smol::handle_input(cstate.*.ui.context);
    mu_begin(cstate.*.ui.context);

    # Select Player/Color UI Window
    var ui_w = (:sint)screen_w / 4;
    var ui_h = (:sint)screen_h / 4;
    var ui_x = (:sint)screen_w * 2 / 3 - ui_w - 2 * UI_BORDER;
    var ui_y = (:sint)screen_h - ui_h - UI_BORDER;
    var show_ui = cstate.*.player == player::NIL;
    if show_ui and cstate.*.ui.begin_window_ex("Select Color", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        # Re-set cached window rect in case the screen was resized.
        var win = cstate.*.ui.get_current_container();
        win.*.rect.w = ui_w;
        win.*.rect.h = ui_h;
        win.*.rect.x = ui_x;
        win.*.rect.y = ui_y;

        # Window Content
        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        if cstate.*.ui.button("Red") {
            sender.*.sendc(client_message::init_select_player(player::RED));
        }
        if cstate.*.ui.button("Blue") {
            sender.*.sendc(client_message::init_select_player(player::BLUE));
        }
        if cstate.*.ui.button("White") {
            sender.*.sendc(client_message::init_select_player(player::WHITE));
        }
        if cstate.*.ui.button("Orange") {
            sender.*.sendc(client_message::init_select_player(player::ORANGE));
        }

        cstate.*.ui.end_window();
    }

    # Player Info UI Windows
    let UI_PLAYERS = (:[4]player)[player::RED, player::BLUE, player::WHITE, player::ORANGE];
    var ui_players_w = (:sint)screen_w * 1 / 3;
    var ui_players_h = ((:sint)screen_h * 1 / 2 - 2 * UI_BORDER) / (:sint)countof(UI_PLAYERS);
    for i in countof(UI_PLAYERS) {
        var player = UI_PLAYERS[i];
        if not cstate.*.p_info(player).*.live {
            continue;
        }

        var pcolor = player_color(player);
        cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLEBG].r = pcolor.r;
        cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLEBG].g = pcolor.g;
        cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLEBG].b = pcolor.b;
        cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLEBG].a = 0xFF;
        if player == ::player::WHITE {
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].r = BLACK.r;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].g = BLACK.g;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].b = BLACK.b;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].a = 0xFF;
        }
        else {
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].r = WHITE.r;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].g = WHITE.g;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].b = WHITE.b;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].a = 0xFF;
        }
        if cstate.*.turn.player == player {
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].r = YELLOW.r;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].g = YELLOW.g;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].b = YELLOW.b;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].a = 0xFF;
        }
        else {
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].r = BLACK.r;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].g = BLACK.g;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].b = BLACK.b;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].a = 0xFF;
        }

        var ui_w = ui_players_w;
        var ui_h = ui_players_h;
        var ui_x = (:sint)screen_w - ui_w - UI_BORDER;
        var ui_y = UI_BORDER + (:sint)i * (ui_players_h + UI_BORDER);
        if cstate.*.ui.begin_window_ex(player_to_name(player), smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NODRAG | smol::OPT_NOCLOSE) {
            # Re-set cached window rect in case the screen was resized.
            var win = cstate.*.ui.get_current_container();
            win.*.rect.w = ui_w;
            win.*.rect.h = ui_h;
            win.*.rect.x = ui_x;
            win.*.rect.y = ui_y;

            # Window Content
            var victory_points: sint = uninit;
            var resources: sint = uninit;
            var dev_cards: sint = uninit;
            switch player {
            ::player::NIL {
                std::unreachable(fileof(), lineof());
            }
            ::player::RED {
                victory_points = cstate.*.r.victory_points;
                resources = cstate.*.r.resources;
                dev_cards = cstate.*.r.dev_cards;
            }
            ::player::BLUE {
                victory_points = cstate.*.b.victory_points;
                resources = cstate.*.b.resources;
                dev_cards = cstate.*.b.dev_cards;
            }
            ::player::WHITE {
                victory_points = cstate.*.w.victory_points;
                resources = cstate.*.w.resources;
                dev_cards = cstate.*.w.dev_cards;
            }
            ::player::ORANGE {
                victory_points = cstate.*.o.victory_points;
                resources = cstate.*.o.resources;
                dev_cards = cstate.*.o.dev_cards;
            }
            }

            if player == cstate.*.player {
                for i in cstate.*.pinfo.dev_card_count {
                    if cstate.*.pinfo.dev_card_array[i].kind == dev_card::VICTORY_POINT {
                        victory_points += 1;
                    }
                }
            }

            cstate.*.ui.layout_row((:[]sint)[-1], 1);
            var s = std::string::init_from_format(
                "Victory Points: {}, Resources: {}, Dev Cards: {}",
                (:[]std::formatter)[
                    std::formatter::init[[sint]](&victory_points),
                    std::formatter::init[[sint]](&resources),
                    std::formatter::init[[sint]](&dev_cards)]);
            defer s.fini();
            cstate.*.ui.text(s.data());

            if player == cstate.*.player {
                var s = std::string::init_from_format(
                    "Brick: {}, Ore: {}, Sheep: {}, Wheat: {}, Wood: {}",
                    (:[]std::formatter)[
                        std::formatter::init[[sint]](&cstate.*.pinfo.brick),
                        std::formatter::init[[sint]](&cstate.*.pinfo.ore),
                        std::formatter::init[[sint]](&cstate.*.pinfo.sheep),
                        std::formatter::init[[sint]](&cstate.*.pinfo.wheat),
                        std::formatter::init[[sint]](&cstate.*.pinfo.wood)]);
                defer s.fini();
                cstate.*.ui.text(s.data());

                var knight_count: usize = 0;
                var road_building_count: usize = 0;
                var year_of_plenty_count: usize = 0;
                var monopoly_count: usize = 0;
                var victory_point_count: usize = 0;
                for i in cstate.*.pinfo.dev_card_count {
                    if cstate.*.pinfo.dev_card_array[i].used {
                        continue;
                    }
                    switch cstate.*.pinfo.dev_card_array[i].kind {
                    dev_card::KNIGHT {
                        knight_count += 1;
                    }
                    dev_card::ROAD_BUILDING {
                        road_building_count += 1;
                    }
                    dev_card::YEAR_OF_PLENTY {
                        year_of_plenty_count += 1;
                    }
                    dev_card::MONOPOLY {
                        monopoly_count += 1;
                    }
                    dev_card::VICTORY_POINT {
                        victory_point_count += 1;
                    }
                    }
                }
                var s = std::string::init_from_format(
                    "[Dev Cards] Kn: {}, RB: {}, YoP: {}, Mo: {}, VP: {}",
                    (:[]std::formatter)[
                        std::formatter::init[[usize]](&knight_count),
                        std::formatter::init[[usize]](&road_building_count),
                        std::formatter::init[[usize]](&year_of_plenty_count),
                        std::formatter::init[[usize]](&monopoly_count),
                        std::formatter::init[[usize]](&victory_point_count)]);
                defer s.fini();
                cstate.*.ui.text(s.data());
            }

            cstate.*.ui.end_window();
        }
    }

    # Log UI Window
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].r = BLACK.r;
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].g = BLACK.g;
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].b = BLACK.b;
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].a = 0xFF;
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLEBG].r = BLACK.r;
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLEBG].g = BLACK.g;
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLEBG].b = BLACK.b;
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLEBG].a = 0xFF;
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].r = WHITE.r;
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].g = WHITE.g;
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].b = WHITE.b;
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].a = 0xFF;
    var ui_w = (:sint)screen_w * 1 / 3;
    var ui_h = (:sint)screen_h * 1 / 2 - 4 * UI_BORDER;
    var ui_x = (:sint)screen_w - ui_w - UI_BORDER;
    var ui_y = (:sint)screen_h * 1 / 2 + 3 * UI_BORDER;
    if cstate.*.ui.begin_window_ex("LOG", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NODRAG | smol::OPT_NOCLOSE) {
        # Re-set cached window rect in case the screen was resized.
        var win = cstate.*.ui.get_current_container();
        win.*.rect.w = ui_w;
        win.*.rect.h = ui_h;
        win.*.rect.x = ui_x;
        win.*.rect.y = ui_y;

        # Window Content
        cstate.*.ui.layout_row((:[]sint)[-1], -1);
        cstate.*.ui.text(std::ascii::view_trimmed(cstate.*.ui_log.data()));

        # Re-set scroll if the log was updated.
        if cstate.*.ui_log_updated {
            win.*.scroll.y = win.*.content_size.y;
            cstate.*.ui_log_updated = false;
        }

        cstate.*.ui.end_window();
    }

    # Resource Production Roll UI Window
    var ui_w = (:sint)screen_w / 4;
    var ui_h = (:sint)screen_h / 4;
    var ui_x = (:sint)screen_w * 2 / 3 - ui_w - 2 * UI_BORDER;
    var ui_y = (:sint)screen_h - ui_h - UI_BORDER;
    var show_ui = cstate.*.turn.phase == phase::RESOURCE_PRODUCTION and cstate.*.turn.player == cstate.*.player;
    if show_ui and cstate.*.ui_main_play_dev_card_selected {
        ui_window_play_dev_card(cstate, sender);
    }
    elif show_ui and cstate.*.ui.begin_window_ex("Your Turn (resource production)", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        # Re-set cached window rect in case the screen was resized.
        var win = cstate.*.ui.get_current_container();
        win.*.rect.w = ui_w;
        win.*.rect.h = ui_h;
        win.*.rect.x = ui_x;
        win.*.rect.y = ui_y;

        # Window Content
        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        if cstate.*.ui.button("Roll") {
            sender.*.sendc(client_message::init_roll());
        }
        if cstate.*.ui.button("Play a Development Card") {
            cstate.*.ui_main_play_dev_card_selected = true;
        }

        cstate.*.ui.end_window();
    }

    # Discard Resources UI Window
    var ui_w = (:sint)screen_w / 4;
    var ui_h = (:sint)screen_h / 4;
    var ui_x = (:sint)screen_w * 2 / 3 - ui_w - 2 * UI_BORDER;
    var ui_y = (:sint)screen_h - ui_h - UI_BORDER;
    var show_ui = cstate.*.turn.phase == phase::DISCARD and not *cstate.*.p_discarded();
    if show_ui and cstate.*.ui.begin_window_ex("Select Resources", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        # Re-set cached window rect in case the screen was resized.
        var win = cstate.*.ui.get_current_container();
        win.*.rect.w = ui_w;
        win.*.rect.h = ui_h;
        win.*.rect.x = ui_x;
        win.*.rect.y = ui_y;

        # Window Content
        cstate.*.ui.layout_row((:[]sint)[64, -1], 0);
        cstate.*.ui.label("Brick:");
        ui_number_select(&cstate.*.ui, &cstate.*.ui_resources_select.brick, 0, cstate.*.pinfo.brick);
        cstate.*.ui.label("Ore:");
        ui_number_select(&cstate.*.ui, &cstate.*.ui_resources_select.ore, 0,  cstate.*.pinfo.ore);
        cstate.*.ui.label("Sheep:");
        ui_number_select(&cstate.*.ui, &cstate.*.ui_resources_select.sheep, 0, cstate.*.pinfo.sheep);
        cstate.*.ui.label("Wheat:");
        ui_number_select(&cstate.*.ui, &cstate.*.ui_resources_select.wheat, 0, cstate.*.pinfo.wheat);
        cstate.*.ui.label("Wood:");
        ui_number_select(&cstate.*.ui, &cstate.*.ui_resources_select.wood, 0, cstate.*.pinfo.wood);
        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        var total = cstate.*.ui_resources_select.count();
        var s = std::string::init_from_format("Total = {}", (:[]std::formatter)[std::formatter::init[[sint]](&total)]);
        defer s.fini();
        cstate.*.ui.text(s.data());
        if cstate.*.ui.button("Submit") {
            sender.*.sendc(client_message::init_submit_resources(cstate.*.ui_resources_select));
            cstate.*.ui_resources_select = std::zeroed[[resources]]();
        }

        cstate.*.ui.end_window();
    }

    # Steal From Player UI Window
    var ui_w = (:sint)screen_w / 8;
    var ui_h = (:sint)screen_h / 4;
    var ui_x = (:sint)screen_w * 2 / 3 - ui_w - 2 * UI_BORDER;
    var ui_y = (:sint)screen_h - ui_h - UI_BORDER;
    var show_ui = cstate.*.turn.phase == phase::STEAL and cstate.*.turn.player == cstate.*.player;
    if show_ui and cstate.*.ui.begin_window_ex("Select Player", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        # Re-set cached window rect in case the screen was resized.
        var win = cstate.*.ui.get_current_container();
        win.*.rect.w = ui_w;
        win.*.rect.h = ui_h;
        win.*.rect.x = ui_x;
        win.*.rect.y = ui_y;

        # Window Content
        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        if cstate.*.ui.button("RED") {
            sender.*.sendc(client_message::init_submit_player(player::RED));
        }
        if cstate.*.ui.button("BLUE") {
            sender.*.sendc(client_message::init_submit_player(player::BLUE));
        }
        if cstate.*.ui.button("WHITE") {
            sender.*.sendc(client_message::init_submit_player(player::WHITE));
        }
        if cstate.*.ui.button("ORANGE") {
            sender.*.sendc(client_message::init_submit_player(player::ORANGE));
        }

        cstate.*.ui.end_window();
    }

    # Main Phase UI Window(s)
    var ui_w = (:sint)screen_w / 4;
    var ui_h = (:sint)screen_h / 4;
    var ui_x = (:sint)screen_w * 2 / 3 - ui_w - 2 * UI_BORDER;
    var ui_y = (:sint)screen_h - ui_h - UI_BORDER;
    var show_ui = cstate.*.turn.phase == phase::MAIN and cstate.*.turn.player == cstate.*.player;
    if show_ui
    and cstate.*.ui_main_build_road_selected
    and cstate.*.ui.begin_window_ex("Build Road", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        # Re-set cached window rect in case the screen was resized.
        var win = cstate.*.ui.get_current_container();
        win.*.rect.w = ui_w;
        win.*.rect.h = ui_h;
        win.*.rect.x = ui_x;
        win.*.rect.y = ui_y;

        # Window Content
        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        if cstate.*.ui.button("Back") {
            cstate.*.ui_main_build_road_selected = false;
        }

        cstate.*.ui.end_window();
    }
    elif show_ui
    and cstate.*.ui_main_build_town_selected
    and cstate.*.ui.begin_window_ex("Build Town", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        # Re-set cached window rect in case the screen was resized.
        var win = cstate.*.ui.get_current_container();
        win.*.rect.w = ui_w;
        win.*.rect.h = ui_h;
        win.*.rect.x = ui_x;
        win.*.rect.y = ui_y;

        # Window Content
        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        if cstate.*.ui.button("Back") {
            cstate.*.ui_main_build_town_selected = false;
        }

        cstate.*.ui.end_window();
    }
    elif show_ui
    and cstate.*.ui_main_play_dev_card_selected {
        ui_window_play_dev_card(cstate, sender);
    }
    elif show_ui
    and cstate.*.ui_main_trade_with_bank_selected
    and cstate.*.ui.begin_window_ex("Trade with Bank", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        # Re-set cached window rect in case the screen was resized.
        var win = cstate.*.ui.get_current_container();
        win.*.rect.w = ui_w;
        win.*.rect.h = ui_h;
        win.*.rect.x = ui_x;
        win.*.rect.y = ui_y;

        # Window Content
        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        if cstate.*.ui_main_trade_with_bank_resource.is_value() {
            for i in countof(RESOURCES) {
                var name = RESOURCES[i].data();
                var s = std::string::init_from_format(
                    ".. for {}",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(name)]](&name)]);
                defer s.fini();
                var id = mu_get_id(cstate.*.ui.context, s.start(), (:sint)s.count());
                var r = mu_layout_next(cstate.*.ui.context);
                if mu_button_raw(cstate.*.ui.context, s.start(), (:sint)s.count(), 0, id, r, MU_OPT_ALIGNCENTER) != 0 {
                    var n_to_1 = n_to_1(&cstate.*.board, cstate.*.player, RESOURCES[i]);
                    var cmessage = client_message::init_trade_n_for_1(cstate.*.ui_main_trade_with_bank_resource.value(), RESOURCES[i], n_to_1);
                    sender.*.sendc(cmessage);
                    cstate.*.ui_main_trade_with_bank_selected = false;
                    cstate.*.ui_main_trade_with_bank_resource = std::optional[[resource]]::EMPTY;
                }
            }
            if cstate.*.ui.button("Back") {
                cstate.*.ui_main_trade_with_bank_selected = true;
                cstate.*.ui_main_trade_with_bank_resource = std::optional[[resource]]::EMPTY;
            }
        }
        else {
            for i in countof(RESOURCES) {
                var name = RESOURCES[i].data();
                var n_to_1 = n_to_1(&cstate.*.board, cstate.*.player, RESOURCES[i]);
                var s = std::string::init_from_format(
                    "{}:1 {}...",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(n_to_1)]](&n_to_1),
                        std::formatter::init[[typeof(name)]](&name)]);
                defer s.fini();
                var id = mu_get_id(cstate.*.ui.context, s.start(), (:sint)s.count());
                var r = mu_layout_next(cstate.*.ui.context);
                if mu_button_raw(cstate.*.ui.context, s.start(), (:sint)s.count(), 0, id, r, MU_OPT_ALIGNCENTER) != 0 {
                    cstate.*.ui_main_trade_with_bank_resource = std::optional[[resource]]::init_value(RESOURCES[i]);
                }
            }
            if cstate.*.ui.button("Back") {
                cstate.*.ui_main_trade_with_bank_selected = false;
                cstate.*.ui_main_trade_with_bank_resource = std::optional[[resource]]::EMPTY;
            }
        }

        cstate.*.ui.end_window();
    }
    elif show_ui
    and cstate.*.ui_main_trade_with_players_selected {
        var ui_recv_x = ui_x;
        var ui_recv_y = ui_y - ui_h - UI_BORDER;

        var ui_give_x = ui_recv_x - ui_w - UI_BORDER;
        var ui_give_y = ui_recv_y;

        # Give Window
        if cstate.*.ui.begin_window_ex("Resources to Give", smol::rect::init(ui_give_x, ui_give_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
            # Re-set cached window rect in case the screen was resized.
            var win = cstate.*.ui.get_current_container();
            win.*.rect.w = ui_w;
            win.*.rect.h = ui_h;
            win.*.rect.x = ui_give_x;
            win.*.rect.y = ui_give_y;

            # Window Content
            cstate.*.ui.layout_row((:[]sint)[64, -1], 0);
            cstate.*.ui.label("Brick:");
            ui_number_select(&cstate.*.ui, &cstate.*.ui_main_trade_with_players_give.brick, 0, cstate.*.pinfo.brick);
            cstate.*.ui.label("Ore:");
            ui_number_select(&cstate.*.ui, &cstate.*.ui_main_trade_with_players_give.ore, 0,  cstate.*.pinfo.ore);
            cstate.*.ui.label("Sheep:");
            ui_number_select(&cstate.*.ui, &cstate.*.ui_main_trade_with_players_give.sheep, 0, cstate.*.pinfo.sheep);
            cstate.*.ui.label("Wheat:");
            ui_number_select(&cstate.*.ui, &cstate.*.ui_main_trade_with_players_give.wheat, 0, cstate.*.pinfo.wheat);
            cstate.*.ui.label("Wood:");
            ui_number_select(&cstate.*.ui, &cstate.*.ui_main_trade_with_players_give.wood, 0, cstate.*.pinfo.wood);

            cstate.*.ui.end_window();
        }

        # Recv Window
        if cstate.*.ui.begin_window_ex("Resources to Receive", smol::rect::init(ui_recv_x, ui_recv_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
            # Re-set cached window rect in case the screen was resized.
            var win = cstate.*.ui.get_current_container();
            win.*.rect.w = ui_w;
            win.*.rect.h = ui_h;
            win.*.rect.x = ui_recv_x;
            win.*.rect.y = ui_recv_y;

            # Window Content
            cstate.*.ui.layout_row((:[]sint)[-1], 0);
            cstate.*.ui.layout_row((:[]sint)[64, -1], 0);
            cstate.*.ui.label("Brick:");
            ui_number_select(&cstate.*.ui, &cstate.*.ui_main_trade_with_players_recv.brick, 0, sint::MAX);
            cstate.*.ui.label("Ore:");
            ui_number_select(&cstate.*.ui, &cstate.*.ui_main_trade_with_players_recv.ore, 0,  sint::MAX);
            cstate.*.ui.label("Sheep:");
            ui_number_select(&cstate.*.ui, &cstate.*.ui_main_trade_with_players_recv.sheep, 0, sint::MAX);
            cstate.*.ui.label("Wheat:");
            ui_number_select(&cstate.*.ui, &cstate.*.ui_main_trade_with_players_recv.wheat, 0, sint::MAX);
            cstate.*.ui.label("Wood:");
            ui_number_select(&cstate.*.ui, &cstate.*.ui_main_trade_with_players_recv.wood, 0, sint::MAX);

            cstate.*.ui.end_window();
        }

        # Menu Buttons Window
        if cstate.*.ui.begin_window_ex("Trade with Players", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
            # Re-set cached window rect in case the screen was resized.
            var win = cstate.*.ui.get_current_container();
            win.*.rect.w = ui_w;
            win.*.rect.h = ui_h;
            win.*.rect.x = ui_x;
            win.*.rect.y = ui_y;

            # Window Content
            cstate.*.ui.layout_row((:[]sint)[-1], 0);
            if cstate.*.ui.button("Propose Trade") {
                var cmessage = client_message::init_trade_players(cstate.*.ui_main_trade_with_players_give, cstate.*.ui_main_trade_with_players_recv);
                sender.*.sendc(cmessage);
                cstate.*.ui_main_trade_with_players_selected = false;
                cstate.*.ui_main_trade_with_players_give = std::zeroed[[resources]]();
                cstate.*.ui_main_trade_with_players_recv = std::zeroed[[resources]]();
            }
            if cstate.*.ui.button("Back") {
                cstate.*.ui_main_trade_with_players_selected = false;
                cstate.*.ui_main_trade_with_players_give = std::zeroed[[resources]]();
                cstate.*.ui_main_trade_with_players_recv = std::zeroed[[resources]]();
            }

            cstate.*.ui.end_window();
        }
    }
    elif show_ui
    and cstate.*.ui.begin_window_ex("Your Turn", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        # Re-set cached window rect in case the screen was resized.
        var win = cstate.*.ui.get_current_container();
        win.*.rect.w = ui_w;
        win.*.rect.h = ui_h;
        win.*.rect.x = ui_x;
        win.*.rect.y = ui_y;

        # Window Content
        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        if cstate.*.ui.button("Build a Road") {
            cstate.*.ui_main_build_road_selected = true;
        }
        if cstate.*.ui.button("Build a Settlement/City") {
            cstate.*.ui_main_build_town_selected = true;
        }
        if cstate.*.ui.button("Buy a Development Card") {
            sender.*.sendc(client_message::init_buy_dev_card());
        }
        if cstate.*.ui.button("Play a Development Card") {
            cstate.*.ui_main_play_dev_card_selected = true;
        }
        if cstate.*.ui.button("Trade with the Bank") {
            cstate.*.ui_main_trade_with_bank_selected = true;
            cstate.*.ui_main_trade_with_bank_resource = std::optional[[resource]]::EMPTY;
        }
        if cstate.*.ui.button("Trade with Players") {
            cstate.*.ui_main_trade_with_players_selected = true;
            cstate.*.ui_main_trade_with_players_give = std::zeroed[[resources]]();
            cstate.*.ui_main_trade_with_players_recv = std::zeroed[[resources]]();
        }
        if cstate.*.ui.button("End Turn") {
            sender.*.sendc(client_message::init_end_turn());
        }

        cstate.*.ui.end_window();
    }

    # Trade Phase UI Window
    var ui_w = (:sint)screen_w / 4;
    var ui_h = (:sint)screen_h / 4;
    var ui_x = (:sint)screen_w * 2 / 3 - ui_w - 2 * UI_BORDER;
    var ui_y = (:sint)screen_h - ui_h - UI_BORDER;
    var show_ui = cstate.*.turn.phase == phase::TRADE;
    if show_ui {
        var ui_recv_x = ui_x;
        var ui_recv_y = ui_y - ui_h - UI_BORDER;

        var ui_give_x = ui_recv_x - ui_w - UI_BORDER;
        var ui_give_y = ui_recv_y;

        # Give Window
        if cstate.*.ui.begin_window_ex("Resources to Give", smol::rect::init(ui_give_x, ui_give_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
            # Re-set cached window rect in case the screen was resized.
            var win = cstate.*.ui.get_current_container();
            win.*.rect.w = ui_w;
            win.*.rect.h = ui_h;
            win.*.rect.x = ui_give_x;
            win.*.rect.y = ui_give_y;

            # Window Content
            cstate.*.ui.layout_row((:[]sint)[64, -1], 0);
            cstate.*.ui.label("Brick:");
            var s = std::string::init_from_format("{}", (:[]std::formatter)[std::formatter::init[[sint]](&cstate.*.trade.recv.brick)]);
            defer s.fini();
            cstate.*.ui.text(s.data());
            cstate.*.ui.label("Ore:");
            var s = std::string::init_from_format("{}", (:[]std::formatter)[std::formatter::init[[sint]](&cstate.*.trade.recv.ore)]);
            defer s.fini();
            cstate.*.ui.text(s.data());
            cstate.*.ui.label("Sheep:");
            var s = std::string::init_from_format("{}", (:[]std::formatter)[std::formatter::init[[sint]](&cstate.*.trade.recv.sheep)]);
            defer s.fini();
            cstate.*.ui.text(s.data());
            cstate.*.ui.label("Wheat:");
            var s = std::string::init_from_format("{}", (:[]std::formatter)[std::formatter::init[[sint]](&cstate.*.trade.recv.wheat)]);
            defer s.fini();
            cstate.*.ui.text(s.data());
            cstate.*.ui.label("Wood:");
            var s = std::string::init_from_format("{}", (:[]std::formatter)[std::formatter::init[[sint]](&cstate.*.trade.recv.wood)]);
            defer s.fini();
            cstate.*.ui.text(s.data());

            cstate.*.ui.end_window();
        }

        # Recv Window
        if cstate.*.ui.begin_window_ex("Resources to Receive", smol::rect::init(ui_recv_x, ui_recv_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
            # Re-set cached window rect in case the screen was resized.
            var win = cstate.*.ui.get_current_container();
            win.*.rect.w = ui_w;
            win.*.rect.h = ui_h;
            win.*.rect.x = ui_recv_x;
            win.*.rect.y = ui_recv_y;

            # Window Content
            cstate.*.ui.layout_row((:[]sint)[64, -1], 0);
            cstate.*.ui.label("Brick:");
            var s = std::string::init_from_format("{}", (:[]std::formatter)[std::formatter::init[[sint]](&cstate.*.trade.give.brick)]);
            defer s.fini();
            cstate.*.ui.text(s.data());
            cstate.*.ui.label("Ore:");
            var s = std::string::init_from_format("{}", (:[]std::formatter)[std::formatter::init[[sint]](&cstate.*.trade.give.ore)]);
            defer s.fini();
            cstate.*.ui.text(s.data());
            cstate.*.ui.label("Sheep:");
            var s = std::string::init_from_format("{}", (:[]std::formatter)[std::formatter::init[[sint]](&cstate.*.trade.give.sheep)]);
            defer s.fini();
            cstate.*.ui.text(s.data());
            cstate.*.ui.label("Wheat:");
            var s = std::string::init_from_format("{}", (:[]std::formatter)[std::formatter::init[[sint]](&cstate.*.trade.give.wheat)]);
            defer s.fini();
            cstate.*.ui.text(s.data());
            cstate.*.ui.label("Wood:");
            var s = std::string::init_from_format("{}", (:[]std::formatter)[std::formatter::init[[sint]](&cstate.*.trade.give.wood)]);
            defer s.fini();
            cstate.*.ui.text(s.data());

            cstate.*.ui.end_window();
        }

        # Menu Buttons Window
        if not *cstate.*.p_trade_submitted()
        and cstate.*.ui.begin_window_ex("Trade with Players", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
            # Re-set cached window rect in case the screen was resized.
            var win = cstate.*.ui.get_current_container();
            win.*.rect.w = ui_w;
            win.*.rect.h = ui_h;
            win.*.rect.x = ui_x;
            win.*.rect.y = ui_y;

            # Window Content
            cstate.*.ui.layout_row((:[]sint)[-1], 0);
            if cstate.*.ui.button("Accept") {
                sender.*.sendc(client_message::init_trade_accept(cstate.*.trade));
            }
            if cstate.*.ui.button("Decline") {
                sender.*.sendc(client_message::init_trade_reject(cstate.*.trade));
            }

            cstate.*.ui.end_window();
        }
    }

    mu_end(cstate.*.ui.context);

    # Board Actions
    if cstate.*.turn.phase == phase::ROBBER
    and cstate.*.turn.player == cstate.*.player
    and IsMouseButtonPressed(MOUSE_BUTTON_LEFT) {
        if cstate.*.world_tile.is_value() {
            var world_tile = cstate.*.world_tile.value();
            if not std::eq[[hex]](&world_tile.hex, &cstate.*.board.robber) {
                var cmessage = client_message::init_move_robber(world_tile.hex);
                sender.*.sendc(cmessage);
            }
        }
        return;
    }
    elif cstate.*.ui_main_build_town_selected
    and IsMouseButtonPressed(MOUSE_BUTTON_LEFT)
    and cstate.*.world_node.is_value() {
        var existing = cstate.*.board.towns.lookup(cstate.*.world_node.value());
        if existing.is_value() and existing.value().*.player == cstate.*.player {
            var cmessage = client_message::init_build_town(
                town::init(
                    cstate.*.player,
                    cstate.*.world_node.value(),
                    town::CITY));
            sender.*.sendc(cmessage);
            cstate.*.ui_main_build_town_selected = false;
            return;
        }

        var cmessage = client_message::init_build_town(
            town::init(
                cstate.*.player,
                cstate.*.world_node.value(),
                town::SETTLEMENT));
        sender.*.sendc(cmessage);
        cstate.*.ui_main_build_town_selected = false;
        return;
    }
    elif IsKeyPressed(KEY_SPACE)
    and cstate.*.turn.phase == phase::RESOURCE_PRODUCTION {
        var cmessage = client_message::init_roll();
        sender.*.sendc(cmessage);
        return;
    }
    elif IsKeyPressed(KEY_SPACE)
    and cstate.*.turn.phase == phase::MAIN {
        var cmessage = client_message::init_end_turn();
        sender.*.sendc(cmessage);
        return;
    }
    elif cstate.*.ui_main_build_road_selected and IsMouseButtonPressed(MOUSE_BUTTON_LEFT)
    and cstate.*.world_edge.is_value() {
        var tile_a = cstate.*.board.tiles.lookup(cstate.*.world_edge.value().hexes[0]);
        var tile_b = cstate.*.board.tiles.lookup(cstate.*.world_edge.value().hexes[1]);
        assert tile_a.is_value() and tile_b.is_value();
        var is_road_across_water =
            tile_a.value().*.kind == tile::OCEAN and
            tile_b.value().*.kind == tile::OCEAN;
        if not is_road_across_water {
            sender.*.sendc(client_message::init_build_road(
                road::init(
                    cstate.*.player,
                    cstate.*.world_edge.value())));
            cstate.*.ui_main_build_road_selected = false;
        }
        return;
    }
}

func client_render(cstate: *client_state) void {
    BeginDrawing();
    ClearBackground((:Color){.r = 0x66, .g = 0xBB, .b = 0xFF, .a = 0xFF});

    var screen_w = screen_w();
    var screen_h = screen_h();
    var camera = camera(HEX_RADIUS);

    BeginMode2D(camera);

    var iter = std::hash_map_iterator[[hex, tile]]::init(&cstate.*.board.tiles);
    for iter.advance() {
        var tile = iter.current().*.value;
        var point = pointy_hex_to_point(tile.*.hex, HEX_RADIUS);
        draw_pointy_hexagon(point, HEX_RADIUS, tile_color(*tile));
        var resource = tile.*.resource();
        if resource.is_value() {
            draw_number_token(point, tile.*.number, HEX_RADIUS, cstate.*.font);
        }
    }

    var world_hex_center = pointy_hex_to_point(cstate.*.world_hex, HEX_RADIUS);

    if cstate.*.debug {
        if cstate.*.world_node.is_value() {
            for i in countof(cstate.*.world_node.value().hexes) {
                var point = pointy_hex_to_point(cstate.*.world_node.value().hexes[i], HEX_RADIUS);
                draw_pointy_hexagon_outline(point, HEX_RADIUS, RED);
            }
        }
        elif cstate.*.world_edge.is_value() {
            for i in countof(cstate.*.world_edge.value().hexes) {
                var point = pointy_hex_to_point(cstate.*.world_edge.value().hexes[i], HEX_RADIUS);
                draw_pointy_hexagon_outline(point, HEX_RADIUS, ORANGE);
            }
        }
        elif cstate.*.world_tile.is_value() {
            draw_pointy_hexagon_outline(world_hex_center, HEX_RADIUS, YELLOW);
        }
    }

    var iter = std::hash_map_iterator[[hex, tile]]::init(&cstate.*.board.tiles);
    for iter.advance() {
        var tile = iter.current().*.value;
        if tile.*.kind == ::tile::OCEAN {
            continue;
        }
        var point = pointy_hex_to_point(tile.*.hex, HEX_RADIUS);
        draw_pointy_hexagon_border(point, HEX_RADIUS, BLACK);
    }

    # Re-draw the hexagon outline and boarder for the currently hovered-over
    # tile if the robber is being moved. This is done before towns and roads
    # are drawn so that the hovered-over tile appears highlighted.
    if cstate.*.turn.phase == phase::ROBBER
    and cstate.*.turn.player == cstate.*.player {
        var tile = cstate.*.board.tiles.lookup(cstate.*.world_hex);
        if tile.is_value() and tile.value().*.kind != ::tile::OCEAN {
            draw_pointy_hexagon_outline(world_hex_center, HEX_RADIUS, YELLOW);
            draw_pointy_hexagon_border(world_hex_center, HEX_RADIUS, BLACK);
        }
    }

    var iter = std::hash_set_iterator[[port]]::init(&cstate.*.board.ports);
    for iter.advance() {
        var port = iter.current();
        draw_port(*port, HEX_RADIUS, cstate.*.font);
    }

    var iter = std::hash_map_iterator[[edge, road]]::init(&cstate.*.board.roads);
    for iter.advance() {
        var road = iter.current().*.value;
        var points = edge_to_points(road.*.edge, HEX_RADIUS);
        draw_road(points[0], points[1], HEX_RADIUS, player_color(road.*.player));
    }

    var show_world_edge_road =
        cstate.*.turn.phase == phase::MAIN and
        cstate.*.ui_main_build_road_selected and
        cstate.*.world_edge.is_value() and
        not cstate.*.board.roads.contains(cstate.*.world_edge.value()) and
        not cstate.*.world_node.is_value();
    if show_world_edge_road {
        var tile_a = cstate.*.board.tiles.lookup(cstate.*.world_edge.value().hexes[0]);
        var tile_b = cstate.*.board.tiles.lookup(cstate.*.world_edge.value().hexes[1]);
        assert tile_a.is_value() and tile_b.is_value();
        var is_road_across_water =
            tile_a.value().*.kind == tile::OCEAN and
            tile_b.value().*.kind == tile::OCEAN;
        if not is_road_across_water {
            var points = edge_to_points(cstate.*.world_edge.value(), HEX_RADIUS);
            draw_road(points[0], points[1], HEX_RADIUS, YELLOW);
        }
    }

    var iter = std::hash_map_iterator[[node, town]]::init(&cstate.*.board.towns);
    for iter.advance() {
        var town = iter.current().*.value;
        switch town.*.kind {
        ::town::SETTLEMENT {
            draw_settlement(node_to_point(town.*.node, HEX_RADIUS), HEX_RADIUS, player_color(town.*.player));
        }
        ::town::CITY {
            draw_city(node_to_point(town.*.node, HEX_RADIUS), HEX_RADIUS, player_color(town.*.player));
        }
        }
    }

    var show_world_node_town =
        cstate.*.turn.phase == phase::MAIN and
        cstate.*.ui_main_build_town_selected and
        cstate.*.world_node.is_value();
    if show_world_node_town {
        var point = node_to_point(cstate.*.world_node.value(), HEX_RADIUS);
        draw_circle(point, 6.0, YELLOW);
        draw_circle_outline(point, 6.0, 1.0, BLACK);
    }

    var robber_outline = BLACK;
    if cstate.*.turn.phase == phase::ROBBER and cstate.*.turn.player == cstate.*.player {
        robber_outline = YELLOW;
    }
    draw_robber(pointy_hex_to_point(cstate.*.board.robber, HEX_RADIUS), HEX_RADIUS, robber_outline);

    if cstate.*.debug {
        if cstate.*.world_node.is_value() {
            var world_node = cstate.*.world_node.value();
            var world_node_point = node_to_point(world_node, HEX_RADIUS);
            draw_circle(world_node_point, 6.0, RED);
            draw_circle_outline(world_node_point, 6.0, 1.0, BLACK);
        }
        elif cstate.*.world_edge.is_value() {
            var world_edge = cstate.*.world_edge.value();
            var points = edge_to_points(world_edge, HEX_RADIUS);
            draw_circle(points[0], 6.0, ORANGE);
            draw_circle(points[1], 6.0, ORANGE);
            draw_circle_outline(points[0], 6.0, 1.0, BLACK);
            draw_circle_outline(points[1], 6.0, 1.0, BLACK);
        }
        else {
            draw_circle(world_hex_center, 6.0, YELLOW);
            draw_circle_outline(world_hex_center, 6.0, 1.0, BLACK);
        }
    }

    EndMode2D();

    var SQUARE_SIDE = f32::min(screen_w / 24.0, screen_h / 24.0);
    let SQUARE_OFFSET = 8.0f32;
    var square_xpos = SQUARE_OFFSET;
    var square_ypos = screen_h - SQUARE_SIDE - SQUARE_OFFSET;
    draw_d6(
        cstate.*.font,
        SQUARE_SIDE / 2.0,
        (:Vector2){
            .x = square_xpos + SQUARE_SIDE * 0.0 + SQUARE_OFFSET * 0.0,
            .y = square_ypos,
        },
        cstate.*.board.d6_a,
        YELLOW,
        RED);
    draw_d6(
        cstate.*.font,
        SQUARE_SIDE / 2.0,
        (:Vector2){
            .x = square_xpos + SQUARE_SIDE * 1.0 + SQUARE_OFFSET * 1.0,
            .y = square_ypos,
        },
        cstate.*.board.d6_b,
        RED,
        YELLOW);

    smol::render(cstate.*.ui.context);

    if cstate.*.debug {
        var fps = GetFPS();
        draw_text_format(cstate.*.font, cstate.*.font_size, BLACK,
            (:Vector2){.x = 2.0, .y = 0.0},
            "FPS {}",
            (:[]std::formatter)[
                std::formatter::init[[typeof(fps)]](&fps)]);

        draw_text_format(cstate.*.font, cstate.*.font_size, BLACK,
            (:Vector2){.x = 2.0, .y = 1.0 * cstate.*.font_size},
            "MOUSE: x={.0}, y={.0}",
            (:[]std::formatter)[
                std::formatter::init[[f32]](&cstate.*.mouse.x),
                std::formatter::init[[f32]](&cstate.*.mouse.y)]);

        draw_text_format(cstate.*.font, cstate.*.font_size, BLACK,
            (:Vector2){.x = 2.0, .y = 2.0 * cstate.*.font_size},
            "WORLD: x={.0}, y={.0}",
            (:[]std::formatter)[
                std::formatter::init[[f32]](&cstate.*.world.x),
                std::formatter::init[[f32]](&cstate.*.world.y)]);

        draw_text_format(cstate.*.font, cstate.*.font_size, BLACK,
            (:Vector2){.x = 2.0, .y = 3.0 * cstate.*.font_size},
            "WORLD->HEX: q={}, r={}, s={}",
            (:[]std::formatter)[
                std::formatter::init[[sint]](&cstate.*.world_hex.q),
                std::formatter::init[[sint]](&cstate.*.world_hex.r),
                std::formatter::init[[sint]](&cstate.*.world_hex.s)]);

        draw_text_format(cstate.*.font, cstate.*.font_size, BLACK,
            (:Vector2){.x = 2.0, .y = 4.0 * cstate.*.font_size},
            "WORLD->HEX->WORLD: x={.0}, y={.0}",
            (:[]std::formatter)[
                std::formatter::init[[f32]](&world_hex_center.x),
                std::formatter::init[[f32]](&world_hex_center.y)]);

        if cstate.*.world_node.is_value() {
            var world_node = cstate.*.world_node.value();
            draw_text_format(cstate.*.font, cstate.*.font_size, BLACK,
                (:Vector2){.x = 2.0, .y = 5.0 * cstate.*.font_size},
                "NODE: {}",
                (:[]std::formatter)[
                    std::formatter::init[[node]](&world_node)]);
        }
        elif cstate.*.world_edge.is_value() {
            var world_edge = cstate.*.world_edge.value();
            draw_text_format(cstate.*.font, cstate.*.font_size, BLACK,
                (:Vector2){.x = 2.0, .y = 5.0 * cstate.*.font_size},
                "EDGE: {}",
                (:[]std::formatter)[
                    std::formatter::init[[edge]](&world_edge)]);
        }
        elif cstate.*.world_tile.is_value() {
            var world_tile = cstate.*.world_tile.value();
            draw_text_format(cstate.*.font, cstate.*.font_size, BLACK,
                (:Vector2){.x = 2.0, .y = 5.0 * cstate.*.font_size},
                "TILE: {} {verbose}",
                (:[]std::formatter)[
                    std::formatter::init[[hex]](&world_tile.hex),
                    std::formatter::init[[tile]](&world_tile)]);
        }
        else {
            draw_text(cstate.*.font, cstate.*.font_size, BLACK,
                (:Vector2){.x = 2.0, .y = 5.0 * cstate.*.font_size},
                "NODE/EDGE/TILE: none");
        }

        draw_text_format(cstate.*.font, cstate.*.font_size, BLACK,
            (:Vector2){.x = 2.0, .y = 6.0 * cstate.*.font_size},
            "TURN: {}",
            (:[]std::formatter)[
                std::formatter::init[[sint]](&cstate.*.turn.number)]);

        var phase_text: []byte = uninit;
        switch cstate.*.turn.phase {
        phase::RESOURCE_PRODUCTION {
            phase_text = "resource production";
        }
        phase::DISCARD {
            phase_text = "discard";
        }
        phase::ROBBER {
            phase_text = "robber";
        }
        phase::STEAL {
            phase_text = "steal";
        }
        phase::MAIN {
            phase_text = "main";
        }
        phase::TRADE {
            phase_text = "trade";
        }
        }
        draw_text_format(cstate.*.font, cstate.*.font_size, BLACK,
            (:Vector2){.x = 2.0, .y = 7.0 * cstate.*.font_size},
            "PHASE: {}",
            (:[]std::formatter)[
                std::formatter::init[[[]byte]](&phase_text)]);
    }

    EndDrawing();
}
