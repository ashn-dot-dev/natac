import "c";
import "std";

import "raylib";
import "smolui";

import "shared.sunder";

# The radius of the outer circle touching the corners of the hexagon.
let HEX_RADIUS = 56.0f32;

# By default, raylib uses an EPSILON value of 0.000001f, which is more precise
# than we would like. Check float equivalence using our own custom EPSILON.
func vec2_feq(a: Vector2, b: Vector2) bool {
    let EPSILON = 0.0001f32;
    var x_feq = f32::abs(a.x - b.x) < EPSILON;
    var y_feq = f32::abs(a.y - b.y) < EPSILON;
    return x_feq and y_feq;
}

func vec2_distance(a: Vector2, b: Vector2) f32 {
    var x_dist = a.x - b.x;
    var y_dist = a.y - b.y;
    return f32::sqrt(x_dist * x_dist + y_dist * y_dist);
}

func tile_color(tile: tile) Color {
    var out: Color = uninit;
    switch tile.kind {
    ::tile::DESERT {
        out = (:Color){.r = 0xEE, .g = 0xCC, .b = 0x88, .a = 0xFF};
    }
    ::tile::OCEAN {
        out = (:Color){.r = 0x66, .g = 0xBB, .b = 0xFF, .a = 0xFF};
    }
    ::tile::FOREST {
        out = (:Color){.r = 0x11, .g = 0x55, .b = 0x11, .a = 0xFF};
    }
    ::tile::FIELD {
        out = (:Color){.r = 0xDD, .g = 0xAA, .b = 0x22, .a = 0xFF};
    }
    ::tile::HILL {
        out = (:Color){.r = 0xCC, .g = 0x55, .b = 0x44, .a = 0xFF};
    }
    ::tile::MOUNTAIN {
        out = (:Color){.r = 0x88, .g = 0x88, .b = 0x88, .a = 0xFF};
    }
    ::tile::PASTURE {
        out = (:Color){.r = 0x66, .g = 0xAA, .b = 0x66, .a = 0xFF};
    }
    }
    return out;
}

func player_color(player: player) Color {
    var out: Color = uninit;
    switch player {
    ::player::RED {
        out = RED;
    }
    ::player::BLUE {
        out = BLUE;
    }
    ::player::WHITE {
        out = WHITE;
    }
    ::player::ORANGE {
        out = ORANGE;
    }
    }
    return out;
}

func point_to_pointy_hex(point: Vector2, radius: f32) hex {
    var q = (f32::sqrt(3.0)/3.0 * point.x - 1.0/3.0 * point.y) / radius;
    var r = (2.0/3.0 * point.y) / radius;
    var s = -q - r;

    return hex::init_round(q, r, s);
}

func pointy_hex_to_point(hex: hex, radius: f32) Vector2 {
    var x = radius * (f32::sqrt(3.0) * (:f32)hex.q + f32::sqrt(3.0)/2.0 * (:f32)hex.r);
    var y = radius * (3.0/2.0 * (:f32)hex.r);
    return (:Vector2){.x = x, .y = y};
}

func pointy_hex_vertices(hex: hex, radius: f32) [6]Vector2 {
    var result: [6]Vector2 = uninit;
    var center = pointy_hex_to_point(hex, radius);
    for i in 6 {
        var x = center.x + f32::cos(f32::degrees_to_radians((:f32)i * 360.0 / 6.0 + 30.0)) * radius;
        var y = center.y + f32::sin(f32::degrees_to_radians((:f32)i * 360.0 / 6.0 + 30.0)) * radius;
        result[i] = (:Vector2){.x = x, .y = y};
    }
    return result;
}

func edge_to_points(edge: edge, radius: f32) [2]Vector2 {
    var ret: [2]Vector2 = uninit;
    var cur = 0u;

    var vertices_a = pointy_hex_vertices(edge.hexes[0], radius);
    var vertices_b = pointy_hex_vertices(edge.hexes[1], radius);
    for i in countof(vertices_a) {
        for j in countof(vertices_b) {
            if vec2_feq(vertices_a[i], vertices_b[j]) {
                ret[cur] = vertices_a[i];
                cur = cur + 1;
            }
        }
    }

    return ret;
}

func node_to_point(node: node, radius: f32) Vector2 {
    var ret: Vector2 = uninit;

    var vertices_a = pointy_hex_vertices(node.hexes[0], radius);
    var vertices_b = pointy_hex_vertices(node.hexes[1], radius);
    var vertices_c = pointy_hex_vertices(node.hexes[2], radius);
    for i in countof(vertices_a) {
        for j in countof(vertices_b) {
            for k in countof(vertices_c) {
                if vec2_feq(vertices_a[i], vertices_b[j]) and vec2_feq(vertices_b[j], vertices_c[k]) {
                    ret = vertices_a[i];
                    break;
                }
            }
        }
    }

    return ret;
}

func draw_pointy_hexagon(center: Vector2, radius: f32, color: Color) void {
    let SIDES: sint = 6;
    let ANGLE: f32 = 30.0; # pointy-top orientation
    DrawPoly(center, SIDES, radius, ANGLE, color);
}

func draw_pointy_hexagon_outline(center: Vector2, radius: f32, color: Color) void {
    let SIDES: sint = 6;
    let ANGLE: f32 = 30.0; # pointy-top orientation
    DrawPolyLinesEx(center, SIDES, radius, ANGLE, radius / 8.0, color);
}

func draw_pointy_hexagon_border(center: Vector2, radius: f32, color: Color) void {
    let SIDES: sint = 6;
    let ANGLE: f32 = 30.0; # pointy-top orientation
    var thick: f32 = radius / 16.0;
    DrawPolyLinesEx(center, SIDES, radius + thick / 2.0, ANGLE, thick, color);
}

func draw_circle(center: Vector2, radius: f32, color: Color) void {
    DrawCircleV(center, radius, color);
}

func draw_circle_outline(center: Vector2, radius: f32, thickness: f32, color: Color) void {
    assert thickness <= radius;
    let SIDES: sint = 36;
    let ANGLE: f32 = 0.0;
    DrawPolyLinesEx(center, SIDES, radius, ANGLE, thickness, color);
}

func draw_rect(position: Vector2, w: f32, h: f32, color: Color) void {
    DrawRectangleV(position, (:Vector2){.x = w, .y = h}, color);
}

func draw_rect_outline(position: Vector2, w: f32, h: f32, thickness: f32, color: Color) void {
    assert thickness <= w;
    assert thickness <= h;
    # left side
    DrawRectangleV(
        (:Vector2){
            .x = position.x,
            .y = position.y,
        },
        (:Vector2){
            .x = thickness,
            .y = h,
        },
        color);
    # right side
    DrawRectangleV(
        (:Vector2){
            .x = position.x + w - thickness,
            .y = position.y,
        },
        (:Vector2){
            .x = thickness,
            .y = h,
        },
        color);
    # top side
    DrawRectangleV(
        (:Vector2){
            .x = position.x,
            .y = position.y,
        },
        (:Vector2){
            .x = w,
            .y = thickness,
        },
        color);
    # bottom side
    DrawRectangleV(
        (:Vector2){
            .x = position.x,
            .y = position.y + h - thickness,
        },
        (:Vector2){
            .x = w,
            .y = thickness,
        },
        color);
}

func draw_number_token(center: Vector2, number: sint, radius: f32, font: Font, font_size: f32) void {
    var CIRCLE_RADIUS = radius / 2.0;
    let TAN = (:Color){.r = 0xDD, .g = 0xBB, .b = 0x88, .a = 0xFF};
    draw_circle(center, CIRCLE_RADIUS, TAN);
    # Need a little bit extra radius so that all pixels of the
    # outline will cover up the number token circle.
    var CIRCLE_OUTLINE_RADIUS = CIRCLE_RADIUS + 1.0;
    var CIRCLE_OUTLINE_THICKNESS = CIRCLE_RADIUS / 8.0;
    draw_circle_outline(center, CIRCLE_OUTLINE_RADIUS, CIRCLE_OUTLINE_THICKNESS, BLACK);

    var size = measure_text_format(font, font_size,
        "{}",
        (:[]std::formatter)[
            std::formatter::init[[sint]](&number)]);
    var color = BLACK;
    if number == 6 or number == 8 {
        color = RED;
    }
    draw_text_format(font, font_size, color,
        (:Vector2){
            .x = center.x - size.x / 2.0,
            .y = center.y - size.y / 2.0 - CIRCLE_RADIUS / 16.0,
        },
        "{}",
        (:[]std::formatter)[
            std::formatter::init[[sint]](&number)]);

    assert 2 <= number and number <= 12;
    let DOTS = (:[]usize)[
        0, # 0 (invalid)
        0, # 1 (invalid)
        1, # 2
        2, # 3
        3, # 4
        4, # 5
        5, # 6
        0, # 7 (invalid)
        5, # 8
        4, # 9
        3, # 10
        2, # 11
        1, # 12
    ];
    var distance = CIRCLE_RADIUS / 3.6;
    var width = (:f32)DOTS[(:usize)number] * distance;
    for i in DOTS[(:usize)number] {
        var position = (:Vector2){
            .x = center.x - width / 2.0 + distance * ((:f32)i + 0.5),
            .y = center.y + CIRCLE_RADIUS / 2.0,
        };
        draw_circle(position, distance / 4.0, color);
    }
}

func draw_port(port: port, radius: f32, font: Font, font_size: f32) void {
    var center = pointy_hex_to_point(port.hex, radius);

    var a = node_to_point(port.nodes[0], radius);
    var b = node_to_point(port.nodes[1], radius);
    var thick: f32 = radius / 8.0;
    DrawLineEx(Vector2Lerp(center, a, 0.49), Vector2Lerp(center, a, 0.91), thick + 1.0, BLACK);
    DrawLineEx(Vector2Lerp(center, a, 0.50), Vector2Lerp(center, a, 0.90), thick, BROWN);
    DrawLineEx(Vector2Lerp(center, b, 0.49), Vector2Lerp(center, b, 0.91), thick + 1.0, BLACK);
    DrawLineEx(Vector2Lerp(center, b, 0.50), Vector2Lerp(center, b, 0.90), thick, BROWN);

    var text = "<error>";
    switch port.kind {
    ::port::ANY {
        text = "3:1";
    }
    ::port::BRICK {
        text = "brick 2:1";
    }
    ::port::ORE {
        text = "ore 2:1";
    }
    ::port::SHEEP {
        text = "sheep 2:1";
    }
    ::port::WHEAT {
        text = "wheat 2:1";
    }
    ::port::WOOD {
        text = "wood 2:1";
    }
    }
    var size = measure_text_cstr(font, font_size, startof(text));
    var position = (:Vector2){.x = center.x - size.x / 2.0, .y = center.y - size.y / 2.0};
    draw_text_cstr(font, font_size, BLACK, position, startof(text));
}

func draw_road(a: Vector2, b: Vector2, radius: f32, color: Color) void {
    var thick: f32 = radius / 8.0;
    DrawLineEx(Vector2Lerp(a, b, 0.09), Vector2Lerp(a, b, 0.91), thick + 1.0, BLACK);
    DrawLineEx(Vector2Lerp(a, b, 0.10), Vector2Lerp(a, b, 0.90), thick, color);
}

func draw_settlement(center: Vector2, radius: f32, color: Color) void {
    var center = (:Vector2){
        .x = center.x,
        .y = center.y - radius / 8.0f32, # y-offset
    };
    var size = (:Vector2){
        .x = radius / 3.0,
        .y = radius / 4.0,
    };

    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0 - 1.0, .y = center.y},
        (:Vector2){.x = size.x + 2.0, .y = size.y + 1.0},
        BLACK);
    DrawTriangle(
        (:Vector2){.x = center.x - size.x / 2.0 - 1.2, .y = center.y},
        (:Vector2){.x = center.x + size.x / 2.0 + 1.2, .y = center.y},
        (:Vector2){.x = center.x, .y = center.y - size.y / 2.0 - 1.25},
        BLACK);

    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0, .y = center.y},
        (:Vector2){.x = size.x, .y = size.y},
        color);
    DrawTriangle(
        (:Vector2){.x = center.x - size.x / 2.0, .y = center.y},
        (:Vector2){.x = center.x + size.x / 2.0, .y = center.y},
        (:Vector2){.x = center.x, .y = center.y - size.y / 2.0},
        color);
}

func draw_city(center: Vector2, radius: f32, color: Color) void {
    var center = (:Vector2){
        .x = center.x,
        .y = center.y - radius / 8.0f32, # y-offset
    };
    var size = (:Vector2){
        .x = radius / 2.2,
        .y = radius / 4.0,
    };

    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0 - 1.0, .y = center.y - 1.0},
        (:Vector2){.x = size.x + 2.0, .y = size.y + 2.0},
        BLACK);
    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0 - 1.0, .y = center.y - size.y / 2.0},
        (:Vector2){.x = size.x / 2.0 + 2.0, .y = size.y / 2.0 + 1.0},
        BLACK);
    DrawTriangle(
        (:Vector2){.x = center.x - size.x / 2.0 - 1.0, .y = center.y - size.y / 2.0},
        (:Vector2){.x = center.x + 1.0, .y = center.y - size.y / 2.0},
        (:Vector2){.x = center.x - size.x / 4.0, .y = center.y - size.y - 1.0},
        BLACK);

    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0, .y = center.y},
        (:Vector2){.x = size.x, .y = size.y},
        color);
    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0, .y = center.y - size.y / 2.0},
        (:Vector2){.x = size.x / 2.0, .y = size.y / 2.0},
        color);
    DrawTriangle(
        (:Vector2){.x = center.x - size.x / 2.0, .y = center.y - size.y / 2.0},
        (:Vector2){.x = center.x, .y = center.y - size.y / 2.0},
        (:Vector2){.x = center.x - size.x / 4.0, .y = center.y - size.y},
        color);
}

func draw_robber(center: Vector2, radius: f32, outline: Color) void {
    var radius_h = radius / 6.0;
    var radius_v = radius / 3.0;
    var size = (:Vector2){
        .x = radius_h * 2.0,
        .y = radius_v / 2.0,
    };

    DrawEllipse(
        (:sint)center.x,
        (:sint)center.y,
        radius_h + 1.0,
        radius_v + 1.0,
        outline);
    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0 - 1.0, .y = center.y + radius_v - size.y / 2.0 - 1.0},
        (:Vector2){.x = size.x + 2.0, .y = size.y + 2.0},
        outline);
    DrawCircleV(
        (:Vector2){.x = center.x, .y = center.y - radius_v},
        radius_h * 0.9 + 1.0,
        outline);

    let COLOR = GRAY;
    DrawEllipse(
        (:sint)center.x,
        (:sint)center.y,
        radius_h,
        radius_v,
        COLOR);
    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0, .y = center.y + radius_v - size.y / 2.0},
        (:Vector2){.x = size.x, .y = size.y},
        COLOR);
    DrawCircleV(
        (:Vector2){.x = center.x, .y = center.y - radius_v},
        radius_h * 0.9,
        COLOR);
}

func measure_text(font: Font, size: f32, text: []byte) Vector2 {
    var s = std::string::init_from_str(text);
    defer s.fini();

    let SPACING = 0.0f32;
    return MeasureTextEx(font, s.cstr(), size, SPACING);
}

func draw_text(font: Font, size: f32, color: Color, position: Vector2, text: []byte) void {
    var s = std::string::init_from_str(text);
    defer s.fini();

    let SPACING = 0.0f32;
    DrawTextEx(font, s.cstr(), position, size, SPACING, color);
}

func measure_text_cstr(font: Font, size: f32, text: *byte) Vector2 {
    let SPACING = 0.0f32;
    return MeasureTextEx(font, text, size, SPACING);
}

func draw_text_cstr(font: Font, size: f32, color: Color, position: Vector2, text: *byte) void {
    let SPACING = 0.0f32;
    DrawTextEx(font, text, position, size, SPACING, color);
}

func measure_text_format(font: Font, size: f32, format: []byte, args: []std::formatter) Vector2 {
    var s = std::string::init_from_format(format, args);
    defer s.fini();

    let SPACING = 0.0f32;
    return MeasureTextEx(font, s.cstr(), size, SPACING);
}

func draw_text_format(font: Font, size: f32, color: Color, position: Vector2, format: []byte, args: []std::formatter) void {
    var s = std::string::init_from_format(format, args);
    defer s.fini();

    let SPACING = 0.0f32;
    DrawTextEx(font, s.cstr(), position, size, SPACING, color);
}

func draw_d6(font: Font, font_size: f32, position: Vector2, side: f32, number: sint, fg: Color, bg: Color) void {
    assert 1 <= number and number <= 6;
    let BOARDER = 2.0f32;
    draw_rect(position, side, side, bg);
    draw_rect_outline(position, side, side, BOARDER, BLACK);
    var text_size = measure_text_format(font, font_size,
        "{}",
        (:[]std::formatter)[
            std::formatter::init[[sint]](&number)]);
    draw_text_format(
        font,
        font_size,
        fg,
        (:Vector2){
            .x = position.x + side / 2.0 - text_size.x / 2.0,
            .y = position.y + side / 2.0 - text_size.y / 2.0,
        },
        "{}",
        (:[]std::formatter)[std::formatter::init[[sint]](&number)]);
}

func screen_w() f32 {
    return (:f32)GetScreenWidth();
}

func screen_h() f32 {
    return (:f32)GetScreenHeight();
}

func camera() Camera2D {
    return (:Camera2D){
        .target = (:Vector2){
            .x = 0.0f32,
            .y = 0.0f32,
        },
        .offset = (:Vector2){
            .x = screen_w() / 2.0 - screen_w() / 5.0,
            .y = screen_h() / 2.0 - screen_h() / 8.0,
        },
        .rotation = 0.0f32,
        .zoom = 1.0f32,
    };
}

struct ui_dynamic_state {
    var kind: enum {
        ROOT;
        BUILD_ROAD;
        BUILD_TOWN;
        PLAY_DEV_CARD;
        PLAY_DEV_CARD_YEAR_OF_PLENTY;
        PLAY_DEV_CARD_MONOPOLY;
        TRADE_WITH_BANK;
        TRADE_WITH_PLAYERS;
    };
    var data: union {
        var trade_with_bank_resource: std::optional[[resource]]; # x:1 resource->...
        var trade_with_players: struct {
            var give: resources;
            var recv: resources;
        };
    };

    let SELF: ui_dynamic_state = uninit;

    func init(kind: typeof(SELF.kind)) ui_dynamic_state {
        return (:ui_dynamic_state){
            .kind = kind,
            .data = uninit,
        };
    }
}

struct client_state {
    var debug: bool;
    var connected: bool;

    var wav_ding: Wave;
    var sound_ding: Sound;
    var wav_dice: Wave;
    var sound_dice: Sound;
    var wav_impact: Wave;
    var sound_impact: Sound;
    var wav_winner: Wave;
    var sound_winner: Sound;
    var board_font: Font;
    var board_font_size: f32;
    var ui_font: *Font;
    var ui_font_size: f32;
    var ui_log: std::string;
    var ui_log_updated: bool;
    var ui_textbox_buf: [256]char;
    var ui_dynamic_state: ui_dynamic_state;
    var ui_resources_select: resources;
    var ui_trade_submitted: bool;
    var ui: smol::ui;

    var player: std::optional[[player]];
    var pinfo: hidden_player_info;
    var board: board;
    var r: public_player_info;
    var b: public_player_info;
    var w: public_player_info;
    var o: public_player_info;
    var dev_cards_remaining: sint;
    var longest_road: std::optional[[player]];
    var largest_army: std::optional[[player]];
    var turn_order: [4]player;
    var turn: turn;
    var trade: trade;

    var mouse: Vector2;
    var world: Vector2;
    var world_hex: hex;
    var world_tile: std::optional[[tile]];
    var world_edge: std::optional[[edge]];
    var world_node: std::optional[[node]];

    func init() client_state {
        let WAV = embed("assets/BellDing1.wav");
        var wav_ding = LoadWaveFromMemory(
            startof(".wav"),
            (:*u8)startof(WAV),
            (:sint)countof(WAV));
        var sound_ding = LoadSoundFromWave(wav_ding);

        let WAV = embed("assets/Dice25.wav");
        var wav_dice = LoadWaveFromMemory(
            startof(".wav"),
            (:*u8)startof(WAV),
            (:sint)countof(WAV));
        var sound_dice = LoadSoundFromWave(wav_dice);

        let WAV = embed("assets/WoodPlasticHitImpact.wav");
        var wav_impact = LoadWaveFromMemory(
            startof(".wav"),
            (:*u8)startof(WAV),
            (:sint)countof(WAV));
        var sound_impact = LoadSoundFromWave(wav_impact);

        let WAV = embed("assets/SuccessFanfareTrumpets.wav");
        var wav_winner = LoadWaveFromMemory(
            startof(".wav"),
            (:*u8)startof(WAV),
            (:sint)countof(WAV));
        var sound_winner = LoadSoundFromWave(wav_winner);

        # Raylib internally renders fonts to a texture, which may look
        # pixilated when scaled up to a higher resolution. For this font, we
        # internally load it at a very large font size, and use bilinear
        # filtering on the resulting texture, which together will make the font
        # legible for a wider range of font sizes.
        let FONT_NUMCHARS: sint = '~' - ' ' + 1; # Printable ASCII
        let BOARD_FONT_DATA = embed("assets/MinSans-Bold.otf");
        var board_font_size = 128.0f32;
        var board_font = LoadFontFromMemory(
            startof(".ttf"),
            (:*u8)startof(BOARD_FONT_DATA),
            (:sint)countof(BOARD_FONT_DATA),
            (:sint)board_font_size,
            std::ptr[[sint]]::NULL,
            FONT_NUMCHARS);
        SetTextureFilter(board_font.texture, TEXTURE_FILTER_BILINEAR);

        let UI_FONT_DATA = embed("assets/RuneScapeUF.ttf");
        var ui_font_size = 16.0f32;
        var ui_font = std::new[[Font]]();
        *ui_font = LoadFontFromMemory(
            startof(".ttf"),
            (:*u8)startof(UI_FONT_DATA),
            (:sint)countof(UI_FONT_DATA),
            (:sint)ui_font_size,
            std::ptr[[sint]]::NULL,
            FONT_NUMCHARS);

        var ctx = std::new[[mu_Context]]();
        mu_init(ctx);
        smol::setup_font(ctx, ui_font);
        var ui = smol::ui::init(ctx);
        var ui_log = std::string::init();
        var log_writer = std::writer::init[[std::string]](&ui_log);
        std::print_line(log_writer, "Welcome to Natac!");
        var ui_log_updated = true;

        var board = board::init();

        return (:client_state){
            .debug = false,
            .connected = false,

            .wav_ding = wav_ding,
            .sound_ding = sound_ding,
            .wav_dice = wav_dice,
            .sound_dice = sound_dice,
            .wav_impact = wav_impact,
            .sound_impact = sound_impact,
            .wav_winner = wav_winner,
            .sound_winner = sound_winner,
            .board_font = board_font,
            .board_font_size = board_font_size,
            .ui_font = ui_font,
            .ui_font_size = ui_font_size,
            .ui_log = ui_log,
            .ui_log_updated = ui_log_updated,
            .ui_textbox_buf = uninit,
            .ui_dynamic_state = uninit,
            .ui_resources_select = uninit,
            .ui_trade_submitted = false,
            .ui = ui,

            .player = std::optional[[player]]::EMPTY,
            .pinfo = uninit,
            .board = board,
            .r = uninit,
            .b = uninit,
            .w = uninit,
            .o = uninit,
            .dev_cards_remaining = uninit,
            .longest_road = std::optional[[player]]::EMPTY,
            .largest_army = std::optional[[player]]::EMPTY,
            .turn_order = (:[4]player)[
                player::RED,
                player::BLUE,
                player::WHITE,
                player::ORANGE,
            ],
            .turn = uninit,
            .trade = uninit,

            .mouse = uninit,
            .world = uninit,
            .world_hex = uninit,
            .world_tile = uninit,
            .world_edge = uninit,
            .world_node = uninit,
        };
    }

    func fini(self: *client_state) void {
        std::delete[[mu_Context]](self.*.ui.context);
        self.*.ui_log.fini();
        UnloadFont(*self.*.ui_font);
        std::delete[[Font]](self.*.ui_font);
        UnloadFont(self.*.board_font);
        UnloadSound(self.*.sound_winner);
        UnloadWave(self.*.wav_winner);
        UnloadSound(self.*.sound_ding);
        UnloadWave(self.*.wav_ding);
        UnloadSound(self.*.sound_impact);
        UnloadWave(self.*.wav_impact);
        UnloadSound(self.*.sound_dice);
        UnloadWave(self.*.wav_dice);
        self.*.board.fini();
    }

    func p_info(self: *client_state, player: player) *public_player_info {
        var out: *public_player_info = uninit;
        switch player {
        ::player::RED {
            out = &self.*.r;
        }
        ::player::BLUE {
            out = &self.*.b;
        }
        ::player::WHITE {
            out = &self.*.w;
        }
        ::player::ORANGE {
            out = &self.*.o;
        }
        }
        return out;
    }

    func p_discarded(self: *client_state, player: player) *bool {
        var out: *bool = uninit;
        switch player {
        ::player::RED {
            out = &self.*.r.discarded;
        }
        ::player::BLUE {
            out = &self.*.b.discarded;
        }
        ::player::WHITE {
            out = &self.*.w.discarded;
        }
        ::player::ORANGE {
            out = &self.*.o.discarded;
        }
        }
        return out;
    }

    func p_trade_submitted(self: *client_state, player: player) *bool {
        var out: *bool = uninit;
        switch player {
        ::player::RED {
            out = &self.*.r.trade_submitted;
        }
        ::player::BLUE {
            out = &self.*.b.trade_submitted;
        }
        ::player::WHITE {
            out = &self.*.w.trade_submitted;
        }
        ::player::ORANGE {
            out = &self.*.o.trade_submitted;
        }
        }
        return out;
    }

    func update_from_server_message(self: *client_state, message: *server_message) void {
        switch message.*.kind {
        server_message::LOG {
            var log_writer = std::writer::init[[std::string]](&self.*.ui_log);
            std::print_line(log_writer, message.*.data.log.data());
            self.*.ui_log_updated = true;
        }
        server_message::INFO {
            self.*.pinfo = message.*.data.info;
        }
        server_message::STATE {
            var is_new_turn = self.*.turn.number < message.*.data.state.turn.number;
            if is_new_turn {
                # Reset the UI dynamic state every turn so that all menus and
                # menu data appear uniform at the start of every new turn.
                self.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::ROOT);
            }

            # We purposefully check that the player of the turn has changed
            # rather than the turn number changing in combination with it being
            # the current players turn so that one player games are not
            # constantly dinging during testing.
            var is_your_turn =
                self.*.player.is_value() and
                self.*.player.value() != self.*.turn.player and
                self.*.player.value() == message.*.data.state.turn.player;
            if is_your_turn {
                PlaySound(self.*.sound_ding);
            }

            var is_dice_rolled =
                self.*.turn.phase == phase::RESOURCE_PRODUCTION and
                (message.*.data.state.turn.phase == phase::DISCARD or
                    message.*.data.state.turn.phase == phase::ROBBER or
                    message.*.data.state.turn.phase == phase::MAIN);
            if is_dice_rolled {
                PlaySound(self.*.sound_dice);
            }

            var old_road_count = self.*.board.roads.count();
            var new_road_count = message.*.data.state.board.roads.count();
            var old_settlement_count = 0u;
            var old_city_count = 0u;
            var iter = self.*.board.towns.iterator();
            for iter.advance() {
                old_settlement_count += (:usize)(iter.current().*.value.*.kind == town::SETTLEMENT);
                old_city_count += (:usize)(iter.current().*.value.*.kind == town::CITY);
            }
            var new_settlement_count = 0u;
            var new_city_count = 0u;
            var iter = message.*.data.state.board.towns.iterator();
            for iter.advance() {
                new_settlement_count += (:usize)(iter.current().*.value.*.kind == town::SETTLEMENT);
                new_city_count += (:usize)(iter.current().*.value.*.kind == town::CITY);
            }
            # Since the robber will populate to tile (+0, +0, +0) on the
            # intital state message from the server, skip playing a sound for
            # the robber being "moved" when the previous board was empty.
            var is_robber_moved =
                self.*.board.tiles.count() != 0 and
                std::ne[[hex]](&self.*.board.robber, &message.*.data.state.board.robber);
            if new_road_count > old_road_count or new_settlement_count > old_settlement_count or new_city_count > old_city_count or is_robber_moved {
                PlaySound(self.*.sound_impact);
            }

            var is_game_ended = self.*.turn.phase != phase::GAME_FINI and message.*.data.state.turn.phase == phase::GAME_FINI;
            if is_game_ended {
                PlaySound(self.*.sound_winner);
            }

            board::assign(&self.*.board, &message.*.data.state.board);
            self.*.turn_order = message.*.data.state.turn_order;
            self.*.turn = message.*.data.state.turn;
            self.*.trade = message.*.data.state.trade;
            self.*.r = message.*.data.state.r;
            self.*.b = message.*.data.state.b;
            self.*.w = message.*.data.state.w;
            self.*.o = message.*.data.state.o;
            self.*.dev_cards_remaining =message.*.data.state.dev_cards_remaining;
            self.*.longest_road = message.*.data.state.longest_road;
            self.*.largest_army = message.*.data.state.largest_army;
        }
        server_message::PLAYER {
            self.*.player = std::optional[[player]]::init_value(message.*.data.player);
        }
        server_message::REJECTED {
            var log_writer = std::writer::init[[std::string]](&self.*.ui_log);
            std::print_format_line(
                log_writer,
                "[ACTION REJECTED]: {}",
                (:[]std::formatter)[
                    std::formatter::init[[std::string]](&message.*.data.rejected)]);
            self.*.ui_log_updated = true;
        }
        }
    }
}

func ui_reset_cached_container_size(container: *smol::container, x: sint, y: sint, w: sint, h: sint) void {
    container.*.rect.x = x;
    container.*.rect.y = y;
    container.*.rect.w = w;
    container.*.rect.h = h;
}

func ui_labled_number(ui: *smol::ui, label: []byte, value: sint, layout: []sint) void {
    assert countof(layout) == 2;
    ui.*.push_id(startof(label), countof(label));
    ui.*.layout_begin_column();

    ui.*.layout_row(layout, 0);
    ui.*.text(label);

    var s = std::string::init_from_format("{}", (:[]std::formatter)[std::formatter::init[[sint]](&value)]);
    defer s.fini();
    ui.*.text(s.data());

    ui.*.layout_end_column();
    ui.*.pop_id();
}

# In HTML this input element is has type "number", but elsewhere it is referred
# to as a spinner for some reason. I'm calling it a "UI Number Select" for now.
#
# https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/number
# https://jqueryui.com/spinner/
# https://www.mathworks.com/help/matlab/ref/uispinner.html
func ui_number_select(ui: *smol::ui, value: *sint, min: sint, max: sint) void {
    ui.*.push_id(&value, sizeof(typeof(value)));
    ui.*.layout_begin_column();

    var button_w: sint = 32;
    ui.*.layout_row((:[]sint)[button_w, button_w, -1], 0);

    if ui.*.button("-1") {
        *value -= 1;
    }
    if ui.*.button("+1") {
        *value += 1;
    }
    *value = sint::max(min, *value);
    *value = sint::min(max, *value);

    ui.*.begin_panel_ex("PANEL", smol::OPT_NOSCROLL); # XXX: Duplicate IDs?
    var s = std::string::init_from_format("{}", (:[]std::formatter)[std::formatter::init[[sint]](value)]);
    defer s.fini();
    ui.*.text(s.data());
    ui.*.end_panel();

    ui.*.layout_end_column();
    ui.*.pop_id();
}

let UI_BORDER: sint = 8;

func ui_window_play_dev_card(cstate: *client_state, sender: *message_sender[[client_message]]) void {
    var screen_w = screen_w();
    var screen_h = screen_h();

    var ui_w = (:sint)screen_w / 4;
    var ui_h = (:sint)screen_h / 4;
    var ui_x = (:sint)screen_w * 2 / 3 - ui_w - 2 * UI_BORDER;
    var ui_y = (:sint)screen_h - ui_h - UI_BORDER;

    if cstate.*.ui.begin_window_ex("Play a Development Card", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_x, ui_y, ui_w, ui_h);

        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        if cstate.*.ui.button("Play Knight") {
            sender.*.sendc(client_message::init_use_dev_card_knight());
            cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::ROOT);
        }
        if cstate.*.ui.button("Play Road Building") {
            sender.*.sendc(client_message::init_use_dev_card_road_building());
            cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::ROOT);
        }
        if cstate.*.ui.button("Play Year of Plenty") {
            cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::PLAY_DEV_CARD_YEAR_OF_PLENTY);
        }
        if cstate.*.ui.button("Play Monopoly") {
            cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::PLAY_DEV_CARD_MONOPOLY);
        }
        if cstate.*.ui.button("Back") {
            cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::ROOT);
        }

        cstate.*.ui.end_window();
    }
}

func ui_window_resource_production(cstate: *client_state, sender: *message_sender[[client_message]]) void {
    var screen_w = screen_w();
    var screen_h = screen_h();

    var ui_w = (:sint)screen_w / 4;
    var ui_h = (:sint)screen_h / 4;
    var ui_x = (:sint)screen_w * 2 / 3 - ui_w - 2 * UI_BORDER;
    var ui_y = (:sint)screen_h - ui_h - UI_BORDER;

    if cstate.*.ui.begin_window_ex("Your Turn (resource production)", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_x, ui_y, ui_w, ui_h);

        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        if cstate.*.ui.button("Roll") {
            sender.*.sendc(client_message::init_roll());
        }
        if cstate.*.ui.button("Play a Development Card") {
            cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::PLAY_DEV_CARD);
        }

        cstate.*.ui.end_window();
    }
}

func ui_window_play_dev_card_year_of_plenty(cstate: *client_state, sender: *message_sender[[client_message]]) void {
    var screen_w = screen_w();
    var screen_h = screen_h();

    var ui_w = (:sint)screen_w / 4;
    var ui_h = (:sint)screen_h / 4;
    var ui_x = (:sint)screen_w * 2 / 3 - ui_w - 2 * UI_BORDER;
    var ui_y = (:sint)screen_h - ui_h - UI_BORDER;

    if cstate.*.ui.begin_window_ex("Select Resources (Year of Plenty)", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_x, ui_y, ui_w, ui_h);

        cstate.*.ui.layout_row((:[]sint)[64, -1], 0);
        cstate.*.ui.label("Brick:");
        var max = 2 - cstate.*.ui_resources_select.count() + cstate.*.ui_resources_select.brick;
        ui_number_select(&cstate.*.ui, &cstate.*.ui_resources_select.brick, 0, max);
        cstate.*.ui.label("Ore:");
        var max = 2 - cstate.*.ui_resources_select.count() + cstate.*.ui_resources_select.ore;
        ui_number_select(&cstate.*.ui, &cstate.*.ui_resources_select.ore, 0, max);
        cstate.*.ui.label("Sheep:");
        var max = 2 - cstate.*.ui_resources_select.count() + cstate.*.ui_resources_select.sheep;
        ui_number_select(&cstate.*.ui, &cstate.*.ui_resources_select.sheep, 0, max);
        cstate.*.ui.label("Wheat:");
        var max = 2 - cstate.*.ui_resources_select.count() + cstate.*.ui_resources_select.wheat;
        ui_number_select(&cstate.*.ui, &cstate.*.ui_resources_select.wheat, 0, max);
        cstate.*.ui.label("Wood:");
        var max = 2 - cstate.*.ui_resources_select.count() + cstate.*.ui_resources_select.wood;
        ui_number_select(&cstate.*.ui, &cstate.*.ui_resources_select.wood, 0, max);
        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        if cstate.*.ui.button("Submit") {
            sender.*.sendc(client_message::init_use_dev_card_year_of_plenty(cstate.*.ui_resources_select));
            cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::ROOT);
            cstate.*.ui_resources_select = std::zeroed[[resources]]();
        }
        if cstate.*.ui.button("Back") {
            cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::PLAY_DEV_CARD);
            cstate.*.ui_resources_select = std::zeroed[[resources]]();
        }

        cstate.*.ui.end_window();
    }
}

func ui_window_play_dev_card_monopoly(cstate: *client_state, sender: *message_sender[[client_message]]) void {
    var screen_w = screen_w();
    var screen_h = screen_h();

    var ui_w = (:sint)screen_w / 4;
    var ui_h = (:sint)screen_h / 4;
    var ui_x = (:sint)screen_w * 2 / 3 - ui_w - 2 * UI_BORDER;
    var ui_y = (:sint)screen_h - ui_h - UI_BORDER;

    if cstate.*.ui.begin_window_ex("Select Resource (Monopoly)", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_x, ui_y, ui_w, ui_h);

        cstate.*.ui.layout_row((:[]sint)[64, -1], 0);
        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        if cstate.*.ui.button("Brick") {
            sender.*.sendc(client_message::init_use_dev_card_monopoly(resource::BRICK));
            cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::ROOT);
        }
        if cstate.*.ui.button("Ore") {
            sender.*.sendc(client_message::init_use_dev_card_monopoly(resource::ORE));
            cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::ROOT);
        }
        if cstate.*.ui.button("Sheep") {
            sender.*.sendc(client_message::init_use_dev_card_monopoly(resource::SHEEP));
            cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::ROOT);
        }
        if cstate.*.ui.button("Wheat") {
            sender.*.sendc(client_message::init_use_dev_card_monopoly(resource::WHEAT));
            cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::ROOT);
        }
        if cstate.*.ui.button("Wood") {
            sender.*.sendc(client_message::init_use_dev_card_monopoly(resource::WOOD));
            cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::ROOT);
        }
        if cstate.*.ui.button("Back") {
            cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::PLAY_DEV_CARD);
        }

        cstate.*.ui.end_window();
    }
}

func ui_window_main_root(cstate: *client_state, sender: *message_sender[[client_message]]) void {
    var screen_w = screen_w();
    var screen_h = screen_h();

    var ui_w = (:sint)screen_w / 4;
    var ui_h = (:sint)screen_h / 4;
    var ui_x = (:sint)screen_w * 2 / 3 - ui_w - 2 * UI_BORDER;
    var ui_y = (:sint)screen_h - ui_h - UI_BORDER;

    if cstate.*.ui.begin_window_ex("Your Turn", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_x, ui_y, ui_w, ui_h);

        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        if cstate.*.ui.button("Build a Road") {
            cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::BUILD_ROAD);
        }
        if cstate.*.ui.button("Build a Settlement/City") {
            cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::BUILD_TOWN);
        }
        if cstate.*.ui.button("Buy a Development Card") {
            sender.*.sendc(client_message::init_buy_dev_card());
        }
        if cstate.*.ui.button("Play a Development Card") {
            cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::PLAY_DEV_CARD);
        }
        if cstate.*.ui.button("Trade with the Bank") {
            cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::TRADE_WITH_BANK);
        }
        if cstate.*.ui.button("Trade with Players") {
            cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::TRADE_WITH_PLAYERS);
        }
        if cstate.*.ui.button("End Turn") {
            sender.*.sendc(client_message::init_end_turn());
        }

        cstate.*.ui.end_window();
    }

    var ui_x = ui_x - ui_w - UI_BORDER;
    if cstate.*.ui.begin_window_ex("Building Costs", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_x, ui_y, ui_w, ui_h);

        cstate.*.ui.layout_row((:[]sint)[-1], 0);

        var remaining = 15s;
        var iter = cstate.*.board.roads.iterator();
        for iter.advance() {
            var road = iter.current().*.value.*;
            remaining -= (:ssize)(road.player == cstate.*.player.value());
        }
        var s = std::string::init_from_format(
            "Road ({} remaining):\n    1 brick, 1 wood",
            (:[]std::formatter)[
                std::formatter::init[[ssize]](&remaining)]);
        defer s.fini();
        cstate.*.ui.text(s.data());

        var remaining = 5s;
        var iter = cstate.*.board.towns.iterator();
        for iter.advance() {
            var town = iter.current().*.value.*;
            remaining -= (:ssize)(town.player == cstate.*.player.value() and town.kind == ::town::SETTLEMENT);
        }
        var s = std::string::init_from_format(
            "Settlement ({} remaining):\n    1 brick, 1 sheep, 1 wheat, 1 wood",
            (:[]std::formatter)[
                std::formatter::init[[ssize]](&remaining)]);
        defer s.fini();
        cstate.*.ui.text(s.data());

        var remaining = 4s;
        var iter = cstate.*.board.towns.iterator();
        for iter.advance() {
            var town = iter.current().*.value.*;
            remaining -= (:ssize)(town.player == cstate.*.player.value() and town.kind == ::town::CITY);
        }
        var s = std::string::init_from_format(
            "City ({} remaining):\n    3 ore, 1 wheat",
            (:[]std::formatter)[
                std::formatter::init[[ssize]](&remaining)]);
        defer s.fini();
        cstate.*.ui.text(s.data());

        var remaining = (:ssize)cstate.*.dev_cards_remaining;
        var s = std::string::init_from_format(
            "Development Card ({} remaining):\n    1 ore, 1 sheep, 1 wheat",
            (:[]std::formatter)[
                std::formatter::init[[ssize]](&remaining)]);
        defer s.fini();
        cstate.*.ui.text(s.data());

        cstate.*.ui.end_window();
    }
}

func ui_window_main_build_road(cstate: *client_state) void {
    var screen_w = screen_w();
    var screen_h = screen_h();

    var ui_w = (:sint)screen_w / 4;
    var ui_h = (:sint)screen_h / 4;
    var ui_x = (:sint)screen_w * 2 / 3 - ui_w - 2 * UI_BORDER;
    var ui_y = (:sint)screen_h - ui_h - UI_BORDER;

    if cstate.*.ui.begin_window_ex("Build a Road", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_x, ui_y, ui_w, ui_h);

        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        if cstate.*.ui.button("Back") {
            cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::ROOT);
        }

        cstate.*.ui.end_window();
    }
}

func ui_window_main_build_town(cstate: *client_state) void {
    var screen_w = screen_w();
    var screen_h = screen_h();

    var ui_w = (:sint)screen_w / 4;
    var ui_h = (:sint)screen_h / 4;
    var ui_x = (:sint)screen_w * 2 / 3 - ui_w - 2 * UI_BORDER;
    var ui_y = (:sint)screen_h - ui_h - UI_BORDER;

    if cstate.*.ui.begin_window_ex("Build a Settlement/City", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_x, ui_y, ui_w, ui_h);

        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        if cstate.*.ui.button("Back") {
            cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::ROOT);
        }

        cstate.*.ui.end_window();
    }
}

func ui_window_main_trade_with_bank(cstate: *client_state, sender: *message_sender[[client_message]]) void {
    var screen_w = screen_w();
    var screen_h = screen_h();

    var ui_w = (:sint)screen_w / 4;
    var ui_h = (:sint)screen_h / 4;
    var ui_x = (:sint)screen_w * 2 / 3 - ui_w - 2 * UI_BORDER;
    var ui_y = (:sint)screen_h - ui_h - UI_BORDER;

    if cstate.*.ui.begin_window_ex("Trade with Bank", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_x, ui_y, ui_w, ui_h);

        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        if cstate.*.ui_dynamic_state.data.trade_with_bank_resource.is_value() {
            for i in countof(RESOURCES) {
                var name = RESOURCES[i].data();
                var s = std::string::init_from_format(
                    ".. for {}",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(name)]](&name)]);
                defer s.fini();
                var id = mu_get_id(cstate.*.ui.context, s.start(), (:sint)s.count());
                var r = mu_layout_next(cstate.*.ui.context);
                if mu_button_raw(cstate.*.ui.context, s.start(), (:sint)s.count(), 0, id, r, MU_OPT_ALIGNCENTER) != 0 {
                    var n_to_1 = n_to_1(&cstate.*.board, cstate.*.player.value(), cstate.*.ui_dynamic_state.data.trade_with_bank_resource.value());
                    var cmessage = client_message::init_trade_n_for_1(cstate.*.ui_dynamic_state.data.trade_with_bank_resource.value(), RESOURCES[i], n_to_1);
                    sender.*.sendc(cmessage);
                    cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::ROOT);
                }
            }
            if cstate.*.ui.button("Back") {
                cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::TRADE_WITH_BANK);
            }
        }
        else {
            for i in countof(RESOURCES) {
                var name = RESOURCES[i].data();
                var n_to_1 = n_to_1(&cstate.*.board, cstate.*.player.value(), RESOURCES[i]);
                var s = std::string::init_from_format(
                    "{}:1 {}...",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(n_to_1)]](&n_to_1),
                        std::formatter::init[[typeof(name)]](&name)]);
                defer s.fini();
                var id = mu_get_id(cstate.*.ui.context, s.start(), (:sint)s.count());
                var r = mu_layout_next(cstate.*.ui.context);
                if mu_button_raw(cstate.*.ui.context, s.start(), (:sint)s.count(), 0, id, r, MU_OPT_ALIGNCENTER) != 0 {
                    cstate.*.ui_dynamic_state.data.trade_with_bank_resource = std::optional[[resource]]::init_value(RESOURCES[i]);
                }
            }
            if cstate.*.ui.button("Back") {
                cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::ROOT);
            }
        }

        cstate.*.ui.end_window();
    }
}

func ui_window_main_trade_with_players(cstate: *client_state, sender: *message_sender[[client_message]]) void {
    var screen_w = screen_w();
    var screen_h = screen_h();

    var ui_w = (:sint)screen_w / 4;
    var ui_h = (:sint)screen_h / 4;
    var ui_x = (:sint)screen_w * 2 / 3 - ui_w - 2 * UI_BORDER;
    var ui_y = (:sint)screen_h - ui_h - UI_BORDER;

    if cstate.*.ui_dynamic_state.kind == ui_dynamic_state::TRADE_WITH_PLAYERS {
        var ui_recv_x = ui_x;
        var ui_recv_y = ui_y - ui_h - UI_BORDER;

        var ui_give_x = ui_recv_x - ui_w - UI_BORDER;
        var ui_give_y = ui_recv_y;

        # Give Window
        if cstate.*.ui.begin_window_ex("Resources to Give", smol::rect::init(ui_give_x, ui_give_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
            ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_give_x, ui_give_y, ui_w, ui_h);

            cstate.*.ui.layout_row((:[]sint)[64, -1], 0);
            cstate.*.ui.label("Brick:");
            ui_number_select(&cstate.*.ui, &cstate.*.ui_dynamic_state.data.trade_with_players.give.brick, 0, cstate.*.pinfo.brick);
            cstate.*.ui.label("Ore:");
            ui_number_select(&cstate.*.ui, &cstate.*.ui_dynamic_state.data.trade_with_players.give.ore, 0,  cstate.*.pinfo.ore);
            cstate.*.ui.label("Sheep:");
            ui_number_select(&cstate.*.ui, &cstate.*.ui_dynamic_state.data.trade_with_players.give.sheep, 0, cstate.*.pinfo.sheep);
            cstate.*.ui.label("Wheat:");
            ui_number_select(&cstate.*.ui, &cstate.*.ui_dynamic_state.data.trade_with_players.give.wheat, 0, cstate.*.pinfo.wheat);
            cstate.*.ui.label("Wood:");
            ui_number_select(&cstate.*.ui, &cstate.*.ui_dynamic_state.data.trade_with_players.give.wood, 0, cstate.*.pinfo.wood);

            cstate.*.ui.end_window();
        }

        # Recv Window
        if cstate.*.ui.begin_window_ex("Resources to Receive", smol::rect::init(ui_recv_x, ui_recv_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
            ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_recv_x, ui_recv_y, ui_w, ui_h);

            cstate.*.ui.layout_row((:[]sint)[-1], 0);
            cstate.*.ui.layout_row((:[]sint)[64, -1], 0);
            cstate.*.ui.label("Brick:");
            ui_number_select(&cstate.*.ui, &cstate.*.ui_dynamic_state.data.trade_with_players.recv.brick, 0, sint::MAX);
            cstate.*.ui.label("Ore:");
            ui_number_select(&cstate.*.ui, &cstate.*.ui_dynamic_state.data.trade_with_players.recv.ore, 0,  sint::MAX);
            cstate.*.ui.label("Sheep:");
            ui_number_select(&cstate.*.ui, &cstate.*.ui_dynamic_state.data.trade_with_players.recv.sheep, 0, sint::MAX);
            cstate.*.ui.label("Wheat:");
            ui_number_select(&cstate.*.ui, &cstate.*.ui_dynamic_state.data.trade_with_players.recv.wheat, 0, sint::MAX);
            cstate.*.ui.label("Wood:");
            ui_number_select(&cstate.*.ui, &cstate.*.ui_dynamic_state.data.trade_with_players.recv.wood, 0, sint::MAX);

            cstate.*.ui.end_window();
        }

        # Menu Buttons Window
        if cstate.*.ui.begin_window_ex("Trade with Players", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
            ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_x, ui_y, ui_w, ui_h);

            cstate.*.ui.layout_row((:[]sint)[-1], 0);
            if cstate.*.ui.button("Propose Trade") {
                var cmessage = client_message::init_trade_players(
                    cstate.*.ui_dynamic_state.data.trade_with_players.give,
                    cstate.*.ui_dynamic_state.data.trade_with_players.recv);
                sender.*.sendc(cmessage);
                cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::ROOT);
            }
            if cstate.*.ui.button("Back") {
                cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::ROOT);
            }

            cstate.*.ui.end_window();
        }
    }
}

var address_buf = (:[128]byte)[0...];
func client_pre_connect_update(cstate: *client_state, address: *std::optional[[*byte]]) void {
    var screen_w = screen_w();
    var screen_h = screen_h();

    smol::handle_input(cstate.*.ui.context);
    mu_begin(cstate.*.ui.context);

    var ui_w = (:sint)screen_w / 4;
    var ui_h = (:sint)screen_h / 4;
    var ui_x = (:sint)screen_w / 2 - ui_w / 2;
    var ui_y = (:sint)screen_h / 2 - ui_h / 2;
    if cstate.*.ui.begin_window_ex("Enter Server Address", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NODRAG | smol::OPT_NOCLOSE) {
        ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_x, ui_y, ui_w, ui_h);

        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        cstate.*.ui.text("Enter the IP address (IPv4) of the Natac server (e.g. 192.0.2.0).");
        cstate.*.ui.text("");
        var submitted = false;
        if (cstate.*.ui.textbox_buffer(address_buf[0:countof(address_buf)]) & smol::RES_SUBMIT) != 0 {
            cstate.*.ui.set_focus(cstate.*.ui.context.*.last_id);
            submitted = true;
        }
        if cstate.*.ui.button("Connect") {
            submitted = true;
        }
        if submitted {
            *address = std::optional[[*byte]]::init_value(&address_buf[0]);
            cstate.*.ui_textbox_buf[0] = '\0';
        }

        cstate.*.ui.end_window();
    }

    mu_end(cstate.*.ui.context);
}

func client_pre_connect_render(cstate: *client_state) void {
    var screen_w = screen_w();
    var screen_h = screen_h();

    BeginDrawing();
    ClearBackground((:Color){.r = 0x66, .g = 0xBB, .b = 0xFF, .a = 0xFF});
    let text = startof("NATAC!");
    var font_size = cstate.*.board_font_size;
    var text_w = measure_text_cstr(cstate.*.board_font, font_size, text).x;
    var text_h = measure_text_cstr(cstate.*.board_font, font_size, text).y;
    var text_x = screen_w / 2.0 - text_w / 2.0;
    var text_y = screen_h / 3.0 - text_h;
    draw_text_cstr(
        cstate.*.board_font,
        font_size,
        (:Color){.r = 0xA1, .g = 0x21, .b = 0x21, .a = 0xFF},
        (:Vector2){.x = text_x, .y = text_y},
        text);
    smol::render(cstate.*.ui.context);
    EndDrawing();
}

func client_update(cstate: *client_state, sender: *message_sender[[client_message]]) void {
    if not cstate.*.connected {
        return;
    }

    # Collect basic information about the state of the window/camera, position
    # of the mouse in screen space & world space, and objects that the mouse is
    # currently hovering over.
    var camera = camera();

    var mouse = GetMousePosition();
    var world = GetScreenToWorld2D(mouse, camera);
    var world_hex = point_to_pointy_hex(world, HEX_RADIUS);

    var world_tile = std::optional[[tile]]::EMPTY;
    var iter = cstate.*.board.tiles.iterator();
    for iter.advance() {
        if std::eq[[hex]](iter.current().*.key, &world_hex) {
            world_tile = std::optional[[tile]]::init_value(*iter.current().*.value);
            break;
        }
    }

    var world_edge = std::optional[[edge]]::EMPTY;
    var iter = cstate.*.board.edges.iterator();
    for iter.advance() {
        var found = true;
        for i in countof(iter.current().*.hexes) {
            let DISTANCE = HEX_RADIUS * 1.15;
            var hex = iter.current().*.hexes[i];
            if vec2_distance(world, pointy_hex_to_point(hex, HEX_RADIUS)) > DISTANCE {
                found = false;
                break;
            }
        }

        if found {
            world_edge = std::optional[[edge]]::init_value(*iter.current());
            break;
        }
    }

    var world_node = std::optional[[node]]::EMPTY;
    var iter = cstate.*.board.nodes.iterator();
    for iter.advance() {
        var found = true;
        for i in countof(iter.current().*.hexes) {
            let DISTANCE = HEX_RADIUS * 1.15;
            var hex = iter.current().*.hexes[i];
            if vec2_distance(world, pointy_hex_to_point(hex, HEX_RADIUS)) > DISTANCE {
                found = false;
                break;
            }
        }

        if found {
            world_node = std::optional[[node]]::init_value(*iter.current());
            break;
        }
    }

    cstate.*.mouse = mouse;
    cstate.*.world = world;
    cstate.*.world_hex = world_hex;
    cstate.*.world_tile = world_tile;
    cstate.*.world_edge = world_edge;
    cstate.*.world_node = world_node;

    # Actions processed regardless of the client's current player state.
    if IsKeyPressed(KEY_F3) {
        cstate.*.debug = not cstate.*.debug;
    }
    if cstate.*.debug and IsKeyPressed(KEY_ONE) {
        sender.*.sendc(client_message::init_select_player(cstate.*.turn_order[0]));
    }
    if cstate.*.debug and IsKeyPressed(KEY_TWO) {
        sender.*.sendc(client_message::init_select_player(cstate.*.turn_order[1]));
    }
    if cstate.*.debug and IsKeyPressed(KEY_THREE) {
        sender.*.sendc(client_message::init_select_player(cstate.*.turn_order[2]));
    }
    if cstate.*.debug and IsKeyPressed(KEY_FOUR) {
        sender.*.sendc(client_message::init_select_player(cstate.*.turn_order[3]));
    }

    # Begin UI
    var screen_w = screen_w();
    var screen_h = screen_h();
    smol::handle_input(cstate.*.ui.context);
    mu_begin(cstate.*.ui.context);

    # Select Player/Color UI Window
    var ui_w = (:sint)screen_w / 4;
    var ui_h = (:sint)screen_h / 4;
    var ui_x = (:sint)screen_w * 2 / 3 - ui_w - 2 * UI_BORDER;
    var ui_y = (:sint)screen_h - ui_h - UI_BORDER;
    var is_open_seat =
        ((cstate.*.turn.phase == phase::GAME_INIT and not cstate.*.p_info(player::RED).*.live) or not cstate.*.p_info(player::RED).*.connected) or
        ((cstate.*.turn.phase == phase::GAME_INIT and not cstate.*.p_info(player::BLUE).*.live) or not cstate.*.p_info(player::BLUE).*.connected) or
        ((cstate.*.turn.phase == phase::GAME_INIT and not cstate.*.p_info(player::WHITE).*.live) or not cstate.*.p_info(player::WHITE).*.connected) or
        ((cstate.*.turn.phase == phase::GAME_INIT and not cstate.*.p_info(player::ORANGE).*.live) or not cstate.*.p_info(player::ORANGE).*.connected);
    var show_ui = cstate.*.player.is_empty() and is_open_seat;
    if show_ui and cstate.*.ui.begin_window_ex("Select Color", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_x, ui_y, ui_w, ui_h);

        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        if cstate.*.ui.button("Red") {
            sender.*.sendc(client_message::init_select_player(player::RED));
        }
        if cstate.*.ui.button("Blue") {
            sender.*.sendc(client_message::init_select_player(player::BLUE));
        }
        if cstate.*.ui.button("White") {
            sender.*.sendc(client_message::init_select_player(player::WHITE));
        }
        if cstate.*.ui.button("Orange") {
            sender.*.sendc(client_message::init_select_player(player::ORANGE));
        }

        cstate.*.ui.end_window();
    }

    # Begin Game UI Window
    var ui_w = (:sint)screen_w / 4;
    var ui_h = (:sint)screen_h / 4;
    var ui_x = (:sint)screen_w * 2 / 3 - ui_w - 2 * UI_BORDER;
    var ui_y = (:sint)screen_h - ui_h - UI_BORDER;
    var show_ui = cstate.*.turn.phase == phase::GAME_INIT and cstate.*.player.is_value();
    if show_ui and cstate.*.ui.begin_window_ex("Start-of-Game Lobby", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_x, ui_y, ui_w, ui_h);

        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        cstate.*.ui.text("Click the \"Begin the Game\" button below once all players have joined.");
        cstate.*.ui.text("");
        if cstate.*.ui.button("Begin the Game") {
            sender.*.sendc(client_message::init_begin_game());
        }

        cstate.*.ui.end_window();
    }

    # Initial Settlement / Road UI Windows
    var ui_w = (:sint)screen_w / 4;
    var ui_h = (:sint)screen_h / 4;
    var ui_x = (:sint)screen_w * 2 / 3 - ui_w - 2 * UI_BORDER;
    var ui_y = (:sint)screen_h - ui_h - UI_BORDER;
    var show_ui = cstate.*.turn.phase == phase::GAME_INIT_BUILD_TOWN and
        cstate.*.player.is_value() and
        cstate.*.player.value() == cstate.*.turn.player;
    if show_ui and cstate.*.ui.begin_window_ex("Initial Setup", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_x, ui_y, ui_w, ui_h);

        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        cstate.*.ui.text("Place a settlement.");

        cstate.*.ui.end_window();
    }
    var show_ui = cstate.*.turn.phase == phase::GAME_INIT_BUILD_ROAD and
        cstate.*.player.is_value() and
        cstate.*.player.value() == cstate.*.turn.player;
    if show_ui and cstate.*.ui.begin_window_ex("Initial Setup", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_x, ui_y, ui_w, ui_h);

        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        cstate.*.ui.text("Place a road next to your settlement.");

        cstate.*.ui.end_window();
    }

    # Player Info UI Windows
    var ui_player_w = (:sint)screen_w * 1 / 3;
    var ui_player_x = (:sint)screen_w - ui_player_w - UI_BORDER;
    var ui_player_y = UI_BORDER;
    for i in countof(cstate.*.turn_order) {
        var player = cstate.*.turn_order[i];
        if not cstate.*.p_info(player).*.live {
            continue;
        }

        var ui_player_h = ((:sint)screen_h * 1 / 2 - 2 * UI_BORDER) / (:sint)countof(cstate.*.turn_order);
        if cstate.*.player.is_value() and cstate.*.player.value() == player {
            # Five extra rows pluse some wiggle room.
            ui_player_h += (5 + 3) * (:sint)cstate.*.ui_font_size;
        }
        defer { ui_player_y += ui_player_h + UI_BORDER; }

        var pcolor = player_color(player);
        cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLEBG].r = pcolor.r;
        cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLEBG].g = pcolor.g;
        cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLEBG].b = pcolor.b;
        cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLEBG].a = 0xFF;
        if player == ::player::WHITE {
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].r = BLACK.r;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].g = BLACK.g;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].b = BLACK.b;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].a = 0xFF;
        }
        else {
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].r = WHITE.r;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].g = WHITE.g;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].b = WHITE.b;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].a = 0xFF;
        }
        if cstate.*.turn.player == player {
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].r = YELLOW.r;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].g = YELLOW.g;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].b = YELLOW.b;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].a = 0xFF;
        }
        else {
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].r = BLACK.r;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].g = BLACK.g;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].b = BLACK.b;
            cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].a = 0xFF;
        }

        var ui_w = ui_player_w;
        var ui_h = ui_player_h;
        var ui_x = ui_player_x;
        var ui_y = ui_player_y;
        if cstate.*.ui.begin_window_ex(player_to_name(player), smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NODRAG | smol::OPT_NOCLOSE) {
            ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_x, ui_y, ui_w, ui_h);

            var victory_points: sint = uninit;
            var resources: sint = uninit;
            var dev_cards: sint = uninit;
            var knights_played: sint = uninit;
            switch player {
            ::player::RED {
                victory_points = cstate.*.r.victory_points;
                resources = cstate.*.r.resources;
                dev_cards = cstate.*.r.dev_cards;
                knights_played = cstate.*.r.knights_played;
            }
            ::player::BLUE {
                victory_points = cstate.*.b.victory_points;
                resources = cstate.*.b.resources;
                dev_cards = cstate.*.b.dev_cards;
                knights_played = cstate.*.b.knights_played;
            }
            ::player::WHITE {
                victory_points = cstate.*.w.victory_points;
                resources = cstate.*.w.resources;
                dev_cards = cstate.*.w.dev_cards;
                knights_played = cstate.*.w.knights_played;
            }
            ::player::ORANGE {
                victory_points = cstate.*.o.victory_points;
                resources = cstate.*.o.resources;
                dev_cards = cstate.*.o.dev_cards;
                knights_played = cstate.*.o.knights_played;
            }
            }

            if cstate.*.player.is_value() and cstate.*.player.value() == player {
                victory_points = cstate.*.pinfo.victory_points;
            }

            var text_w = (:sint)((:f32)ui_w / 2.0 * (2.0 / 3.0));
            cstate.*.ui.layout_row((:[]sint)[text_w, -1], 1);
            cstate.*.ui.text("Victory Points:");
            var s = std::string::init_from_format(
                "{}",
                (:[]std::formatter)[
                    std::formatter::init[[sint]](&victory_points)]);
            if cstate.*.longest_road.is_value() and cstate.*.longest_road.value() == player and cstate.*.largest_army.is_value() and cstate.*.largest_army.value() == player {
                var w = std::writer::init[[std::string]](&s);
                std::print(w, " (LR, LA)");
            }
            elif cstate.*.longest_road.is_value() and cstate.*.longest_road.value() == player {
                var w = std::writer::init[[std::string]](&s);
                std::print(w, " (Longest Road)");
            }
            elif cstate.*.largest_army.is_value() and cstate.*.largest_army.value() == player {
                var w = std::writer::init[[std::string]](&s);
                std::print(w, " (Largest Army)");
            }
            defer s.fini();
            cstate.*.ui.text(s.data());

            cstate.*.ui.layout_row((:[]sint)[text_w, -1], 1);
            cstate.*.ui.text("Resources:");
            var s = std::string::init_from_format(
                "{}",
                (:[]std::formatter)[
                    std::formatter::init[[sint]](&resources)]);
            defer s.fini();
            cstate.*.ui.text(s.data());

            cstate.*.ui.layout_row((:[]sint)[text_w, -1], 1);
            cstate.*.ui.text("Dev Cards:");
            var s = std::string::init_from_format(
                "{}",
                (:[]std::formatter)[
                    std::formatter::init[[sint]](&dev_cards)]);
            defer s.fini();
            if knights_played != 0 {
                var w = std::writer::init[[typeof(s)]](&s);
                var plural = "";
                if knights_played > 1 {
                    plural = "s";
                }
                std::print_format(
                    w,
                    " ({} knight{} played)",
                    (:[]std::formatter)[
                        std::formatter::init[[sint]](&knights_played),
                        std::formatter::init[[[]byte]](&plural)]);
            }
            cstate.*.ui.text(s.data());

            if cstate.*.player.is_value() and cstate.*.player.value() == player {
                var knight_count: usize = 0;
                var road_building_count: usize = 0;
                var year_of_plenty_count: usize = 0;
                var monopoly_count: usize = 0;
                var victory_point_count: usize = 0;
                for i in cstate.*.pinfo.dev_card_count {
                    if cstate.*.pinfo.dev_card_array[i].used {
                        continue;
                    }
                    switch cstate.*.pinfo.dev_card_array[i].kind {
                    dev_card::KNIGHT {
                        knight_count += 1;
                    }
                    dev_card::ROAD_BUILDING {
                        road_building_count += 1;
                    }
                    dev_card::YEAR_OF_PLENTY {
                        year_of_plenty_count += 1;
                    }
                    dev_card::MONOPOLY {
                        monopoly_count += 1;
                    }
                    dev_card::VICTORY_POINT {
                        victory_point_count += 1;
                    }
                    }
                }

                cstate.*.ui.text(""); # spacer

                cstate.*.ui.layout_row((:[]sint)[(3 * ui_w) / 5 - 16, (2 * ui_w) / 5 - 16], 1);
                var RESOURCE_LAYOUT = (:[]sint)[text_w, -1];
                var DEV_CARD_LAYOUT = (:[]sint)[text_w, -1];

                ui_labled_number(&cstate.*.ui, "Brick:", cstate.*.pinfo.brick, RESOURCE_LAYOUT);
                ui_labled_number(&cstate.*.ui, "Knight:", (:sint)knight_count, DEV_CARD_LAYOUT);

                ui_labled_number(&cstate.*.ui, "Ore:", cstate.*.pinfo.ore, RESOURCE_LAYOUT);
                ui_labled_number(&cstate.*.ui, "Road Building:", (:sint)road_building_count, DEV_CARD_LAYOUT);

                ui_labled_number(&cstate.*.ui, "Sheep:", cstate.*.pinfo.sheep, RESOURCE_LAYOUT);
                ui_labled_number(&cstate.*.ui, "Year of Plenty:", (:sint)year_of_plenty_count, DEV_CARD_LAYOUT);

                ui_labled_number(&cstate.*.ui, "Wheat:", cstate.*.pinfo.wheat, RESOURCE_LAYOUT);
                ui_labled_number(&cstate.*.ui, "Monopoly:", (:sint)monopoly_count, DEV_CARD_LAYOUT);

                ui_labled_number(&cstate.*.ui, "Wood:", cstate.*.pinfo.wood, RESOURCE_LAYOUT);
                ui_labled_number(&cstate.*.ui, "Victory Point:", (:sint)victory_point_count, DEV_CARD_LAYOUT);
            }

            cstate.*.ui.end_window();
        }
    }

    # Log UI Window
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].r = BLACK.r;
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].g = BLACK.g;
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].b = BLACK.b;
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_BORDER].a = 0xFF;
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLEBG].r = BLACK.r;
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLEBG].g = BLACK.g;
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLEBG].b = BLACK.b;
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLEBG].a = 0xFF;
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].r = WHITE.r;
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].g = WHITE.g;
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].b = WHITE.b;
    cstate.*.ui.context.*.style.*.colors[(:usize)MU_COLOR_TITLETEXT].a = 0xFF;
    var ui_w = (:sint)screen_w * 1 / 3;
    var ui_x = (:sint)screen_w - ui_w - UI_BORDER;
    var ui_y = ui_player_y;
    var ui_h = (:sint)screen_h - ui_y - UI_BORDER;
    if cstate.*.ui.begin_window_ex("LOG", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NODRAG | smol::OPT_NOCLOSE) {
        ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_x, ui_y, ui_w, ui_h);

        cstate.*.ui.layout_row((:[]sint)[-1], -25);
        cstate.*.ui.begin_panel("Log Output");
        var panel = cstate.*.ui.get_current_container();
        cstate.*.ui.layout_row((:[]sint)[-1], -1);
        cstate.*.ui.text(std::ascii::view_trimmed(cstate.*.ui_log.data()));
        cstate.*.ui.end_panel();

        # Re-set scroll if the log was updated.
        if cstate.*.ui_log_updated {
            panel.*.scroll.y = panel.*.content_size.y;
            cstate.*.ui_log_updated = false;
        }

        var submitted = false;
        cstate.*.ui.layout_row((:[]sint)[-70, -1], 0);
        if (cstate.*.ui.textbox_buffer(cstate.*.ui_textbox_buf[0:countof(cstate.*.ui_textbox_buf)]) & smol::RES_SUBMIT) != 0 {
            cstate.*.ui.set_focus(cstate.*.ui.context.*.last_id);
            submitted = true;
        }
        if cstate.*.ui.button("Send") {
            submitted = true;
        }
        if submitted {
            sender.*.sendc(client_message::init_chat(std::cstr::data(&cstate.*.ui_textbox_buf[0])));
            cstate.*.ui_textbox_buf[0] = '\0';
        }

        cstate.*.ui.end_window();
    }

    # Resource Production Roll UI Window
    var show_ui = cstate.*.turn.phase == phase::RESOURCE_PRODUCTION and
        cstate.*.player.is_value() and
        cstate.*.player.value() == cstate.*.turn.player;
    if show_ui {
        switch cstate.*.ui_dynamic_state.kind {
        ui_dynamic_state::ROOT {
            ui_window_resource_production(cstate, sender);
        }
        ui_dynamic_state::PLAY_DEV_CARD {
            ui_window_play_dev_card(cstate, sender);
        }
        ui_dynamic_state::PLAY_DEV_CARD_YEAR_OF_PLENTY {
            ui_window_play_dev_card_year_of_plenty(cstate, sender);
        }
        ui_dynamic_state::PLAY_DEV_CARD_MONOPOLY {
            ui_window_play_dev_card_monopoly(cstate, sender);
        }
        else {
            # nothing
        }
        }
    }

    # Discard Resources UI Window
    var ui_w = (:sint)screen_w / 4;
    var ui_h = (:sint)screen_h / 4;
    var ui_x = (:sint)screen_w * 2 / 3 - ui_w - 2 * UI_BORDER;
    var ui_y = (:sint)screen_h - ui_h - UI_BORDER;
    var show_ui = cstate.*.turn.phase == phase::DISCARD and
        cstate.*.player.is_value() and
        not *cstate.*.p_discarded(cstate.*.player.value());
    if show_ui and cstate.*.ui.begin_window_ex("Select Resources", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_x, ui_y, ui_w, ui_h);

        cstate.*.ui.layout_row((:[]sint)[64, -1], 0);
        cstate.*.ui.label("Brick:");
        ui_number_select(&cstate.*.ui, &cstate.*.ui_resources_select.brick, 0, cstate.*.pinfo.brick);
        cstate.*.ui.label("Ore:");
        ui_number_select(&cstate.*.ui, &cstate.*.ui_resources_select.ore, 0, cstate.*.pinfo.ore);
        cstate.*.ui.label("Sheep:");
        ui_number_select(&cstate.*.ui, &cstate.*.ui_resources_select.sheep, 0, cstate.*.pinfo.sheep);
        cstate.*.ui.label("Wheat:");
        ui_number_select(&cstate.*.ui, &cstate.*.ui_resources_select.wheat, 0, cstate.*.pinfo.wheat);
        cstate.*.ui.label("Wood:");
        ui_number_select(&cstate.*.ui, &cstate.*.ui_resources_select.wood, 0, cstate.*.pinfo.wood);
        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        var total = cstate.*.ui_resources_select.count();
        var outof = (cstate.*.pinfo.brick + cstate.*.pinfo.ore + cstate.*.pinfo.sheep + cstate.*.pinfo.wheat + cstate.*.pinfo.wood) / 2;
        var s = std::string::init_from_format(
            "Selected {} out of {} resources",
            (:[]std::formatter)[
                std::formatter::init[[sint]](&total),
                std::formatter::init[[sint]](&outof)]);
        defer s.fini();
        cstate.*.ui.text(s.data());
        if cstate.*.ui.button("Submit") {
            sender.*.sendc(client_message::init_submit_resources(cstate.*.ui_resources_select));
            cstate.*.ui_resources_select = std::zeroed[[resources]]();
        }

        cstate.*.ui.end_window();
    }

    # Steal From Player UI Window
    var ui_w = (:sint)screen_w / 4;
    var ui_h = (:sint)screen_h / 4;
    var ui_x = (:sint)screen_w * 2 / 3 - ui_w - 2 * UI_BORDER;
    var ui_y = (:sint)screen_h - ui_h - UI_BORDER;
    var show_ui = cstate.*.turn.phase == phase::STEAL and
        cstate.*.player.is_value() and
        cstate.*.player.value() == cstate.*.turn.player;
    if show_ui and cstate.*.ui.begin_window_ex("Select Player", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
        ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_x, ui_y, ui_w, ui_h);

        cstate.*.ui.layout_row((:[]sint)[-1], 0);
        if cstate.*.ui.button("RED") {
            sender.*.sendc(client_message::init_submit_player(player::RED));
        }
        if cstate.*.ui.button("BLUE") {
            sender.*.sendc(client_message::init_submit_player(player::BLUE));
        }
        if cstate.*.ui.button("WHITE") {
            sender.*.sendc(client_message::init_submit_player(player::WHITE));
        }
        if cstate.*.ui.button("ORANGE") {
            sender.*.sendc(client_message::init_submit_player(player::ORANGE));
        }

        cstate.*.ui.end_window();
    }

    # Main Phase UI Window(s)
    var show_ui = cstate.*.turn.phase == phase::MAIN and
        cstate.*.player.is_value() and
        cstate.*.player.value() == cstate.*.turn.player;
    if show_ui {
        switch cstate.*.ui_dynamic_state.kind {
        ui_dynamic_state::ROOT {
            ui_window_main_root(cstate, sender);
        }
        ui_dynamic_state::BUILD_ROAD {
            ui_window_main_build_road(cstate);
        }
        ui_dynamic_state::BUILD_TOWN {
            ui_window_main_build_road(cstate);
        }
        ui_dynamic_state::PLAY_DEV_CARD {
            ui_window_play_dev_card(cstate, sender);
        }
        ui_dynamic_state::PLAY_DEV_CARD_YEAR_OF_PLENTY {
            ui_window_play_dev_card_year_of_plenty(cstate, sender);
        }
        ui_dynamic_state::PLAY_DEV_CARD_MONOPOLY {
            ui_window_play_dev_card_monopoly(cstate, sender);
        }
        ui_dynamic_state::TRADE_WITH_BANK {
            ui_window_main_trade_with_bank(cstate, sender);
        }
        ui_dynamic_state::TRADE_WITH_PLAYERS {
            ui_window_main_trade_with_players(cstate, sender);
        }
        }
    }

    # Trade Phase UI Window
    var ui_w = (:sint)screen_w / 4;
    var ui_h = (:sint)screen_h / 4;
    var ui_x = (:sint)screen_w * 2 / 3 - ui_w - 2 * UI_BORDER;
    var ui_y = (:sint)screen_h - ui_h - UI_BORDER;
    var show_ui = cstate.*.turn.phase == phase::TRADE;
    if show_ui {
        var ui_recv_x = ui_x;
        var ui_recv_y = ui_y - ui_h - UI_BORDER;

        var ui_give_x = ui_recv_x - ui_w - UI_BORDER;
        var ui_give_y = ui_recv_y;

        # Give Window
        if cstate.*.ui.begin_window_ex("Resources to Give", smol::rect::init(ui_give_x, ui_give_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
            ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_give_x, ui_give_y, ui_w, ui_h);

            cstate.*.ui.layout_row((:[]sint)[64, -1], 0);
            var resources: resources = uninit;
            if cstate.*.player.is_value() and cstate.*.player.value() == cstate.*.turn.player {
                resources = cstate.*.trade.give;
            }
            else {
                resources = cstate.*.trade.recv;
            }
            cstate.*.ui.label("Brick:");
            var s = std::string::init_from_format("{}", (:[]std::formatter)[std::formatter::init[[sint]](&resources.brick)]);
            defer s.fini();
            cstate.*.ui.text(s.data());
            cstate.*.ui.label("Ore:");
            var s = std::string::init_from_format("{}", (:[]std::formatter)[std::formatter::init[[sint]](&resources.ore)]);
            defer s.fini();
            cstate.*.ui.text(s.data());
            cstate.*.ui.label("Sheep:");
            var s = std::string::init_from_format("{}", (:[]std::formatter)[std::formatter::init[[sint]](&resources.sheep)]);
            defer s.fini();
            cstate.*.ui.text(s.data());
            cstate.*.ui.label("Wheat:");
            var s = std::string::init_from_format("{}", (:[]std::formatter)[std::formatter::init[[sint]](&resources.wheat)]);
            defer s.fini();
            cstate.*.ui.text(s.data());
            cstate.*.ui.label("Wood:");
            var s = std::string::init_from_format("{}", (:[]std::formatter)[std::formatter::init[[sint]](&resources.wood)]);
            defer s.fini();
            cstate.*.ui.text(s.data());

            cstate.*.ui.end_window();
        }

        # Recv Window
        if cstate.*.ui.begin_window_ex("Resources to Receive", smol::rect::init(ui_recv_x, ui_recv_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
            ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_recv_x, ui_recv_y, ui_w, ui_h);

            cstate.*.ui.layout_row((:[]sint)[64, -1], 0);
            var resources: resources = uninit;
            if cstate.*.player.is_value() and cstate.*.player.value() == cstate.*.turn.player {
                resources = cstate.*.trade.recv;
            }
            else {
                resources = cstate.*.trade.give;
            }
            cstate.*.ui.label("Brick:");
            var s = std::string::init_from_format("{}", (:[]std::formatter)[std::formatter::init[[sint]](&resources.brick)]);
            defer s.fini();
            cstate.*.ui.text(s.data());
            cstate.*.ui.label("Ore:");
            var s = std::string::init_from_format("{}", (:[]std::formatter)[std::formatter::init[[sint]](&resources.ore)]);
            defer s.fini();
            cstate.*.ui.text(s.data());
            cstate.*.ui.label("Sheep:");
            var s = std::string::init_from_format("{}", (:[]std::formatter)[std::formatter::init[[sint]](&resources.sheep)]);
            defer s.fini();
            cstate.*.ui.text(s.data());
            cstate.*.ui.label("Wheat:");
            var s = std::string::init_from_format("{}", (:[]std::formatter)[std::formatter::init[[sint]](&resources.wheat)]);
            defer s.fini();
            cstate.*.ui.text(s.data());
            cstate.*.ui.label("Wood:");
            var s = std::string::init_from_format("{}", (:[]std::formatter)[std::formatter::init[[sint]](&resources.wood)]);
            defer s.fini();
            cstate.*.ui.text(s.data());

            cstate.*.ui.end_window();
        }

        # Menu Buttons Window
        if cstate.*.player.is_value() and cstate.*.player.value() == cstate.*.turn.player
        and cstate.*.ui.begin_window_ex("Trade with Players", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
            ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_x, ui_y, ui_w, ui_h);

            cstate.*.ui.layout_row((:[]sint)[-1], 0);
            if cstate.*.ui.button("Withdraw Trade") {
                sender.*.sendc(client_message::init_trade_withdraw());
            }

            cstate.*.ui.end_window();
        }
        elif cstate.*.player.is_value() and not *cstate.*.p_trade_submitted(cstate.*.player.value())
        and cstate.*.ui.begin_window_ex("Trade with Players", smol::rect::init(ui_x, ui_y, ui_w, ui_h), smol::OPT_NOCLOSE) {
            ui_reset_cached_container_size(cstate.*.ui.get_current_container(), ui_x, ui_y, ui_w, ui_h);

            cstate.*.ui.layout_row((:[]sint)[-1], 0);
            if cstate.*.ui.button("Accept") {
                sender.*.sendc(client_message::init_trade_accept(cstate.*.trade));
            }
            if cstate.*.ui.button("Decline") {
                sender.*.sendc(client_message::init_trade_reject(cstate.*.trade));
            }

            cstate.*.ui.end_window();
        }
    }

    mu_end(cstate.*.ui.context);

    # Board Actions
    if cstate.*.turn.phase == phase::ROBBER
    and cstate.*.player.is_value() and cstate.*.player.value() == cstate.*.turn.player
    and IsMouseButtonPressed(MOUSE_BUTTON_LEFT) {
        if cstate.*.world_tile.is_value() {
            var world_tile = cstate.*.world_tile.value();
            if not std::eq[[hex]](&world_tile.hex, &cstate.*.board.robber) {
                var cmessage = client_message::init_move_robber(world_tile.hex);
                sender.*.sendc(cmessage);
            }
        }
        return;
    }
    elif IsKeyPressed(KEY_TAB)
    and cstate.*.turn.phase == phase::GAME_INIT {
        sender.*.sendc(client_message::init_begin_game());
        return;
    }
    elif IsKeyPressed(KEY_TAB)
    and cstate.*.turn.phase == phase::RESOURCE_PRODUCTION {
        sender.*.sendc(client_message::init_roll());
        return;
    }
    elif IsKeyPressed(KEY_TAB)
    and cstate.*.turn.phase == phase::MAIN {
        sender.*.sendc(client_message::init_end_turn());
        return;
    }
    elif (
        cstate.*.ui_dynamic_state.kind == ui_dynamic_state::BUILD_ROAD or
        cstate.*.player.is_value() and cstate.*.player.value() == cstate.*.turn.player and cstate.*.turn.phase == phase::GAME_INIT_BUILD_ROAD or
        cstate.*.player.is_value() and cstate.*.player.value() == cstate.*.turn.player and cstate.*.turn.phase == phase::ROAD_BUILDING_1 or
        cstate.*.player.is_value() and cstate.*.player.value() == cstate.*.turn.player and cstate.*.turn.phase == phase::ROAD_BUILDING_2
    )
    and IsMouseButtonPressed(MOUSE_BUTTON_LEFT)
    and cstate.*.world_edge.is_value() {
        var tile_a = cstate.*.board.tiles.lookup(cstate.*.world_edge.value().hexes[0]);
        var tile_b = cstate.*.board.tiles.lookup(cstate.*.world_edge.value().hexes[1]);
        assert tile_a.is_value() and tile_b.is_value();
        var is_road_across_water =
            tile_a.value().*.kind == tile::OCEAN and
            tile_b.value().*.kind == tile::OCEAN;
        if not is_road_across_water {
            sender.*.sendc(client_message::init_build_road(
                road::init(
                    cstate.*.player.value(),
                    cstate.*.world_edge.value())));
            cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::ROOT);
        }
        return;
    }
    elif (
        cstate.*.ui_dynamic_state.kind == ui_dynamic_state::BUILD_TOWN or
        cstate.*.player.is_value() and cstate.*.player.value() == cstate.*.turn.player and cstate.*.turn.phase == phase::GAME_INIT_BUILD_TOWN
    )
    and IsMouseButtonPressed(MOUSE_BUTTON_LEFT)
    and cstate.*.world_node.is_value() {
        var existing = cstate.*.board.towns.lookup(cstate.*.world_node.value());
        if existing.is_value() and cstate.*.player.is_value() and cstate.*.player.value() == existing.value().*.player {
            var cmessage = client_message::init_build_town(
                town::init(
                    cstate.*.player.value(),
                    cstate.*.world_node.value(),
                    town::CITY));
            sender.*.sendc(cmessage);
            cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::ROOT);
            return;
        }

        var cmessage = client_message::init_build_town(
            town::init(
                cstate.*.player.value(),
                cstate.*.world_node.value(),
                town::SETTLEMENT));
        sender.*.sendc(cmessage);
        cstate.*.ui_dynamic_state = ui_dynamic_state::init(ui_dynamic_state::ROOT);
        return;
    }
}

func client_render(cstate: *client_state) void {
    BeginDrawing();
    defer EndDrawing();
    ClearBackground((:Color){.r = 0x66, .g = 0xBB, .b = 0xFF, .a = 0xFF});

    var screen_w = screen_w();
    var screen_h = screen_h();
    var camera = camera();

    if not cstate.*.connected or cstate.*.board.tiles.count() == 0 {
        var text = "Connecting...";
        var size = measure_text(cstate.*.board_font, cstate.*.board_font_size, text);
        var position = (:Vector2){
            .x = screen_w / 2.0 - size.x / 2.0,
            .y = screen_h / 2.0 - size.y / 2.0,
        };
        draw_text(cstate.*.board_font, cstate.*.board_font_size, BLACK, position, text);
        return;
    }

    BeginMode2D(camera);

    var iter = cstate.*.board.tiles.iterator();
    for iter.advance() {
        var tile = iter.current().*.value;
        var point = pointy_hex_to_point(tile.*.hex, HEX_RADIUS);
        draw_pointy_hexagon(point, HEX_RADIUS, tile_color(*tile));
        var resource = tile.*.resource();
        if resource.is_value() {
            draw_number_token(point, tile.*.number, HEX_RADIUS, cstate.*.board_font, HEX_RADIUS / 1.8);
        }
    }

    var world_hex_center = pointy_hex_to_point(cstate.*.world_hex, HEX_RADIUS);

    if cstate.*.debug {
        if cstate.*.world_node.is_value() {
            for i in countof(cstate.*.world_node.value().hexes) {
                var point = pointy_hex_to_point(cstate.*.world_node.value().hexes[i], HEX_RADIUS);
                draw_pointy_hexagon_outline(point, HEX_RADIUS, RED);
            }
        }
        elif cstate.*.world_edge.is_value() {
            for i in countof(cstate.*.world_edge.value().hexes) {
                var point = pointy_hex_to_point(cstate.*.world_edge.value().hexes[i], HEX_RADIUS);
                draw_pointy_hexagon_outline(point, HEX_RADIUS, ORANGE);
            }
        }
        elif cstate.*.world_tile.is_value() {
            draw_pointy_hexagon_outline(world_hex_center, HEX_RADIUS, YELLOW);
        }
    }

    var iter = cstate.*.board.tiles.iterator();
    for iter.advance() {
        var tile = iter.current().*.value;
        if tile.*.kind == ::tile::OCEAN {
            continue;
        }
        var point = pointy_hex_to_point(tile.*.hex, HEX_RADIUS);
        draw_pointy_hexagon_border(point, HEX_RADIUS, BLACK);
    }

    # Draw outlines tiles corresponding to the current turn's dice roll.
    if cstate.*.turn.phase == phase::MAIN {
        var sum = cstate.*.board.d6_a + cstate.*.board.d6_b;
        var iter = cstate.*.board.tiles.iterator();
        for iter.advance() {
            if iter.current().*.value.*.number == sum {
                var center = pointy_hex_to_point(iter.current().*.key.*, HEX_RADIUS);
                draw_pointy_hexagon_outline(center, HEX_RADIUS, YELLOW);
                draw_pointy_hexagon_border(center, HEX_RADIUS, BLACK);
            }
        }
    }

    # Re-draw the hexagon outline and boarder for the currently hovered-over
    # tile if the robber is being moved. This is done before towns and roads
    # are drawn so that the hovered-over tile appears highlighted.
    if cstate.*.turn.phase == phase::ROBBER
    and cstate.*.player.is_value() and cstate.*.player.value() == cstate.*.turn.player {
        var tile = cstate.*.board.tiles.lookup(cstate.*.world_hex);
        if tile.is_value() and tile.value().*.kind != ::tile::OCEAN {
            draw_pointy_hexagon_outline(world_hex_center, HEX_RADIUS, YELLOW);
            draw_pointy_hexagon_border(world_hex_center, HEX_RADIUS, BLACK);
        }
    }

    var iter = cstate.*.board.ports.iterator();
    for iter.advance() {
        var port = iter.current();
        draw_port(*port, HEX_RADIUS, cstate.*.board_font, HEX_RADIUS / 2.2);
    }

    var iter = cstate.*.board.roads.iterator();
    for iter.advance() {
        var road = iter.current().*.value;
        var points = edge_to_points(road.*.edge, HEX_RADIUS);
        draw_road(points[0], points[1], HEX_RADIUS, player_color(road.*.player));
    }

    var show_world_edge_road_valid =
        cstate.*.turn.phase == phase::ROAD_BUILDING_1 or
        cstate.*.turn.phase == phase::ROAD_BUILDING_2 or
        (cstate.*.turn.phase == phase::MAIN and cstate.*.ui_dynamic_state.kind == ui_dynamic_state::BUILD_ROAD);
    var show_world_edge_road =
        show_world_edge_road_valid and
        cstate.*.world_edge.is_value() and
        not cstate.*.board.roads.contains(cstate.*.world_edge.value()) and
        not cstate.*.world_node.is_value();
    var show_world_edge_road =
        show_world_edge_road or
        cstate.*.player.is_value() and cstate.*.player.value() == cstate.*.turn.player and cstate.*.turn.phase == phase::GAME_INIT_BUILD_ROAD and
        cstate.*.world_edge.is_value() and
        not cstate.*.board.roads.contains(cstate.*.world_edge.value()) and
        not cstate.*.world_node.is_value();
    if show_world_edge_road {
        var tile_a = cstate.*.board.tiles.lookup(cstate.*.world_edge.value().hexes[0]);
        var tile_b = cstate.*.board.tiles.lookup(cstate.*.world_edge.value().hexes[1]);
        assert tile_a.is_value() and tile_b.is_value();
        var is_road_across_water =
            tile_a.value().*.kind == tile::OCEAN and
            tile_b.value().*.kind == tile::OCEAN;
        if not is_road_across_water {
            var points = edge_to_points(cstate.*.world_edge.value(), HEX_RADIUS);
            draw_road(points[0], points[1], HEX_RADIUS, YELLOW);
        }
    }

    var iter = cstate.*.board.towns.iterator();
    for iter.advance() {
        var town = iter.current().*.value;
        switch town.*.kind {
        ::town::SETTLEMENT {
            draw_settlement(node_to_point(town.*.node, HEX_RADIUS), HEX_RADIUS, player_color(town.*.player));
        }
        ::town::CITY {
            draw_city(node_to_point(town.*.node, HEX_RADIUS), HEX_RADIUS, player_color(town.*.player));
        }
        }
    }

    var show_world_node_town =
        cstate.*.turn.phase == phase::MAIN and
        cstate.*.ui_dynamic_state.kind == ui_dynamic_state::BUILD_TOWN and
        cstate.*.world_node.is_value();
    var show_world_node_town =
        show_world_node_town or
        cstate.*.player.is_value() and cstate.*.player.value() == cstate.*.turn.player and cstate.*.turn.phase == phase::GAME_INIT_BUILD_TOWN and
        cstate.*.world_node.is_value();
    if show_world_node_town {
        var point = node_to_point(cstate.*.world_node.value(), HEX_RADIUS);
        draw_circle(point, 6.0, YELLOW);
        draw_circle_outline(point, 6.0, 1.0, BLACK);
    }

    var robber_outline = BLACK;
    if cstate.*.turn.phase == phase::ROBBER and cstate.*.player.is_value() and cstate.*.player.value() == cstate.*.turn.player {
        robber_outline = YELLOW;
    }
    draw_robber(pointy_hex_to_point(cstate.*.board.robber, HEX_RADIUS), HEX_RADIUS, robber_outline);

    if cstate.*.debug {
        if cstate.*.world_node.is_value() {
            var world_node = cstate.*.world_node.value();
            var world_node_point = node_to_point(world_node, HEX_RADIUS);
            draw_circle(world_node_point, 6.0, RED);
            draw_circle_outline(world_node_point, 6.0, 1.0, BLACK);
        }
        elif cstate.*.world_edge.is_value() {
            var world_edge = cstate.*.world_edge.value();
            var points = edge_to_points(world_edge, HEX_RADIUS);
            draw_circle(points[0], 6.0, ORANGE);
            draw_circle(points[1], 6.0, ORANGE);
            draw_circle_outline(points[0], 6.0, 1.0, BLACK);
            draw_circle_outline(points[1], 6.0, 1.0, BLACK);
        }
        else {
            draw_circle(world_hex_center, 6.0, YELLOW);
            draw_circle_outline(world_hex_center, 6.0, 1.0, BLACK);
        }
    }

    EndMode2D();

    var SQUARE_SIDE = f32::min(screen_w / 24.0, screen_h / 24.0);
    let SQUARE_OFFSET = 8.0f32;
    var square_xpos = SQUARE_OFFSET;
    var square_ypos = screen_h - SQUARE_SIDE - SQUARE_OFFSET;
    draw_d6(
        cstate.*.board_font,
        SQUARE_SIDE / 1.2,
        (:Vector2){
            .x = square_xpos + SQUARE_SIDE * 0.0 + SQUARE_OFFSET * 0.0,
            .y = square_ypos,
        },
        SQUARE_SIDE,
        cstate.*.board.d6_a,
        YELLOW,
        RED);
    draw_d6(
        cstate.*.board_font,
        SQUARE_SIDE / 1.2,
        (:Vector2){
            .x = square_xpos + SQUARE_SIDE * 1.0 + SQUARE_OFFSET * 1.0,
            .y = square_ypos,
        },
        SQUARE_SIDE,
        cstate.*.board.d6_b,
        RED,
        YELLOW);

    smol::render(cstate.*.ui.context);

    let FONT_SIZE = HEX_RADIUS / 2.0;
    if cstate.*.debug {
        var fps = GetFPS();
        draw_text_format(cstate.*.board_font, FONT_SIZE, BLACK,
            (:Vector2){.x = 2.0, .y = 0.0},
            "FPS {}",
            (:[]std::formatter)[
                std::formatter::init[[typeof(fps)]](&fps)]);

        draw_text_format(cstate.*.board_font, FONT_SIZE, BLACK,
            (:Vector2){.x = 2.0, .y = 1.0 * FONT_SIZE},
            "MOUSE: x={.0}, y={.0}",
            (:[]std::formatter)[
                std::formatter::init[[f32]](&cstate.*.mouse.x),
                std::formatter::init[[f32]](&cstate.*.mouse.y)]);

        draw_text_format(cstate.*.board_font, FONT_SIZE, BLACK,
            (:Vector2){.x = 2.0, .y = 2.0 * FONT_SIZE},
            "WORLD: x={.0}, y={.0}",
            (:[]std::formatter)[
                std::formatter::init[[f32]](&cstate.*.world.x),
                std::formatter::init[[f32]](&cstate.*.world.y)]);

        draw_text_format(cstate.*.board_font, FONT_SIZE, BLACK,
            (:Vector2){.x = 2.0, .y = 3.0 * FONT_SIZE},
            "WORLD->HEX: q={}, r={}, s={}",
            (:[]std::formatter)[
                std::formatter::init[[sint]](&cstate.*.world_hex.q),
                std::formatter::init[[sint]](&cstate.*.world_hex.r),
                std::formatter::init[[sint]](&cstate.*.world_hex.s)]);

        draw_text_format(cstate.*.board_font, FONT_SIZE, BLACK,
            (:Vector2){.x = 2.0, .y = 4.0 * FONT_SIZE},
            "WORLD->HEX->WORLD: x={.0}, y={.0}",
            (:[]std::formatter)[
                std::formatter::init[[f32]](&world_hex_center.x),
                std::formatter::init[[f32]](&world_hex_center.y)]);

        if cstate.*.world_node.is_value() {
            var world_node = cstate.*.world_node.value();
            draw_text_format(cstate.*.board_font, FONT_SIZE, BLACK,
                (:Vector2){.x = 2.0, .y = 5.0 * FONT_SIZE},
                "NODE: {}",
                (:[]std::formatter)[
                    std::formatter::init[[node]](&world_node)]);
        }
        elif cstate.*.world_edge.is_value() {
            var world_edge = cstate.*.world_edge.value();
            draw_text_format(cstate.*.board_font, FONT_SIZE, BLACK,
                (:Vector2){.x = 2.0, .y = 5.0 * FONT_SIZE},
                "EDGE: {}",
                (:[]std::formatter)[
                    std::formatter::init[[edge]](&world_edge)]);
        }
        elif cstate.*.world_tile.is_value() {
            var world_tile = cstate.*.world_tile.value();
            draw_text_format(cstate.*.board_font, FONT_SIZE, BLACK,
                (:Vector2){.x = 2.0, .y = 5.0 * FONT_SIZE},
                "TILE: {} {verbose}",
                (:[]std::formatter)[
                    std::formatter::init[[hex]](&world_tile.hex),
                    std::formatter::init[[tile]](&world_tile)]);
        }
        else {
            draw_text(cstate.*.board_font, FONT_SIZE, BLACK,
                (:Vector2){.x = 2.0, .y = 5.0 * FONT_SIZE},
                "NODE/EDGE/TILE: none");
        }

        draw_text_format(cstate.*.board_font, FONT_SIZE, BLACK,
            (:Vector2){.x = 2.0, .y = 6.0 * FONT_SIZE},
            "TURN: {}",
            (:[]std::formatter)[
                std::formatter::init[[sint]](&cstate.*.turn.number)]);

        var phase_text: []byte = uninit;
        switch cstate.*.turn.phase {
        phase::GAME_INIT {
            phase_text = "game-init";
        }
        phase::GAME_INIT_BUILD_TOWN {
            phase_text = "game-init (build town)";
        }
        phase::GAME_INIT_BUILD_ROAD {
            phase_text = "game init (build road)";
        }
        phase::GAME_FINI {
            phase_text = "game fini";
        }
        phase::RESOURCE_PRODUCTION {
            phase_text = "resource production";
        }
        phase::DISCARD {
            phase_text = "discard";
        }
        phase::ROBBER {
            phase_text = "robber";
        }
        phase::STEAL {
            phase_text = "steal";
        }
        phase::ROAD_BUILDING_1 {
            phase_text = "road building (1)";
        }
        phase::ROAD_BUILDING_2 {
            phase_text = "road building (2)";
        }
        phase::MAIN {
            phase_text = "main";
        }
        phase::TRADE {
            phase_text = "trade";
        }
        }
        draw_text_format(cstate.*.board_font, FONT_SIZE, BLACK,
            (:Vector2){.x = 2.0, .y = 7.0 * FONT_SIZE},
            "PHASE: {}",
            (:[]std::formatter)[
                std::formatter::init[[[]byte]](&phase_text)]);
    }
    else {
        if cstate.*.world_tile.is_value() and cstate.*.world_tile.value().kind != tile::OCEAN {
            var s = std::string::init();
            defer s.fini();
            var world_tile = cstate.*.world_tile.value();
            var resource = world_tile.resource();
            if resource.is_value() {
                var resource = resource.value();
                std::print_format(
                    std::writer::init[[std::string]](&s),
                    "{}({})",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(resource)]](&resource),
                        std::formatter::init[[sint]](&world_tile.number)]);
            }
            else {
                std::print_format(
                    std::writer::init[[std::string]](&s),
                    "{}",
                    (:[]std::formatter)[
                        std::formatter::init[[tile]](&world_tile)]);
            }
            s.data()[0] = std::ascii::to_uppercase(s.data()[0]);
            draw_text_cstr(cstate.*.board_font, FONT_SIZE, BLACK, (:Vector2){.x = 2.0, .y = 0.0}, s.cstr());
        }
    }
}
