#!/usr/bin/env sunder-run
import "std";

func main() void {
    var asset_directory = std::optional[[[]byte]]::EMPTY;
    var parser = std::argument_parser::init((:[][]byte)[]);
    for parser.advance() {
        if asset_directory.is_value() {
            std::print_line(std::err(), "error: multiple asset directories specified");
            std::exit(std::EXIT_FAILURE);
        }
        asset_directory = std::optional[[[]byte]]::init_value(parser.argument_value());
    }

    if asset_directory.is_empty() {
        std::print_line(std::err(), "error: no asset directory specified");
        std::exit(std::EXIT_FAILURE);
    }
    var asset_directory = asset_directory.value();

    var result = std::directory::open(asset_directory);
    if result.is_error() {
        std::print_format_line(
            std::err(),
            "error: {}",
            (:[]std::formatter)[
                std::formatter::init[[[]byte]](&result.error().*.data)]);
    }
    var directory = result.value();
    defer directory.close();

    var c_output_path = std::string::init_from_format(
        "{}/assets.c",
        (:[]std::formatter)[
            std::formatter::init[[[]byte]](&asset_directory)]);
    defer c_output_path.fini();
    var result = std::file::open(c_output_path.data(), std::file::OPEN_WRITE);
    if result.is_error() {
        std::print_format_line(
            std::err(),
            "error: {}",
            (:[]std::formatter)[
                std::formatter::init[[[]byte]](&result.error().*.data)]);
        std::exit(std::EXIT_FAILURE);
    }
    var c_output = result.value();
    defer c_output.close();

    var s_output_path = std::string::init_from_format(
        "{}/assets.sunder",
        (:[]std::formatter)[
            std::formatter::init[[[]byte]](&asset_directory)]);
    defer s_output_path.fini();
    var result = std::file::open(s_output_path.data(), std::file::OPEN_WRITE);
    if result.is_error() {
        std::print_format_line(
            std::err(),
            "error: {}",
            (:[]std::formatter)[
                std::formatter::init[[[]byte]](&result.error().*.data)]);
        std::exit(std::EXIT_FAILURE);
    }
    var s_output = result.value();
    defer s_output.close();

    var c_writer = std::writer::init[[std::file]](&c_output);
    var s_writer = std::writer::init[[std::file]](&s_output);
    std::print_line(c_writer, "#include <stddef.h>");

    for directory.advance() {
        var result = directory.current();
        if result.*.is_error() {
            std::print_format_line(
                std::err(),
                "error: {}",
                (:[]std::formatter)[
                    std::formatter::init[[[]byte]](&result.*.error().*.data)]);
            std::exit(std::EXIT_FAILURE);
        }

        var name = result.*.value();

        var is_asset_file =
            std::str::ends_with(name, ".otf") or
            std::str::ends_with(name, ".ttf") or
            std::str::ends_with(name, ".wav");
        if not is_asset_file {
            continue;
        }

        std::print_format_line(
            std::out(),
            "Bundling: {}",
            (:[]std::formatter)[
                std::formatter::init[[[]byte]](&name)]);
        var path = std::string::init_from_format(
            "{}/{}",
            (:[]std::formatter)[
                std::formatter::init[[[]byte]](&asset_directory),
                std::formatter::init[[[]byte]](&name)]);
        defer path.fini();

        var result = std::file::open(path.data(), std::file::OPEN_READ);
        if result.is_error() {
            std::print_format_line(
                std::err(),
                "error: {}",
                (:[]std::formatter)[
                    std::formatter::init[[[]byte]](&result.error().*.data)]);
            std::exit(std::EXIT_FAILURE);
        }
        var file = result.value();

        var result = file.seek(0, std::file::SEEK_END);
        assert result.is_value();
        var result = file.tell();
        assert result.is_value();
        var size = result.value();
        var result = file.seek(0, std::file::SEEK_START);
        assert result.is_value();

        var buf = std::slice[[byte]]::new(size);
        defer std::slice[[byte]]::delete(buf);

        var allocator = std::linear_allocator::init[[byte]](buf);
        var allocator = std::allocator::init[[typeof(allocator)]](&allocator);

        var reader = std::reader::init[[std::file]](&file);
        var result = std::read_all_with_allocator(allocator, reader);
        if result.is_error() {
            std::print_format_line(
                std::err(),
                "error: {}",
                (:[]std::formatter)[
                    std::formatter::init[[[]byte]](&result.error().*.data)]);
        }
        var data = result.value();

        generate(c_writer, s_writer, path.data(), data);
    }
}

func generate(c_writer: std::writer, s_writer: std::writer, path: []byte, data: []byte) void {
    var normalized = std::string::init_from_str(path);
    defer normalized.fini();

    var iter = std::slice_iterator[[byte]]::init(normalized.data());
    for iter.advance() {
        var char = iter.current();
        if not std::ascii::is_letter(*char) and not std::ascii::is_digit(*char) {
            *char = '_';
        }
    }

    var normalized = normalized.data();
    var count = countof(data);

    # Emit C Code
    std::print_format(
        c_writer,
        "unsigned char const {}_start[] = {{",
        (:[]std::formatter)[
            std::formatter::init[[[]byte]](&normalized)]);
    for i in countof(data) {
        std::print_format(
            c_writer,
            "{#X}",
            (:[]std::formatter)[
                std::formatter::init[[byte]](&data[i])]);
        if i != countof(data) - 1 {
            std::print(c_writer, ", ");
        }
    }
    std::print_line(c_writer, "};");
    std::print_format_line(
        c_writer,
        "size_t const {}_count = {};",
        (:[]std::formatter)[
            std::formatter::init[[[]byte]](&normalized),
            std::formatter::init[[usize]](&count)]);

    # Emit Sunder Code
    std::print_format_line(
        s_writer,
        "extern var {}_start: *byte;",
        (:[]std::formatter)[
            std::formatter::init[[[]byte]](&normalized)]);
    std::print_format_line(
        s_writer,
        "extern var {}_count: usize;",
        (:[]std::formatter)[
            std::formatter::init[[[]byte]](&normalized)]);
}
