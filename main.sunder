import "c";
import "raylib";
import "std";

# Hex position using the cube coordinate system satisfying q + r + s == 0.
struct hex {
    var q: sint;
    var r: sint;
    var s: sint;

    func init(q: sint, r: sint, s: sint) hex {
        assert q + r + s == 0;
        return (:hex){.q = q, .r = r, .s = s};
    }

    func init_round(q_fractional: f32, r_fractional: f32, s_fractional: f32) hex {
        var q_rounded = f32::round(q_fractional);
        var r_rounded = f32::round(r_fractional);
        var s_rounded = f32::round(s_fractional);

        var q_diff = f32::abs(q_rounded - q_fractional);
        var r_diff = f32::abs(r_rounded - r_fractional);
        var s_diff = f32::abs(s_rounded - s_fractional);

        var q = (:sint)q_rounded;
        var r = (:sint)r_rounded;
        var s = (:sint)s_rounded;
        if q_diff > r_diff and q_diff > s_diff {
            q = (:sint)-r_rounded - (:sint)s_rounded;
        }
        elif r_diff > s_diff {
            r = (:sint)-q_rounded - (:sint)s_rounded;
        }
        else {
            s = (:sint)-q_rounded - (:sint)r_rounded;
        }

        return hex::init(q, r, s);
    }

    func hash(self: *hex) usize {
        var h = self.*.q.hash() +% self.*.q.hash() +% self.*.s.hash();
        return h *% h;
    }

    func compare(lhs: *hex, rhs: *hex) ssize {
        var cmp = sint::cmp(lhs.*.q, rhs.*.q);
        if cmp != 0 {
            return cmp;
        }

        var cmp = sint::cmp(lhs.*.r, rhs.*.r);
        if cmp != 0 {
            return cmp;
        }

        var cmp = sint::cmp(lhs.*.s, rhs.*.s);
        if cmp != 0 {
            return cmp;
        }

        return 0;
    }

    func format(self: *hex, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            return std::write_format(
                    writer,
                    "(q={}, r={}, s={})",
                    (:[]std::formatter)[
                        std::formatter::init[[sint]](&self.*.q),
                        std::formatter::init[[sint]](&self.*.r),
                        std::formatter::init[[sint]](&self.*.s)]);
        }

        return std::result[[void, std::error]]::init_value(void::VALUE);
    }

    func subtract(lhs: hex, rhs: hex) hex {
        return hex::init(lhs.q - rhs.q, lhs.r - rhs.r, lhs.s - rhs.s);
    }

    func distance(a: hex, b: hex) sint {
        var vec = hex::subtract(a, b);
        return (sint::abs(vec.q) + sint::abs(vec.r) + sint::abs(vec.s)) / 2;
    }
}

enum resource {
    BRICK;
    ORE;
    SHEEP;
    WHEAT;
    WOOD;

    func data(self: *resource) []byte {
        switch *self {
        BRICK {
            return "brick";
        }
        ORE {
            return "ore";
        }
        SHEEP {
            return "sheep";
        }
        WHEAT {
            return "wheat";
        }
        WOOD {
            return "wood";
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[[]byte]]();
    }

    func cstr(self: *resource) *byte {
        return startof(self.*.data());
    }

    func format(self: *resource, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            return std::write_all(writer, self.*.data());
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }
}

struct tile {
    var hex: hex;
    var kind: enum {
        DESERT;
        OCEAN;

        FOREST;
        FIELD;
        HILL;
        MOUNTAIN;
        PASTURE;
    };
    var number_token: sint;

    let SELF: tile = uninit;

    func init(hex: hex, kind: typeof(SELF.kind), number_token: sint) tile {
        return (:tile){
            .hex = hex,
            .kind = kind,
            .number_token = number_token,
        };
    }

    func hash(self: *tile) usize {
        return self.*.hex.hash();
    }

    func compare(lhs: *tile, rhs: *tile) ssize {
        return std::compare[[hex]](&lhs.*.hex, &rhs.*.hex);
    }

    func resource(self: *tile) std::optional[[::resource]] {
        switch self.*.kind {
        tile::DESERT or tile::OCEAN {
            return std::optional[[::resource]]::EMPTY;
        }
        tile::FOREST {
            return std::optional[[::resource]]::init_value(::resource::WOOD);
        }
        tile::FIELD {
            return std::optional[[::resource]]::init_value(::resource::WHEAT);
        }
        tile::HILL {
            return std::optional[[::resource]]::init_value(::resource::BRICK);
        }
        tile::MOUNTAIN {
            return std::optional[[::resource]]::init_value(::resource::ORE);
        }
        tile::PASTURE {
            return std::optional[[::resource]]::init_value(::resource::SHEEP);
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[std::optional[[::resource]]]]();
    }

    func color(self: *tile) Color {
        switch self.*.kind {
        tile::DESERT {
            return (:Color){.r = 0xEE, .g = 0xCC, .b = 0x88, .a = 0xFF};
        }
        tile::OCEAN {
            return (:Color){.r = 0x66, .g = 0xBB, .b = 0xFF, .a = 0xFF};
        }
        tile::FOREST {
            return (:Color){.r = 0x11, .g = 0x55, .b = 0x11, .a = 0xFF};
        }
        tile::FIELD {
            return (:Color){.r = 0xDD, .g = 0xAA, .b = 0x22, .a = 0xFF};
        }
        tile::HILL {
            return (:Color){.r = 0xCC, .g = 0x55, .b = 0x44, .a = 0xFF};
        }
        tile::MOUNTAIN {
            return (:Color){.r = 0x88, .g = 0x88, .b = 0x88, .a = 0xFF};
        }
        tile::PASTURE {
            return (:Color){.r = 0x66, .g = 0xAA, .b = 0x66, .a = 0xFF};
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[Color]]();
    }

    func format(self: *tile, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        var kind: []byte = "<error>";
        switch self.*.kind {
        tile::DESERT {
            kind = "desert";
        }
        tile::OCEAN {
            kind = "ocean";
        }
        tile::FOREST {
            kind = "forest";
        }
        tile::FIELD {
            kind = "field";
        }
        tile::HILL {
            kind = "hill";
        }
        tile::MOUNTAIN {
            kind = "mountain";
        }
        tile::PASTURE {
            kind = "pasture";
        }
        }

        if std::str::eq(fmt, "") {
            return std::write_all(writer, kind);
        }

        if std::str::eq(fmt, "verbose") {
            var resource = self.*.resource();
            if resource.is_empty() {
                return std::write_all(writer, kind);
            }

            var resource = resource.value();
            return std::write_format(
                writer,
                "{} ({}, {})",
                (:[]std::formatter)[
                    std::formatter::init[[[]byte]](&kind),
                    std::formatter::init[[::resource]](&resource),
                    std::formatter::init[[sint]](&self.*.number_token)]);
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }
}

struct edge {
    var tiles: [2]tile;

    func init(a: tile, b: tile) edge {
        assert hex::distance(a.hex, b.hex) == 1;

        var tiles = (:[2]tile)[a, b];
        std::sort[[tile]](tiles[0:countof(tiles)]);

        return (:edge){
            .tiles = tiles,
        };
    }

    func hash(self: *edge) usize {
        var hash = 0u;
        for i in countof(self.*.tiles) {
            hash = hash +% self.*.tiles[i].hash();
        }
        return hash;
    }

    func compare(lhs: *edge, rhs: *edge) ssize {
        var cmp = tile::compare(&lhs.*.tiles[0], &rhs.*.tiles[0]);
        if cmp != 0 {
            return cmp;
        }

        var cmp = tile::compare(&lhs.*.tiles[1], &rhs.*.tiles[1]);
        if cmp != 0 {
            return cmp;
        }

        return 0;
    }

    func format(self: *edge, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            for i in countof(self.*.tiles) {
                if i != 0 {
                    std::print(writer, ", ");
                }
                std::print_format(
                    writer,
                    "{}",
                    (:[]std::formatter)[
                        std::formatter::init[[hex]](&self.*.tiles[i].hex)]);
            }

            return std::result[[void, std::error]]::init_value(void::VALUE);
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }
}

struct node {
    var tiles: [3]tile;

    func init(a: tile, b: tile, c: tile) node {
        assert hex::distance(a.hex, b.hex) == 1;
        assert hex::distance(b.hex, c.hex) == 1;
        assert hex::distance(c.hex, a.hex) == 1;

        var tiles = (:[3]tile)[a, b, c];
        std::sort[[tile]](tiles[0:countof(tiles)]);

        return (:node){
            .tiles = tiles,
        };
    }

    func hash(self: *node) usize {
        var hash = 0u;
        for i in countof(self.*.tiles) {
            hash = hash +% self.*.tiles[i].hash();
        }
        return hash;
    }

    func compare(lhs: *node, rhs: *node) ssize {
        var cmp = tile::compare(&lhs.*.tiles[0], &rhs.*.tiles[0]);
        if cmp != 0 {
            return cmp;
        }

        var cmp = tile::compare(&lhs.*.tiles[1], &rhs.*.tiles[1]);
        if cmp != 0 {
            return cmp;
        }

        var cmp = tile::compare(&lhs.*.tiles[2], &rhs.*.tiles[2]);
        if cmp != 0 {
            return cmp;
        }

        return 0;
    }

    func format(self: *node, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            for i in countof(self.*.tiles) {
                if i != 0 {
                    std::print(writer, ", ");
                }
                std::print_format(
                    writer,
                    "{}",
                    (:[]std::formatter)[
                        std::formatter::init[[hex]](&self.*.tiles[i].hex)]);
            }

            return std::result[[void, std::error]]::init_value(void::VALUE);
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }
}

func point_to_pointy_hex(point: Vector2, radius: f32) hex {
    var q = (f32::sqrt(3.0)/3.0 * point.x - 1.0/3.0 * point.y) / radius;
    var r = (2.0/3.0 * point.y) / radius;
    var s = -q - r;

    return hex::init_round(q, r, s);
}

func pointy_hex_to_point(hex: hex, radius: f32) Vector2 {
    var x = radius * (f32::sqrt(3.0) * (:f32)hex.q + f32::sqrt(3.0)/2.0 * (:f32)hex.r);
    var y = radius * (3.0/2.0 * (:f32)hex.r);
    return (:Vector2){.x = x, .y = y};
}

func pointy_hex_vertices(hex: hex, radius: f32) [6]Vector2 {
    var result: [6]Vector2 = uninit;
    var center = pointy_hex_to_point(hex, radius);
    for i in 6 {
        var x = center.x + f32::cos(f32::degrees_to_radians((:f32)i * 360.0 / 6.0 + 30.0)) * radius;
        var y = center.y + f32::sin(f32::degrees_to_radians((:f32)i * 360.0 / 6.0 + 30.0)) * radius;
        result[i] = (:Vector2){.x = x, .y = y};
    }
    return result;
}

func draw_pointy_hexagon(center: Vector2, radius: f32, color: Color) void {
    let SIDES: sint = 6;
    let ANGLE: f32 = 30.0; # pointy-top orientation
    DrawPoly(center, SIDES, radius, ANGLE, color);
}

func draw_pointy_hexagon_outline(center: Vector2, radius: f32, color: Color) void {
    let SIDES: sint = 6;
    let ANGLE: f32 = 30.0; # pointy-top orientation
    DrawPolyLinesEx(center, SIDES, radius, ANGLE, radius / 8.0, color);
}

func draw_pointy_hexagon_border(center: Vector2, radius: f32, color: Color) void {
    let SIDES: sint = 6;
    let ANGLE: f32 = 30.0; # pointy-top orientation
    var thick: f32 = radius / 16.0;
    DrawPolyLinesEx(center, SIDES, radius + thick / 2.0, ANGLE, thick, color);
}

func feq(a: f32, b: f32) bool {
    let THRESHOLD: f32 = 0.0001;
    return f32::abs(a - b) < THRESHOLD;
}

func vec2_feq(a: Vector2, b: Vector2) bool {
    return feq(a.x, b.x) and feq(a.y, b.y);
}

func vec2_distance(a: Vector2, b: Vector2) f32 {
    var x_dist = a.x - b.x;
    var y_dist = a.y - b.y;
    return f32::sqrt(x_dist * x_dist + y_dist * y_dist);
}

func draw_circle(center: Vector2, radius: f32, color: Color) void {
    # NOTE: DrawCircle and DrawCircleV, which forward to DrawCircleSector with
    # 36 segments, will produce a circle with holes for small (less than ~18.0)
    # radii when using FLAG_MSAA_4X_HINT. Higher segment counts seem to cause
    # more holes to appear in the drawn circle.

    # Draw the circle once with DrawCircleV in order to create an outline with
    # proper anti-aliasing.
    DrawCircleV(center, radius, color);

    # Draw the circle again with DrawCircleSector using a segment count that
    # will be lower for smaller radii in order to fill in the circle.
    var segments = (:sint)radius;
    DrawCircleSector(center, radius, 0.0, 360.0, segments, color);

}

func draw_circle_outline(center: Vector2, radius: f32, thickness: f32, color: Color) void {
    let SIDES: sint = 36;
    let ANGLE: f32 = 0.0;
    DrawPolyLinesEx(center, SIDES, radius, ANGLE, thickness, color);
}

func draw_text(font: Font, size: f32, color: Color, position: Vector2, text: []byte) void {
    var s = std::string::init_from_str(text);
    defer s.fini();

    let SPACING = 0.0f32;
    DrawTextEx(font, s.cstr(), position, size, SPACING, color);
}

func draw_text_cstr(font: Font, size: f32, color: Color, position: Vector2, text: *byte) void {
    let SPACING = 0.0f32;
    DrawTextEx(font, text, position, size, SPACING, color);
}

func measure_text_format(font: Font, size: f32, format: []byte, args: []std::formatter) Vector2 {
    var s = std::string::init_from_format(format, args);
    defer s.fini();

    let SPACING = 0.0f32;
    return MeasureTextEx(font, s.cstr(), size, SPACING);
}

func draw_text_format(font: Font, size: f32, color: Color, position: Vector2, format: []byte, args: []std::formatter) void {
    var s = std::string::init_from_format(format, args);
    defer s.fini();

    let SPACING = 0.0f32;
    DrawTextEx(font, s.cstr(), position, size, SPACING, color);
}

func camera_zoom(radius: f32, h: f32) f32 {
    # Return a camera zoom such that the board and board-adjacent ocean tiles
    # fit on the screen. Approximate the length of the board and board-adjacent
    # ocean tiles as six tile diameters (five board tiles plus two ocean tiles
    # on either side minus one tile to somewhat account for radius overlap).
    return h / (6.0 * 2.0 * radius);
}

func init_tiles() std::hash_set[[tile]] {
    var tiles = std::hash_set[[tile]]::init();

    # top row
    tiles.insert(tile::init(hex::init(+0, -2, +2), tile::MOUNTAIN, 10));
    tiles.insert(tile::init(hex::init(+1, -2, +1), tile::PASTURE, 2));
    tiles.insert(tile::init(hex::init(+2, -2, +0), tile::FOREST, 9));
    # top-middle row
    tiles.insert(tile::init(hex::init(-1, -1, +2), tile::FIELD, 12));
    tiles.insert(tile::init(hex::init(+0, -1, +1), tile::HILL, 6));
    tiles.insert(tile::init(hex::init(+1, -1, +0), tile::PASTURE, 4));
    tiles.insert(tile::init(hex::init(+2, -1, -1), tile::HILL, 10));
    # middle row
    tiles.insert(tile::init(hex::init(-2, +0, +2), tile::FIELD, 9));
    tiles.insert(tile::init(hex::init(-1, +0, +1), tile::FOREST, 11));
    tiles.insert(tile::init(hex::init(+0, +0, +0), tile::DESERT, -1));
    tiles.insert(tile::init(hex::init(+1, +0, -1), tile::FOREST, 3));
    tiles.insert(tile::init(hex::init(+2, +0, -2), tile::MOUNTAIN, 8));
    # bottom-middle row
    tiles.insert(tile::init(hex::init(-2, +1, +1), tile::FOREST, 8));
    tiles.insert(tile::init(hex::init(-1, +1, +0), tile::MOUNTAIN, 3));
    tiles.insert(tile::init(hex::init(+0, +1, -1), tile::FIELD, 4));
    tiles.insert(tile::init(hex::init(+1, +1, -2), tile::PASTURE, 5));
    # bottom row
    tiles.insert(tile::init(hex::init(-2, +2, +0), tile::HILL, 5));
    tiles.insert(tile::init(hex::init(-1, +2, -1), tile::FIELD, 6));
    tiles.insert(tile::init(hex::init(+0, +2, -2), tile::PASTURE, 11));
    # adjacent ocean
    tiles.insert(tile::init(hex::init(+0, -3, +3), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(+1, -3, +2), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(+2, -3, +1), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(+3, -3, +0), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(-1, -2, +3), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(+3, -2, -1), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(-2, -1, +3), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(+3, -1, -2), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(-3, +0, +3), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(+3, +0, -3), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(-3, +1, +2), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(+2, +1, -3), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(-3, +2, +1), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(+1, +2, -3), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(-3, +3, +0), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(-2, +3, -1), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(-1, +3, -2), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(+0, +3, -3), tile::OCEAN, -1));

    return tiles;
}

func init_nodes(tiles: *std::hash_set[[tile]]) std::hash_set[[node]] {
    var nodes = std::hash_set[[node]]::init();

    var iter_i = std::hash_set_iterator[[tile]]::init(tiles);
    for iter_i.advance() {
        var iter_j = std::hash_set_iterator[[tile]]::init(tiles);
        for iter_j.advance() {
            var iter_k = std::hash_set_iterator[[tile]]::init(tiles);
            for iter_k.advance() {
                if hex::distance(iter_i.current().*.hex, iter_j.current().*.hex) != 1 {
                    continue;
                }
                if hex::distance(iter_j.current().*.hex, iter_k.current().*.hex) != 1 {
                    continue;
                }
                if hex::distance(iter_k.current().*.hex, iter_i.current().*.hex) != 1 {
                    continue;
                }
                var node = node::init(*iter_i.current(), *iter_j.current(), *iter_k.current());
                nodes.insert(node);
            }
        }
    }

    return nodes;
}

func init_edges(tiles: *std::hash_set[[tile]]) std::hash_set[[edge]] {
    var edges = std::hash_set[[edge]]::init();

    var iter_i = std::hash_set_iterator[[tile]]::init(tiles);
    for iter_i.advance() {
        var iter_j = std::hash_set_iterator[[tile]]::init(tiles);
        for iter_j.advance() {
            if hex::distance(iter_i.current().*.hex, iter_j.current().*.hex) != 1 {
                continue;
            }
            var edge = edge::init(*iter_i.current(), *iter_j.current());
            edges.insert(edge);
        }
    }

    return edges;
}

func main() void {
    var argparser = std::argument_parser::init((:[][]byte)[
        "debug",
        "fullscreen"
    ]);
    var opt_debug = false;
    var opt_fullscreen = false;
    for argparser.advance() {
        if argparser.check_option("debug") {
            opt_debug = true;
            continue;
        }
        if argparser.check_option("fullscreen") {
            opt_fullscreen = true;
            continue;
        }
    }

    SetTraceLogLevel(LOG_WARNING);
    SetConfigFlags(FLAG_MSAA_4X_HINT);
    InitWindow(800, 600, startof("NATAC"));
    defer CloseWindow();
    SetTargetFPS(60);
    if opt_fullscreen {
        ToggleFullscreen();
    }

    let RADIUS = 48.0f32;

    let PUBLIC_PIXEL_TTF = embed("assets/PublicPixel.ttf");
    let FONT_SIZE = 16.0f32;
    let FONT_NUMCHARS: sint = '~' - ' ' + 1; # Printable ASCII
    var font = LoadFontFromMemory(
        startof(".ttf"),
        (:*u8)startof(PUBLIC_PIXEL_TTF),
        (:sint)countof(PUBLIC_PIXEL_TTF),
        (:sint)FONT_SIZE,
        std::ptr[[sint]]::NULL,
        FONT_NUMCHARS);
    defer UnloadFont(font);

    var tiles = init_tiles();
    defer tiles.fini();
    var nodes = init_nodes(&tiles);
    defer nodes.fini();
    var edges = init_edges(&tiles);
    defer edges.fini();

    var debug = opt_debug;
    var camera_rotation = 0.0f32;

    for not WindowShouldClose() {
        if IsKeyPressed(KEY_F3) {
            debug = not debug;
        }
        if IsKeyPressed(KEY_F11) {
            ToggleFullscreen();
        }
        if IsKeyDown(KEY_Q) {
            camera_rotation = camera_rotation - 1.0;
        }
        if IsKeyDown(KEY_E) {
            camera_rotation = camera_rotation + 1.0;
        }
        if IsKeyDown(KEY_R) {
            camera_rotation = 0.0f32;
        }

        BeginDrawing();
        ClearBackground((:Color){.r = 0x66, .g = 0xBB, .b = 0xFF, .a = 0xFF});

        var render_w = GetRenderWidth();
        var render_h = GetRenderHeight();
        var render_center = (:Vector2){
            .x = (:f32)render_w / 2.0,
            .y = (:f32)render_h / 2.0,
        };
        var camera = (:Camera2D){
            .target = (:Vector2){
                .x = 0.0f32,
                .y = 0.0f32
            },
            .offset = render_center,
            .rotation = camera_rotation,
            .zoom = camera_zoom(RADIUS, (:f32)render_h),
        };

        BeginMode2D(camera);

        var iter = std::hash_set_iterator[[tile]]::init(&tiles);
        for iter.advance() {
            var tile = iter.current();
            var point = pointy_hex_to_point(tile.*.hex, RADIUS);
            draw_pointy_hexagon(point, RADIUS, tile.*.color());
            var resource = tile.*.resource();
            if resource.is_value() {
                let CIRCLE_RADIUS = RADIUS / 2.0;
                let TAN = (:Color){.r = 0xDD, .g = 0xBB, .b = 0x88, .a = 0xFF};
                draw_circle(point, CIRCLE_RADIUS, TAN);
                # Need a little bit extra radius so that all pixels of the
                # outline will cover up the number token circle.
                let CIRCLE_OUTLINE_RADIUS = CIRCLE_RADIUS + 1.0;
                let CIRCLE_OUTLINE_THICKNESS = CIRCLE_RADIUS / 8.0;
                draw_circle_outline(point, CIRCLE_OUTLINE_RADIUS, CIRCLE_OUTLINE_THICKNESS, BLACK);
                var size = measure_text_format(font, FONT_SIZE,
                    "{}",
                    (:[]std::formatter)[
                        std::formatter::init[[sint]](&tile.*.number_token)]);
                var number_color = BLACK;
                if tile.*.number_token == 6 or tile.*.number_token == 8 {
                    number_color = RED;
                }
                draw_text_format(font, FONT_SIZE, number_color,
                    (:Vector2){
                        .x = point.x - size.x / 2.0,
                        .y = point.y - size.y / 2.0
                    },
                    "{}",
                    (:[]std::formatter)[
                        std::formatter::init[[sint]](&tile.*.number_token)]);
            }
        }

        var mouse = GetMousePosition();
        var world = GetScreenToWorld2D(mouse, camera);
        var world_hex = point_to_pointy_hex(world, RADIUS);
        var world_hex_center = pointy_hex_to_point(world_hex, RADIUS);

        var world_tile = std::optional[[tile]]::EMPTY;
        var iter = std::hash_set_iterator[[tile]]::init(&tiles);
        for iter.advance() {
            if std::eq[[hex]](&iter.current().*.hex, &world_hex) {
                world_tile = std::optional[[tile]]::init_value(*iter.current());
                draw_pointy_hexagon_outline(world_hex_center, RADIUS, YELLOW);
                break;
            }
        }

        var world_edge = std::optional[[edge]]::EMPTY;
        var iter = std::hash_set_iterator[[edge]]::init(&edges);
        for iter.advance() {
            var found = true;
            for i in countof(iter.current().*.tiles) {
                let DISTANCE = RADIUS * 1.2;
                var hex = iter.current().*.tiles[i].hex;
                if vec2_distance(world, pointy_hex_to_point(hex, RADIUS)) > DISTANCE {
                    found = false;
                    break;
                }
            }

            if found {
                world_edge = std::optional[[edge]]::init_value(*iter.current());
                for i in countof(iter.current().*.tiles) {
                    var point = pointy_hex_to_point(iter.current().*.tiles[i].hex, RADIUS);
                    draw_pointy_hexagon_outline(point, RADIUS, ORANGE);
                }
                break;
            }
        }

        var world_node = std::optional[[node]]::EMPTY;
        var iter = std::hash_set_iterator[[node]]::init(&nodes);
        for iter.advance() {
            var found = true;
            for i in countof(iter.current().*.tiles) {
                let DISTANCE = RADIUS * 1.2;
                var hex = iter.current().*.tiles[i].hex;
                if vec2_distance(world, pointy_hex_to_point(hex, RADIUS)) > DISTANCE {
                    found = false;
                    break;
                }
            }

            if found {
                world_node = std::optional[[node]]::init_value(*iter.current());
                for i in countof(iter.current().*.tiles) {
                    var point = pointy_hex_to_point(iter.current().*.tiles[i].hex, RADIUS);
                    draw_pointy_hexagon_outline(point, RADIUS, RED);
                }
                break;
            }
        }

        var iter = std::hash_set_iterator[[tile]]::init(&tiles);
        for iter.advance() {
            var tile = iter.current();
            if tile.*.kind == ::tile::OCEAN {
                continue;
            }
            var point = pointy_hex_to_point(tile.*.hex, RADIUS);
            draw_pointy_hexagon_border(point, RADIUS, BLACK);
        }

        draw_circle(world_hex_center, 6.0, YELLOW);
        draw_circle_outline(world_hex_center, 6.0, 1.0, BLACK);
        if world_edge.is_value() {
            var world_edge = world_edge.value();
            var vertices_a = pointy_hex_vertices(world_edge.tiles[0].hex, RADIUS);
            var vertices_b = pointy_hex_vertices(world_edge.tiles[1].hex, RADIUS);
            for i in countof(vertices_a) {
                for j in countof(vertices_b) {
                    if vec2_feq(vertices_a[i], vertices_b[j]) {
                        draw_circle(vertices_a[i], 6.0, ORANGE);
                        draw_circle_outline(vertices_a[i], 6.0, 1.0, BLACK);
                    }
                }
            }
        }
        if world_node.is_value() {
            var world_node = world_node.value();
            var vertices_a = pointy_hex_vertices(world_node.tiles[0].hex, RADIUS);
            var vertices_b = pointy_hex_vertices(world_node.tiles[1].hex, RADIUS);
            var vertices_c = pointy_hex_vertices(world_node.tiles[2].hex, RADIUS);
            for i in countof(vertices_a) {
                for j in countof(vertices_b) {
                    for k in countof(vertices_c) {
                        if vec2_feq(vertices_a[i], vertices_b[j]) and vec2_feq(vertices_b[j], vertices_c[k]) {
                            draw_circle(vertices_a[i], 6.0, RED);
                            draw_circle_outline(vertices_a[i], 6.0, 1.0, BLACK);
                        }
                    }
                }
            }
        }

        EndMode2D();

        if debug {
            var fps = GetFPS();
            draw_text_format(font, FONT_SIZE, BLACK,
                (:Vector2){.x = 2.0, .y = 0.0},
                "FPS {}",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(fps)]](&fps)]);

            draw_text_format(font, FONT_SIZE, BLACK,
                (:Vector2){.x = 2.0, .y = 1.0 * FONT_SIZE},
                "MOUSE: x={.0}, y={.0}",
                (:[]std::formatter)[
                    std::formatter::init[[f32]](&mouse.x),
                    std::formatter::init[[f32]](&mouse.y)]);

            draw_text_format(font, FONT_SIZE, BLACK,
                (:Vector2){.x = 2.0, .y = 2.0 * FONT_SIZE},
                "WORLD: x={.0}, y={.0}",
                (:[]std::formatter)[
                    std::formatter::init[[f32]](&world.x),
                    std::formatter::init[[f32]](&world.y)]);

            draw_text_format(font, FONT_SIZE, BLACK,
                (:Vector2){.x = 2.0, .y = 3.0 * FONT_SIZE},
                "WORLD->HEX: q={}, r={}, s={}",
                (:[]std::formatter)[
                    std::formatter::init[[sint]](&world_hex.q),
                    std::formatter::init[[sint]](&world_hex.r),
                    std::formatter::init[[sint]](&world_hex.s)]);

            draw_text_format(font, FONT_SIZE, BLACK,
                (:Vector2){.x = 2.0, .y = 4.0 * FONT_SIZE},
                "WORLD->HEX->WORLD: x={.0}, y={.0}",
                (:[]std::formatter)[
                    std::formatter::init[[f32]](&world_hex_center.x),
                    std::formatter::init[[f32]](&world_hex_center.y)]);

            if world_tile.is_value() {
                var world_tile = world_tile.value();
                draw_text_format(font, FONT_SIZE, BLACK,
                    (:Vector2){.x = 2.0, .y = 5.0 * FONT_SIZE},
                    "TILE: {} {verbose}",
                    (:[]std::formatter)[
                        std::formatter::init[[hex]](&world_tile.hex),
                        std::formatter::init[[tile]](&world_tile)]);
            }
            else {
                draw_text(font, FONT_SIZE, BLACK,
                    (:Vector2){.x = 2.0, .y = 5.0 * FONT_SIZE},
                    "TILE: ocean");
            }

            if world_edge.is_value() {
                var world_edge = world_edge.value();
                draw_text_format(font, FONT_SIZE, BLACK,
                    (:Vector2){.x = 2.0, .y = 6.0 * FONT_SIZE},
                    "EDGE: {}",
                    (:[]std::formatter)[
                        std::formatter::init[[edge]](&world_edge)]);
            }
            else {
                draw_text(font, FONT_SIZE, BLACK,
                    (:Vector2){.x = 2.0, .y = 6.0 * FONT_SIZE},
                    "EDGE: none");
            }

            if world_node.is_value() {
                var world_node = world_node.value();
                draw_text_format(font, FONT_SIZE, BLACK,
                    (:Vector2){.x = 2.0, .y = 7.0 * FONT_SIZE},
                    "NODE: {}",
                    (:[]std::formatter)[
                        std::formatter::init[[node]](&world_node)]);
            }
            else {
                draw_text(font, FONT_SIZE, BLACK,
                    (:Vector2){.x = 2.0, .y = 7.0 * FONT_SIZE},
                    "NODE: none");
            }
        }

        EndDrawing();
    }
}
