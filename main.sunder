import "c";
import "raylib";
import "std";

import "client.sunder";
import "server.sunder";
import "shared.sunder";

struct local_client_message_sender {
    var server: *server_state;

    func send(self: *local_client_message_sender, message: *client_message) void {
        self.*.server.*.update_from_client_message(message);
    }
}

struct local_server_message_sender {
    var client: *client_state;

    func send(self: *local_server_message_sender, message: *server_message) void {
        self.*.client.*.update_from_server_message(message);
    }
}

func main() void {
    var argparser = std::argument_parser::init((:[][]byte)[
        "debug",
        "fullscreen"
    ]);
    var opt_debug = false;
    var opt_fullscreen = false;
    for argparser.advance() {
        if argparser.check_option("debug") {
            opt_debug = true;
            continue;
        }
        if argparser.check_option("fullscreen") {
            opt_fullscreen = true;
            continue;
        }
    }

    SetTraceLogLevel(LOG_WARNING);
    SetConfigFlags(FLAG_MSAA_4X_HINT);
    InitWindow(800, 600, startof("NATAC"));
    defer CloseWindow();
    SetTargetFPS(60);
    if opt_fullscreen {
        ToggleFullscreen();
    }

    var sstate = server_state::init();
    defer sstate.fini();
    var cstate = client_state::init();
    defer cstate.fini();
    cstate.debug = opt_debug;
    cstate.player = player::RED;

    var cmessage_sender = (:local_client_message_sender){.server = &sstate};
    var cmessage_sender = message_sender[[client_message]]::init[[local_client_message_sender]](&cmessage_sender);
    var smessage_sender = (:local_server_message_sender){.client = &cstate};
    var smessage_sender = message_sender[[server_message]]::init[[local_server_message_sender]](&smessage_sender);

    for not WindowShouldClose() {
        var message = sstate.to_server_message();
        smessage_sender.send(&message);
        message.fini();

        update(&cstate, &cmessage_sender);
        render(&cstate);
    }
}
