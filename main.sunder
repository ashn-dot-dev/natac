import "c";
import "raylib";
import "std";

# Hex position using the cube coordinate system satisfying q + r + s == 0.
struct hex {
    var q: sint;
    var r: sint;
    var s: sint;

    func init(q: sint, r: sint, s: sint) hex {
        assert q + r + s == 0;
        return (:hex){.q = q, .r = r, .s = s};
    }

    func init_round(q_fractional: f32, r_fractional: f32, s_fractional: f32) hex {
        var q_rounded = f32::round(q_fractional);
        var r_rounded = f32::round(r_fractional);
        var s_rounded = f32::round(s_fractional);

        var q_diff = f32::abs(q_rounded - q_fractional);
        var r_diff = f32::abs(r_rounded - r_fractional);
        var s_diff = f32::abs(s_rounded - s_fractional);

        var q = (:sint)q_rounded;
        var r = (:sint)r_rounded;
        var s = (:sint)s_rounded;
        if q_diff > r_diff and q_diff > s_diff {
            q = (:sint)-r_rounded - (:sint)s_rounded;
        }
        elif r_diff > s_diff {
            r = (:sint)-q_rounded - (:sint)s_rounded;
        }
        else {
            s = (:sint)-q_rounded - (:sint)r_rounded;
        }

        return hex::init(q, r, s);
    }

    func hash(self: *hex) usize {
        var h = self.*.q.hash() +% self.*.q.hash() +% self.*.s.hash();
        return h *% h;
    }

    func compare(lhs: *hex, rhs: *hex) ssize {
        var cmp = sint::cmp(lhs.*.q, rhs.*.q);
        if cmp != 0 {
            return cmp;
        }

        var cmp = sint::cmp(lhs.*.r, rhs.*.r);
        if cmp != 0 {
            return cmp;
        }

        var cmp = sint::cmp(lhs.*.s, rhs.*.s);
        if cmp != 0 {
            return cmp;
        }

        return 0;
    }

    func format(self: *hex, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            return std::write_format(
                writer,
                "(q={}, r={}, s={})",
                (:[]std::formatter)[
                    std::formatter::init[[sint]](&self.*.q),
                    std::formatter::init[[sint]](&self.*.r),
                    std::formatter::init[[sint]](&self.*.s)]);
        }

        return std::result[[void, std::error]]::init_value(void::VALUE);
    }

    func subtract(lhs: hex, rhs: hex) hex {
        return hex::init(lhs.q - rhs.q, lhs.r - rhs.r, lhs.s - rhs.s);
    }

    func distance(a: hex, b: hex) sint {
        var vec = hex::subtract(a, b);
        return (sint::abs(vec.q) + sint::abs(vec.r) + sint::abs(vec.s)) / 2;
    }
}

enum resource {
    BRICK;
    ORE;
    SHEEP;
    WHEAT;
    WOOD;

    func data(self: *resource) []byte {
        switch *self {
        BRICK {
            return "brick";
        }
        ORE {
            return "ore";
        }
        SHEEP {
            return "sheep";
        }
        WHEAT {
            return "wheat";
        }
        WOOD {
            return "wood";
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[[]byte]]();
    }

    func cstr(self: *resource) *byte {
        return startof(self.*.data());
    }

    func format(self: *resource, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            return std::write_all(writer, self.*.data());
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }
}

struct tile {
    var hex: hex;
    var kind: enum {
        DESERT;
        OCEAN;

        FOREST;
        FIELD;
        HILL;
        MOUNTAIN;
        PASTURE;
    };
    var number_token: sint;

    let SELF: tile = uninit;

    func init(hex: hex, kind: typeof(SELF.kind), number_token: sint) tile {
        return (:tile){
            .hex = hex,
            .kind = kind,
            .number_token = number_token,
        };
    }

    func hash(self: *tile) usize {
        return self.*.hex.hash();
    }

    func compare(lhs: *tile, rhs: *tile) ssize {
        return std::compare[[hex]](&lhs.*.hex, &rhs.*.hex);
    }

    func resource(self: *tile) std::optional[[::resource]] {
        switch self.*.kind {
        tile::DESERT or tile::OCEAN {
            return std::optional[[::resource]]::EMPTY;
        }
        tile::FOREST {
            return std::optional[[::resource]]::init_value(::resource::WOOD);
        }
        tile::FIELD {
            return std::optional[[::resource]]::init_value(::resource::WHEAT);
        }
        tile::HILL {
            return std::optional[[::resource]]::init_value(::resource::BRICK);
        }
        tile::MOUNTAIN {
            return std::optional[[::resource]]::init_value(::resource::ORE);
        }
        tile::PASTURE {
            return std::optional[[::resource]]::init_value(::resource::SHEEP);
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[std::optional[[::resource]]]]();
    }

    func color(self: *tile) Color {
        switch self.*.kind {
        tile::DESERT {
            return (:Color){.r = 0xEE, .g = 0xCC, .b = 0x88, .a = 0xFF};
        }
        tile::OCEAN {
            return (:Color){.r = 0x66, .g = 0xBB, .b = 0xFF, .a = 0xFF};
        }
        tile::FOREST {
            return (:Color){.r = 0x11, .g = 0x55, .b = 0x11, .a = 0xFF};
        }
        tile::FIELD {
            return (:Color){.r = 0xDD, .g = 0xAA, .b = 0x22, .a = 0xFF};
        }
        tile::HILL {
            return (:Color){.r = 0xCC, .g = 0x55, .b = 0x44, .a = 0xFF};
        }
        tile::MOUNTAIN {
            return (:Color){.r = 0x88, .g = 0x88, .b = 0x88, .a = 0xFF};
        }
        tile::PASTURE {
            return (:Color){.r = 0x66, .g = 0xAA, .b = 0x66, .a = 0xFF};
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[Color]]();
    }

    func format(self: *tile, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        var kind = "<error>";
        switch self.*.kind {
        tile::DESERT {
            kind = "desert";
        }
        tile::OCEAN {
            kind = "ocean";
        }
        tile::FOREST {
            kind = "forest";
        }
        tile::FIELD {
            kind = "field";
        }
        tile::HILL {
            kind = "hill";
        }
        tile::MOUNTAIN {
            kind = "mountain";
        }
        tile::PASTURE {
            kind = "pasture";
        }
        }

        if std::str::eq(fmt, "") {
            return std::write_all(writer, kind);
        }

        if std::str::eq(fmt, "verbose") {
            var resource = self.*.resource();
            if resource.is_empty() {
                return std::write_all(writer, kind);
            }

            var resource = resource.value();
            return std::write_format(
                writer,
                "{} ({}, {})",
                (:[]std::formatter)[
                    std::formatter::init[[[]byte]](&kind),
                    std::formatter::init[[::resource]](&resource),
                    std::formatter::init[[sint]](&self.*.number_token)]);
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }
}

struct edge {
    var hexes: [2]hex;

    func init(a: hex, b: hex) edge {
        assert hex::distance(a, b) == 1;

        var hexes = (:[2]hex)[a, b];
        std::sort[[hex]](hexes[0:countof(hexes)]);

        return (:edge){
            .hexes = hexes,
        };
    }

    func hash(self: *edge) usize {
        var hash = 0u;
        for i in countof(self.*.hexes) {
            hash = hash +% self.*.hexes[i].hash();
        }
        return hash;
    }

    func compare(lhs: *edge, rhs: *edge) ssize {
        var cmp = hex::compare(&lhs.*.hexes[0], &rhs.*.hexes[0]);
        if cmp != 0 {
            return cmp;
        }

        var cmp = hex::compare(&lhs.*.hexes[1], &rhs.*.hexes[1]);
        if cmp != 0 {
            return cmp;
        }

        return 0;
    }

    func format(self: *edge, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            for i in countof(self.*.hexes) {
                if i != 0 {
                    std::print(writer, ", ");
                }
                std::print_format(
                    writer,
                    "{}",
                    (:[]std::formatter)[
                        std::formatter::init[[hex]](&self.*.hexes[i])]);
            }

            return std::result[[void, std::error]]::init_value(void::VALUE);
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }
}

struct node {
    var hexes: [3]hex;

    func init(a: hex, b: hex, c: hex) node {
        assert hex::distance(a, b) == 1;
        assert hex::distance(b, c) == 1;
        assert hex::distance(c, a) == 1;

        var hexes = (:[3]hex)[a, b, c];
        std::sort[[hex]](hexes[0:countof(hexes)]);

        return (:node){
            .hexes = hexes,
        };
    }

    func hash(self: *node) usize {
        var hash = 0u;
        for i in countof(self.*.hexes) {
            hash = hash +% self.*.hexes[i].hash();
        }
        return hash;
    }

    func compare(lhs: *node, rhs: *node) ssize {
        var cmp = hex::compare(&lhs.*.hexes[0], &rhs.*.hexes[0]);
        if cmp != 0 {
            return cmp;
        }

        var cmp = hex::compare(&lhs.*.hexes[1], &rhs.*.hexes[1]);
        if cmp != 0 {
            return cmp;
        }

        var cmp = hex::compare(&lhs.*.hexes[2], &rhs.*.hexes[2]);
        if cmp != 0 {
            return cmp;
        }

        return 0;
    }

    func format(self: *node, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            for i in countof(self.*.hexes) {
                if i != 0 {
                    std::print(writer, ", ");
                }
                std::print_format(
                    writer,
                    "{}",
                    (:[]std::formatter)[
                        std::formatter::init[[hex]](&self.*.hexes[i])]);
            }

            return std::result[[void, std::error]]::init_value(void::VALUE);
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }
}

struct port {
    var hex: hex;
    var nodes: [2]node;
    var kind: enum {
        ANY;
        BRICK;
        ORE;
        SHEEP;
        WHEAT;
        WOOD;
    };

    let SELF: port = uninit;

    func init(hex: hex, a: node, b: node, kind: typeof(SELF.kind)) port {
        assert std::eq[[::hex]](&hex, &a.hexes[0])
            or std::eq[[::hex]](&hex, &a.hexes[1])
            or std::eq[[::hex]](&hex, &a.hexes[2]);
        assert std::eq[[::hex]](&hex, &b.hexes[0])
            or std::eq[[::hex]](&hex, &b.hexes[1])
            or std::eq[[::hex]](&hex, &b.hexes[2]);
        assert std::ne[[node]](&a, &b);

        var nodes = (:[2]node)[a, b];
        std::sort[[node]](nodes[0:countof(nodes)]);

        return (:port){
            .hex = hex,
            .nodes = nodes,
            .kind = kind,
        };
    }

    func hash(self: *port) usize {
        return self.*.hex.hash();
    }

    func compare(lhs: *port, rhs: *port) ssize {
        return std::compare[[hex]](&lhs.*.hex, &rhs.*.hex);
    }
}

struct road {
    var player: uint;
    var edge: edge;

    func init(player: uint, edge: edge) road {
        return (:road){
            .edge = edge,
            .player = player,
        };
    }

    func hash(self: *road) usize {
        return self.*.edge.hash();
    }

    func compare(lhs: *road, rhs: *road) ssize {
        return std::compare[[edge]](&lhs.*.edge, &rhs.*.edge);
    }
}

struct town {
    var player: uint;
    var node: node;
    var kind: enum {
        SETTLEMENT;
        CITY;
    };

    let SELF: town = uninit;

    func init(player: uint, node: node, kind: typeof(SELF.kind)) town {
        return (:town){
            .player = player,
            .node = node,
            .kind = kind,
        };
    }

    func hash(self: *town) usize {
        return self.*.node.hash();
    }

    func compare(lhs: *town, rhs: *town) ssize {
        return std::compare[[node]](&lhs.*.node, &rhs.*.node);
    }
}

func feq(a: f32, b: f32) bool {
    let THRESHOLD: f32 = 0.0001;
    return f32::abs(a - b) < THRESHOLD;
}

func lerp(a: f32, b: f32, t: f32) f32 {
    return a * (1.0 - t) + (b * t);
}

func vec2_feq(a: Vector2, b: Vector2) bool {
    return feq(a.x, b.x) and feq(a.y, b.y);
}

func vec2_lerp(a: Vector2, b: Vector2, t: f32) Vector2 {
    return (:Vector2){
        .x = lerp(a.x, b.x, t),
        .y = lerp(a.y, b.y, t),
    };
}

func vec2_distance(a: Vector2, b: Vector2) f32 {
    var x_dist = a.x - b.x;
    var y_dist = a.y - b.y;
    return f32::sqrt(x_dist * x_dist + y_dist * y_dist);
}

let PLAYER_RED: uint = 1;
let PLAYER_BLUE: uint = 2;
let PLAYER_WHITE: uint = 3;
let PLAYER_ORANGE: uint = 4;

func player_color(player: uint) Color {
    assert 1 <= player and player <= 4;
    return (:[4]Color)[
        RED,
        BLUE,
        WHITE,
        ORANGE,
    ][(:usize)player-1];
}

func point_to_pointy_hex(point: Vector2, radius: f32) hex {
    var q = (f32::sqrt(3.0)/3.0 * point.x - 1.0/3.0 * point.y) / radius;
    var r = (2.0/3.0 * point.y) / radius;
    var s = -q - r;

    return hex::init_round(q, r, s);
}

func pointy_hex_to_point(hex: hex, radius: f32) Vector2 {
    var x = radius * (f32::sqrt(3.0) * (:f32)hex.q + f32::sqrt(3.0)/2.0 * (:f32)hex.r);
    var y = radius * (3.0/2.0 * (:f32)hex.r);
    return (:Vector2){.x = x, .y = y};
}

func pointy_hex_vertices(hex: hex, radius: f32) [6]Vector2 {
    var result: [6]Vector2 = uninit;
    var center = pointy_hex_to_point(hex, radius);
    for i in 6 {
        var x = center.x + f32::cos(f32::degrees_to_radians((:f32)i * 360.0 / 6.0 + 30.0)) * radius;
        var y = center.y + f32::sin(f32::degrees_to_radians((:f32)i * 360.0 / 6.0 + 30.0)) * radius;
        result[i] = (:Vector2){.x = x, .y = y};
    }
    return result;
}

func edge_to_points(edge: edge, radius: f32) [2]Vector2 {
    var ret: [2]Vector2 = uninit;
    var cur = 0u;

    var vertices_a = pointy_hex_vertices(edge.hexes[0], radius);
    var vertices_b = pointy_hex_vertices(edge.hexes[1], radius);
    for i in countof(vertices_a) {
        for j in countof(vertices_b) {
            if vec2_feq(vertices_a[i], vertices_b[j]) {
                ret[cur] = vertices_a[i];
                cur = cur + 1;
            }
        }
    }

    return ret;
}

func node_to_point(node: node, radius: f32) Vector2 {
    var ret: Vector2 = uninit;

    var vertices_a = pointy_hex_vertices(node.hexes[0], radius);
    var vertices_b = pointy_hex_vertices(node.hexes[1], radius);
    var vertices_c = pointy_hex_vertices(node.hexes[2], radius);
    for i in countof(vertices_a) {
        for j in countof(vertices_b) {
            for k in countof(vertices_c) {
                if vec2_feq(vertices_a[i], vertices_b[j]) and vec2_feq(vertices_b[j], vertices_c[k]) {
                    ret = vertices_a[i];
                    break;
                }
            }
        }
    }

    return ret;
}

func draw_pointy_hexagon(center: Vector2, radius: f32, color: Color) void {
    let SIDES: sint = 6;
    let ANGLE: f32 = 30.0; # pointy-top orientation
    DrawPoly(center, SIDES, radius, ANGLE, color);
}

func draw_pointy_hexagon_outline(center: Vector2, radius: f32, color: Color) void {
    let SIDES: sint = 6;
    let ANGLE: f32 = 30.0; # pointy-top orientation
    DrawPolyLinesEx(center, SIDES, radius, ANGLE, radius / 8.0, color);
}

func draw_pointy_hexagon_border(center: Vector2, radius: f32, color: Color) void {
    let SIDES: sint = 6;
    let ANGLE: f32 = 30.0; # pointy-top orientation
    var thick: f32 = radius / 16.0;
    DrawPolyLinesEx(center, SIDES, radius + thick / 2.0, ANGLE, thick, color);
}

func draw_circle(center: Vector2, radius: f32, color: Color) void {
    DrawCircleV(center, radius, color);
}

func draw_circle_outline(center: Vector2, radius: f32, thickness: f32, color: Color) void {
    let SIDES: sint = 36;
    let ANGLE: f32 = 0.0;
    DrawPolyLinesEx(center, SIDES, radius, ANGLE, thickness, color);
}

func draw_number_token(center: Vector2, number: sint, radius: f32, font: Font) void {
    var CIRCLE_RADIUS = radius / 2.0;
    let TAN = (:Color){.r = 0xDD, .g = 0xBB, .b = 0x88, .a = 0xFF};
    draw_circle(center, CIRCLE_RADIUS, TAN);
    # Need a little bit extra radius so that all pixels of the
    # outline will cover up the number token circle.
    var CIRCLE_OUTLINE_RADIUS = CIRCLE_RADIUS + 1.0;
    var CIRCLE_OUTLINE_THICKNESS = CIRCLE_RADIUS / 8.0;
    draw_circle_outline(center, CIRCLE_OUTLINE_RADIUS, CIRCLE_OUTLINE_THICKNESS, BLACK);

    var font_size = radius / 3.0;
    var size = measure_text_format(font, font_size,
        "{}",
        (:[]std::formatter)[
            std::formatter::init[[sint]](&number)]);
    var color = BLACK;
    if number == 6 or number == 8 {
        color = RED;
    }
    draw_text_format(font, font_size, color,
        (:Vector2){
            .x = center.x - size.x / 2.0,
            .y = center.y - size.y / 2.0,
        },
        "{}",
        (:[]std::formatter)[
            std::formatter::init[[sint]](&number)]);

    assert 2 <= number and number <= 12;
    let DOTS = (:[]usize)[
        0, # 0 (invalid)
        0, # 1 (invalid)
        1, # 2
        2, # 3
        3, # 4
        4, # 5
        5, # 6
        0, # 7 (invalid)
        5, # 8
        4, # 9
        3, # 10
        2, # 11
        1, # 12
    ];
    var distance = CIRCLE_RADIUS / 3.6;
    var width = (:f32)DOTS[(:usize)number] * distance;
    for i in DOTS[(:usize)number] {
        var position = (:Vector2){
            .x = center.x - width / 2.0 + distance * ((:f32)i + 0.5),
            .y = center.y + CIRCLE_RADIUS / 2.0,
        };
        draw_circle(position, distance / 4.0, color);
    }
}

func draw_port(port: port, radius: f32, font: Font) void {
    var center = pointy_hex_to_point(port.hex, radius);

    var a = node_to_point(port.nodes[0], radius);
    var b = node_to_point(port.nodes[1], radius);
    var thick: f32 = radius / 8.0;
    DrawLineEx(vec2_lerp(center, a, 0.49), vec2_lerp(center, a, 0.91), thick + 1.0, BLACK);
    DrawLineEx(vec2_lerp(center, a, 0.50), vec2_lerp(center, a, 0.90), thick, BROWN);
    DrawLineEx(vec2_lerp(center, b, 0.49), vec2_lerp(center, b, 0.91), thick + 1.0, BLACK);
    DrawLineEx(vec2_lerp(center, b, 0.50), vec2_lerp(center, b, 0.90), thick, BROWN);

    var text = "<error>";
    switch port.kind {
    ::port::ANY {
        text = "3:1";
    }
    ::port::BRICK {
        text = "brick 2:1";
    }
    ::port::ORE {
        text = "ore 2:1";
    }
    ::port::SHEEP {
        text = "sheep 2:1";
    }
    ::port::WHEAT {
        text = "wheat 2:1";
    }
    ::port::WOOD {
        text = "wood 2:1";
    }
    }
    var font_size = radius / 6.0;
    var size = measure_text_cstr(font, font_size, startof(text));
    var position = (:Vector2){.x = center.x - size.x / 2.0, .y = center.y - size.y / 2.0};
    draw_text_cstr(font, font_size, BLACK, position, startof(text));
}

func draw_road(a: Vector2, b: Vector2, radius: f32, color: Color) void {
    var thick: f32 = radius / 8.0;
    DrawLineEx(vec2_lerp(a, b, 0.09), vec2_lerp(a, b, 0.91), thick + 1.0, BLACK);
    DrawLineEx(vec2_lerp(a, b, 0.10), vec2_lerp(a, b, 0.90), thick, color);
}

func draw_settlement(center: Vector2, radius: f32, color: Color) void {
    var center = (:Vector2){
        .x = center.x,
        .y = center.y - radius / 8.0f32, # y-offset
    };
    var size = (:Vector2){
        .x = radius / 3.0,
        .y = radius / 4.0,
    };

    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0 - 1.0, .y = center.y},
        (:Vector2){.x = size.x + 2.0, .y = size.y + 1.0},
        BLACK);
    DrawTriangle(
        (:Vector2){.x = center.x - size.x / 2.0 - 1.2, .y = center.y},
        (:Vector2){.x = center.x + size.x / 2.0 + 1.2, .y = center.y},
        (:Vector2){.x = center.x, .y = center.y - size.y / 2.0 - 1.25},
        BLACK);

    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0, .y = center.y},
        (:Vector2){.x = size.x, .y = size.y},
        color);
    DrawTriangle(
        (:Vector2){.x = center.x - size.x / 2.0, .y = center.y},
        (:Vector2){.x = center.x + size.x / 2.0, .y = center.y},
        (:Vector2){.x = center.x, .y = center.y - size.y / 2.0},
        color);
}

func draw_city(center: Vector2, radius: f32, color: Color) void {
    var center = (:Vector2){
        .x = center.x,
        .y = center.y - radius / 8.0f32, # y-offset
    };
    var size = (:Vector2){
        .x = radius / 2.2,
        .y = radius / 4.0,
    };

    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0 - 1.0, .y = center.y - 1.0},
        (:Vector2){.x = size.x + 2.0, .y = size.y + 2.0},
        BLACK);
    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0 - 1.0, .y = center.y - size.y / 2.0},
        (:Vector2){.x = size.x / 2.0 + 2.0, .y = size.y / 2.0 + 1.0},
        BLACK);
    DrawTriangle(
        (:Vector2){.x = center.x - size.x / 2.0 - 1.0, .y = center.y - size.y / 2.0},
        (:Vector2){.x = center.x + 1.0, .y = center.y - size.y / 2.0},
        (:Vector2){.x = center.x - size.x / 4.0, .y = center.y - size.y - 1.0},
        BLACK);

    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0, .y = center.y},
        (:Vector2){.x = size.x, .y = size.y},
        color);
    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0, .y = center.y - size.y / 2.0},
        (:Vector2){.x = size.x / 2.0, .y = size.y / 2.0},
        color);
    DrawTriangle(
        (:Vector2){.x = center.x - size.x / 2.0, .y = center.y - size.y / 2.0},
        (:Vector2){.x = center.x, .y = center.y - size.y / 2.0},
        (:Vector2){.x = center.x - size.x / 4.0, .y = center.y - size.y},
        color);
}

func draw_robber(center: Vector2, radius: f32) void {
    var radius_h = radius / 6.0;
    var radius_v = radius / 3.0;
    var size = (:Vector2){
        .x = radius_h * 2.0,
        .y = radius_v / 2.0,
    };

    let COLOR = BLACK;
    DrawEllipse(
        (:sint)center.x,
        (:sint)center.y,
        radius_h + 1.0,
        radius_v + 1.0,
        COLOR);
    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0 - 1.0, .y = center.y + radius_v - size.y / 2.0 - 1.0},
        (:Vector2){.x = size.x + 2.0, .y = size.y + 2.0},
        COLOR);
    DrawCircleV(
        (:Vector2){.x = center.x, .y = center.y - radius_v},
        radius_h * 0.9 + 1.0,
        COLOR);

    let COLOR = GRAY;
    DrawEllipse(
        (:sint)center.x,
        (:sint)center.y,
        radius_h,
        radius_v,
        COLOR);
    DrawRectangleV(
        (:Vector2){.x = center.x - size.x / 2.0, .y = center.y + radius_v - size.y / 2.0},
        (:Vector2){.x = size.x, .y = size.y},
        COLOR);
    DrawCircleV(
        (:Vector2){.x = center.x, .y = center.y - radius_v},
        radius_h * 0.9,
        COLOR);
}

func measure_text(font: Font, size: f32, text: []byte) Vector2 {
    var s = std::string::init_from_str(text);
    defer s.fini();

    let SPACING = 0.0f32;
    return MeasureTextEx(font, s.cstr(), size, SPACING);
}

func draw_text(font: Font, size: f32, color: Color, position: Vector2, text: []byte) void {
    var s = std::string::init_from_str(text);
    defer s.fini();

    let SPACING = 0.0f32;
    DrawTextEx(font, s.cstr(), position, size, SPACING, color);
}

func measure_text_cstr(font: Font, size: f32, text: *byte) Vector2 {
    let SPACING = 0.0f32;
    return MeasureTextEx(font, text, size, SPACING);
}

func draw_text_cstr(font: Font, size: f32, color: Color, position: Vector2, text: *byte) void {
    let SPACING = 0.0f32;
    DrawTextEx(font, text, position, size, SPACING, color);
}

func measure_text_format(font: Font, size: f32, format: []byte, args: []std::formatter) Vector2 {
    var s = std::string::init_from_format(format, args);
    defer s.fini();

    let SPACING = 0.0f32;
    return MeasureTextEx(font, s.cstr(), size, SPACING);
}

func draw_text_format(font: Font, size: f32, color: Color, position: Vector2, format: []byte, args: []std::formatter) void {
    var s = std::string::init_from_format(format, args);
    defer s.fini();

    let SPACING = 0.0f32;
    DrawTextEx(font, s.cstr(), position, size, SPACING, color);
}

func camera_zoom(radius: f32, h: f32) f32 {
    # Return a camera zoom such that the board and board-adjacent ocean tiles
    # fit on the screen. Approximate the length of the board and board-adjacent
    # ocean tiles as six tile diameters (five board tiles plus two ocean tiles
    # on either side minus one tile to somewhat account for radius overlap).
    return h / (6.0 * 2.0 * radius);
}

func init_tiles() std::hash_set[[tile]] {
    var tiles = std::hash_set[[tile]]::init();

    # top row
    tiles.insert(tile::init(hex::init(+0, -2, +2), tile::MOUNTAIN, 10));
    tiles.insert(tile::init(hex::init(+1, -2, +1), tile::PASTURE, 2));
    tiles.insert(tile::init(hex::init(+2, -2, +0), tile::FOREST, 9));
    # top-middle row
    tiles.insert(tile::init(hex::init(-1, -1, +2), tile::FIELD, 12));
    tiles.insert(tile::init(hex::init(+0, -1, +1), tile::HILL, 6));
    tiles.insert(tile::init(hex::init(+1, -1, +0), tile::PASTURE, 4));
    tiles.insert(tile::init(hex::init(+2, -1, -1), tile::HILL, 10));
    # middle row
    tiles.insert(tile::init(hex::init(-2, +0, +2), tile::FIELD, 9));
    tiles.insert(tile::init(hex::init(-1, +0, +1), tile::FOREST, 11));
    tiles.insert(tile::init(hex::init(+0, +0, +0), tile::DESERT, -1));
    tiles.insert(tile::init(hex::init(+1, +0, -1), tile::FOREST, 3));
    tiles.insert(tile::init(hex::init(+2, +0, -2), tile::MOUNTAIN, 8));
    # bottom-middle row
    tiles.insert(tile::init(hex::init(-2, +1, +1), tile::FOREST, 8));
    tiles.insert(tile::init(hex::init(-1, +1, +0), tile::MOUNTAIN, 3));
    tiles.insert(tile::init(hex::init(+0, +1, -1), tile::FIELD, 4));
    tiles.insert(tile::init(hex::init(+1, +1, -2), tile::PASTURE, 5));
    # bottom row
    tiles.insert(tile::init(hex::init(-2, +2, +0), tile::HILL, 5));
    tiles.insert(tile::init(hex::init(-1, +2, -1), tile::FIELD, 6));
    tiles.insert(tile::init(hex::init(+0, +2, -2), tile::PASTURE, 11));
    # adjacent ocean
    tiles.insert(tile::init(hex::init(+0, -3, +3), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(+1, -3, +2), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(+2, -3, +1), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(+3, -3, +0), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(-1, -2, +3), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(+3, -2, -1), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(-2, -1, +3), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(+3, -1, -2), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(-3, +0, +3), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(+3, +0, -3), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(-3, +1, +2), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(+2, +1, -3), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(-3, +2, +1), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(+1, +2, -3), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(-3, +3, +0), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(-2, +3, -1), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(-1, +3, -2), tile::OCEAN, -1));
    tiles.insert(tile::init(hex::init(+0, +3, -3), tile::OCEAN, -1));

    return tiles;
}

func init_nodes(tiles: *std::hash_set[[tile]]) std::hash_set[[node]] {
    var nodes = std::hash_set[[node]]::init();

    var iter_i = std::hash_set_iterator[[tile]]::init(tiles);
    for iter_i.advance() {
        var iter_j = std::hash_set_iterator[[tile]]::init(tiles);
        for iter_j.advance() {
            var iter_k = std::hash_set_iterator[[tile]]::init(tiles);
            for iter_k.advance() {
                if hex::distance(iter_i.current().*.hex, iter_j.current().*.hex) != 1 {
                    continue;
                }
                if hex::distance(iter_j.current().*.hex, iter_k.current().*.hex) != 1 {
                    continue;
                }
                if hex::distance(iter_k.current().*.hex, iter_i.current().*.hex) != 1 {
                    continue;
                }
                var node = node::init(
                    iter_i.current().*.hex,
                    iter_j.current().*.hex,
                    iter_k.current().*.hex);
                nodes.insert(node);
            }
        }
    }

    return nodes;
}

func init_edges(tiles: *std::hash_set[[tile]]) std::hash_set[[edge]] {
    var edges = std::hash_set[[edge]]::init();

    var iter_i = std::hash_set_iterator[[tile]]::init(tiles);
    for iter_i.advance() {
        var iter_j = std::hash_set_iterator[[tile]]::init(tiles);
        for iter_j.advance() {
            if hex::distance(iter_i.current().*.hex, iter_j.current().*.hex) != 1 {
                continue;
            }
            var edge = edge::init(
                iter_i.current().*.hex,
                iter_j.current().*.hex);
            edges.insert(edge);
        }
    }

    return edges;
}

func init_ports() std::hash_set[[port]] {
    var ports = std::hash_set[[port]]::init();

    ports.insert(port::init(
        hex::init(+3, +0, -3),
        node::init(
            hex::init(+2, +0, -2),
            hex::init(+2, +1, -3),
            hex::init(+3, +0, -3)),
        node::init(
            hex::init(+2, +0, -2),
            hex::init(+3, -1, -2),
            hex::init(+3, +0, -3)),
        port::ANY));

    ports.insert(port::init(
        hex::init(+3, -2, -1),
        node::init(
            hex::init(+2, -2, +0),
            hex::init(+2, -1, -1),
            hex::init(+3, -2, -1)),
        node::init(
            hex::init(+2, -1, -1),
            hex::init(+3, -2, -1),
            hex::init(+3, -1, -2)),
        port::ORE));

    ports.insert(port::init(
        hex::init(+2, -3, +1),
        node::init(
            hex::init(+1, -3, +2),
            hex::init(+1, -2, +1),
            hex::init(+2, -3, +1)),
        node::init(
            hex::init(+1, -2, +1),
            hex::init(+2, -3, +1),
            hex::init(+2, -2, +0)),
        port::WHEAT));

    ports.insert(port::init(
        hex::init(+0, -3, +3),
        node::init(
            hex::init(-1, -2, +3),
            hex::init(+0, -3, +3),
            hex::init(+0, -2, +2)),
        node::init(
            hex::init(+0, -3, +3),
            hex::init(+0, -2, +2),
            hex::init(+1, -3, +2)),
        port::ANY));

    ports.insert(port::init(
        hex::init(-2, -1, +3),
        node::init(
            hex::init(-2, -1, +3),
            hex::init(-2, +0, +2),
            hex::init(-1, -1, +2)),
        node::init(
            hex::init(-2, -1, +3),
            hex::init(-1, -2, +3),
            hex::init(-1, -1, +2)),
        port::WOOD));

    ports.insert(port::init(
        hex::init(-3, +1, +2),
        node::init(
            hex::init(-3, +1, +2),
            hex::init(-3, +2, +1),
            hex::init(-2, +1, +1)),
        node::init(
            hex::init(-3, +1, +2),
            hex::init(-2, +0, +2),
            hex::init(-2, +1, +1)),
        port::BRICK));

    ports.insert(port::init(
        hex::init(-3, +3, +0),
        node::init(
            hex::init(-3, +2, +1),
            hex::init(-3, +3, +0),
            hex::init(-2, +2, +0)),
        node::init(
            hex::init(-3, +3, +0),
            hex::init(-2, +2, +0),
            hex::init(-2, +3, -1)),
        port::ANY));

    ports.insert(port::init(
        hex::init(-1, +3, -2),
        node::init(
            hex::init(-2, +3, -1),
            hex::init(-1, +2, -1),
            hex::init(-1, +3, -2)),
        node::init(
            hex::init(-1, +2, -1),
            hex::init(-1, +3, -2),
            hex::init(+0, +2, -2)),
        port::ANY));

    ports.insert(port::init(
        hex::init(+1, +2, -3),
        node::init(
            hex::init(+0, +2, -2),
            hex::init(+1, +1, -2),
            hex::init(+1, +2, -3)),
        node::init(
            hex::init(+1, +1, -2),
            hex::init(+1, +2, -3),
            hex::init(+2, +1, -3)),
        port::SHEEP));

    return ports;
}

func main() void {
    var argparser = std::argument_parser::init((:[][]byte)[
        "debug",
        "fullscreen"
    ]);
    var opt_debug = false;
    var opt_fullscreen = false;
    for argparser.advance() {
        if argparser.check_option("debug") {
            opt_debug = true;
            continue;
        }
        if argparser.check_option("fullscreen") {
            opt_fullscreen = true;
            continue;
        }
    }

    SetTraceLogLevel(LOG_WARNING);
    SetConfigFlags(FLAG_MSAA_4X_HINT);
    InitWindow(800, 600, startof("NATAC"));
    defer CloseWindow();
    SetTargetFPS(60);
    if opt_fullscreen {
        ToggleFullscreen();
    }

    let RADIUS = 48.0f32;

    let PUBLIC_PIXEL_TTF = embed("assets/PublicPixel.ttf");
    let FONT_SIZE = 16.0f32;
    let FONT_NUMCHARS: sint = '~' - ' ' + 1; # Printable ASCII
    var font = LoadFontFromMemory(
        startof(".ttf"),
        (:*u8)startof(PUBLIC_PIXEL_TTF),
        (:sint)countof(PUBLIC_PIXEL_TTF),
        (:sint)FONT_SIZE,
        std::ptr[[sint]]::NULL,
        FONT_NUMCHARS);
    defer UnloadFont(font);

    var tiles = init_tiles();
    defer tiles.fini();
    var nodes = init_nodes(&tiles);
    defer nodes.fini();
    var edges = init_edges(&tiles);
    defer edges.fini();
    var ports = init_ports();
    defer ports.fini();

    var robber = hex::init(+0, +0, +0);
    var roads = std::vector[[road]]::init();
    defer roads.fini();
    var towns = std::vector[[town]]::init();
    defer towns.fini();

    # Red starting position.
    towns.push(town::init(
        PLAYER_RED,
        node::init(
            hex::init(-2, +0, +2),
            hex::init(-2, +1, +1),
            hex::init(-1, +0, +1)),
        town::SETTLEMENT));
    roads.push(road::init(
        PLAYER_RED,
        edge::init(
            hex::init(-2, +1, +1),
            hex::init(-1, +0, +1))));
    towns.push(town::init(
        PLAYER_RED,
        node::init(
            hex::init(+0, -2, +2),
            hex::init(+0, -1, +1),
            hex::init(+1, -2, +1)),
        town::SETTLEMENT));
    roads.push(road::init(
        PLAYER_RED,
        edge::init(
            hex::init(+0, -1, +1),
            hex::init(+1, -2, +1))));
    # Blue starting position.
    towns.push(town::init(
        PLAYER_BLUE,
        node::init(
            hex::init(-2, +1, +1),
            hex::init(-2, +2, +0),
            hex::init(-1, +1, +0)),
        town::SETTLEMENT));
    roads.push(road::init(
        PLAYER_BLUE,
        edge::init(
            hex::init(-2, +2, +0),
            hex::init(-1, +1, +0))));
    towns.push(town::init(
        PLAYER_BLUE,
        node::init(
            hex::init(+0, +1, -1),
            hex::init(+0, +2, -2),
            hex::init(+1, +1, -2)),
        town::SETTLEMENT));
    roads.push(road::init(
        PLAYER_BLUE,
        edge::init(
            hex::init(+0, +1, -1),
            hex::init(+1, +1, -2))));
    # White starting position.
    towns.push(town::init(
        PLAYER_WHITE,
        node::init(
            hex::init(-1, -1, +2),
            hex::init(-1, +0, +1),
            hex::init(+0, -1, +1)),
        town::SETTLEMENT));
    roads.push(road::init(
        PLAYER_WHITE,
        edge::init(
            hex::init(-1, -1, +2),
            hex::init(-1, +0, +1))));
    towns.push(town::init(
        PLAYER_WHITE,
        node::init(
            hex::init(+1, +0, -1),
            hex::init(+1, +1, -2),
            hex::init(+2, +0, -2)),
        town::SETTLEMENT));
    roads.push(road::init(
        PLAYER_WHITE,
        edge::init(
            hex::init(+1, +0, -1),
            hex::init(+2, +0, -2))));
    # Orange starting position.
    towns.push(town::init(
        PLAYER_ORANGE,
        node::init(
            hex::init(-1, +1, +0),
            hex::init(-1, +2, -1),
            hex::init(+0, +1, -1)),
        town::SETTLEMENT));
    roads.push(road::init(
        PLAYER_ORANGE,
        edge::init(
            hex::init(-1, +2, -1),
            hex::init(+0, +1, -1))));
    towns.push(town::init(
        PLAYER_ORANGE,
        node::init(
            hex::init(+1, -1, +0),
            hex::init(+2, -2, +0),
            hex::init(+2, -1, -1)),
        town::SETTLEMENT));
    roads.push(road::init(
        PLAYER_ORANGE,
        edge::init(
            hex::init(+1, -1, +0),
            hex::init(+2, -2, +0))));

    var debug = opt_debug;
    var player = PLAYER_RED;

    for not WindowShouldClose() {
        if IsKeyPressed(KEY_F3) {
            debug = not debug;
        }
        if IsKeyPressed(KEY_F11) {
            ToggleFullscreen();
        }

        if IsKeyPressed(KEY_ONE) {
            player = PLAYER_RED;
        }
        if IsKeyPressed(KEY_TWO) {
            player = PLAYER_BLUE;
        }
        if IsKeyPressed(KEY_THREE) {
            player = PLAYER_WHITE;
        }
        if IsKeyPressed(KEY_FOUR) {
            player = PLAYER_ORANGE;
        }

        BeginDrawing();
        ClearBackground((:Color){.r = 0x66, .g = 0xBB, .b = 0xFF, .a = 0xFF});

        var render_w = GetRenderWidth();
        var render_h = GetRenderHeight();
        var render_center = (:Vector2){
            .x = (:f32)render_w / 2.0,
            .y = (:f32)render_h / 2.0,
        };
        var camera = (:Camera2D){
            .target = (:Vector2){
                .x = 0.0f32,
                .y = 0.0f32
            },
            .offset = render_center,
            .rotation = 0.0f32,
            .zoom = camera_zoom(RADIUS, (:f32)render_h),
        };

        BeginMode2D(camera);

        var iter = std::hash_set_iterator[[tile]]::init(&tiles);
        for iter.advance() {
            var tile = iter.current();
            var point = pointy_hex_to_point(tile.*.hex, RADIUS);
            draw_pointy_hexagon(point, RADIUS, tile.*.color());
            var resource = tile.*.resource();
            if resource.is_value() {
                draw_number_token(point, tile.*.number_token, RADIUS, font);
            }
        }

        var mouse = GetMousePosition();
        var world = GetScreenToWorld2D(mouse, camera);
        var world_hex = point_to_pointy_hex(world, RADIUS);
        var world_hex_center = pointy_hex_to_point(world_hex, RADIUS);

        var world_tile = std::optional[[tile]]::EMPTY;
        var iter = std::hash_set_iterator[[tile]]::init(&tiles);
        for iter.advance() {
            if std::eq[[hex]](&iter.current().*.hex, &world_hex) {
                world_tile = std::optional[[tile]]::init_value(*iter.current());
                draw_pointy_hexagon_outline(world_hex_center, RADIUS, YELLOW);
                break;
            }
        }

        var world_edge = std::optional[[edge]]::EMPTY;
        var iter = std::hash_set_iterator[[edge]]::init(&edges);
        for iter.advance() {
            var found = true;
            for i in countof(iter.current().*.hexes) {
                let DISTANCE = RADIUS * 1.2;
                var hex = iter.current().*.hexes[i];
                if vec2_distance(world, pointy_hex_to_point(hex, RADIUS)) > DISTANCE {
                    found = false;
                    break;
                }
            }

            if found {
                world_edge = std::optional[[edge]]::init_value(*iter.current());
                for i in countof(iter.current().*.hexes) {
                    var point = pointy_hex_to_point(iter.current().*.hexes[i], RADIUS);
                    draw_pointy_hexagon_outline(point, RADIUS, ORANGE);
                }
                break;
            }
        }

        var world_node = std::optional[[node]]::EMPTY;
        var iter = std::hash_set_iterator[[node]]::init(&nodes);
        for iter.advance() {
            var found = true;
            for i in countof(iter.current().*.hexes) {
                let DISTANCE = RADIUS * 1.2;
                var hex = iter.current().*.hexes[i];
                if vec2_distance(world, pointy_hex_to_point(hex, RADIUS)) > DISTANCE {
                    found = false;
                    break;
                }
            }

            if found {
                world_node = std::optional[[node]]::init_value(*iter.current());
                for i in countof(iter.current().*.hexes) {
                    var point = pointy_hex_to_point(iter.current().*.hexes[i], RADIUS);
                    draw_pointy_hexagon_outline(point, RADIUS, RED);
                }
                break;
            }
        }

        if world_node.is_value() and IsMouseButtonPressed(MOUSE_BUTTON_LEFT) {
            towns.push(town::init(
                player,
                world_node.value(),
                town::SETTLEMENT));
        }
        elif world_node.is_value() and IsMouseButtonPressed(MOUSE_BUTTON_RIGHT) {
            towns.push(town::init(
                player,
                world_node.value(),
                town::CITY));
        }
        elif world_edge.is_value() and IsMouseButtonPressed(MOUSE_BUTTON_LEFT) {
            roads.push(road::init(
                player,
                world_edge.value()));
        }

        var iter = std::hash_set_iterator[[tile]]::init(&tiles);
        for iter.advance() {
            var tile = iter.current();
            if tile.*.kind == ::tile::OCEAN {
                continue;
            }
            var point = pointy_hex_to_point(tile.*.hex, RADIUS);
            draw_pointy_hexagon_border(point, RADIUS, BLACK);
        }

        var iter = std::hash_set_iterator[[port]]::init(&ports);
        for iter.advance() {
            var port = iter.current();
            draw_port(*port, RADIUS, font);
        }

        var iter = std::slice_iterator[[road]]::init(roads.data());
        for iter.advance() {
            var road = iter.current();
            var points = edge_to_points(road.*.edge, RADIUS);
            draw_road(points[0], points[1], RADIUS, player_color(road.*.player));
        }

        var iter = std::slice_iterator[[town]]::init(towns.data());
        for iter.advance() {
            var town = iter.current();
            switch town.*.kind {
            ::town::SETTLEMENT {
                draw_settlement(node_to_point(town.*.node, RADIUS), RADIUS, player_color(town.*.player));
            }
            ::town::CITY {
                draw_city(node_to_point(town.*.node, RADIUS), RADIUS, player_color(town.*.player));
            }
            }
        }

        if world_node.is_value() {
            var world_node = world_node.value();
            var world_node_point = node_to_point(world_node, RADIUS);
            draw_circle(world_node_point, 6.0, RED);
            draw_circle_outline(world_node_point, 6.0, 1.0, BLACK);
        }
        elif world_edge.is_value() {
            var world_edge = world_edge.value();
            var points = edge_to_points(world_edge, RADIUS);
            draw_circle(points[0], 6.0, ORANGE);
            draw_circle(points[1], 6.0, ORANGE);
            draw_circle_outline(points[0], 6.0, 1.0, BLACK);
            draw_circle_outline(points[1], 6.0, 1.0, BLACK);
        }
        else {
            draw_circle(world_hex_center, 6.0, YELLOW);
            draw_circle_outline(world_hex_center, 6.0, 1.0, BLACK);
        }

        draw_robber(pointy_hex_to_point(robber, RADIUS), RADIUS);

        EndMode2D();

        if debug {
            var fps = GetFPS();
            draw_text_format(font, FONT_SIZE, BLACK,
                (:Vector2){.x = 2.0, .y = 0.0},
                "FPS {}",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(fps)]](&fps)]);

            draw_text_format(font, FONT_SIZE, BLACK,
                (:Vector2){.x = 2.0, .y = 1.0 * FONT_SIZE},
                "MOUSE: x={.0}, y={.0}",
                (:[]std::formatter)[
                    std::formatter::init[[f32]](&mouse.x),
                    std::formatter::init[[f32]](&mouse.y)]);

            draw_text_format(font, FONT_SIZE, BLACK,
                (:Vector2){.x = 2.0, .y = 2.0 * FONT_SIZE},
                "WORLD: x={.0}, y={.0}",
                (:[]std::formatter)[
                    std::formatter::init[[f32]](&world.x),
                    std::formatter::init[[f32]](&world.y)]);

            draw_text_format(font, FONT_SIZE, BLACK,
                (:Vector2){.x = 2.0, .y = 3.0 * FONT_SIZE},
                "WORLD->HEX: q={}, r={}, s={}",
                (:[]std::formatter)[
                    std::formatter::init[[sint]](&world_hex.q),
                    std::formatter::init[[sint]](&world_hex.r),
                    std::formatter::init[[sint]](&world_hex.s)]);

            draw_text_format(font, FONT_SIZE, BLACK,
                (:Vector2){.x = 2.0, .y = 4.0 * FONT_SIZE},
                "WORLD->HEX->WORLD: x={.0}, y={.0}",
                (:[]std::formatter)[
                    std::formatter::init[[f32]](&world_hex_center.x),
                    std::formatter::init[[f32]](&world_hex_center.y)]);

            if world_node.is_value() {
                var world_node = world_node.value();
                draw_text_format(font, FONT_SIZE, BLACK,
                    (:Vector2){.x = 2.0, .y = 5.0 * FONT_SIZE},
                    "NODE: {}",
                    (:[]std::formatter)[
                        std::formatter::init[[node]](&world_node)]);
            }
            elif world_edge.is_value() {
                var world_edge = world_edge.value();
                draw_text_format(font, FONT_SIZE, BLACK,
                    (:Vector2){.x = 2.0, .y = 5.0 * FONT_SIZE},
                    "EDGE: {}",
                    (:[]std::formatter)[
                        std::formatter::init[[edge]](&world_edge)]);
            }
            elif world_tile.is_value() {
                var world_tile = world_tile.value();
                draw_text_format(font, FONT_SIZE, BLACK,
                    (:Vector2){.x = 2.0, .y = 5.0 * FONT_SIZE},
                    "TILE: {} {verbose}",
                    (:[]std::formatter)[
                        std::formatter::init[[hex]](&world_tile.hex),
                        std::formatter::init[[tile]](&world_tile)]);
            }

            let SQUARE_SIZE = (:Vector2){.x = 32.0, .y = 32.0};
            let SQUARE_OFFSET = 8.0f32;
            let SQUARE_BORDER = 2.0f32;
            var square_xpos = (:f32)render_w - 4.0 * SQUARE_SIZE.x - 4.0 * SQUARE_OFFSET;
            var square_ypos = SQUARE_OFFSET;

            var square_background = BLACK;
            if player == PLAYER_RED {
                square_background = YELLOW;
            }
            DrawRectangleV(
                (:Vector2){
                    .x = square_xpos - SQUARE_BORDER + SQUARE_SIZE.x * 0.0 + SQUARE_OFFSET * 0.0,
                    .y = square_ypos - SQUARE_BORDER,
                },
                (:Vector2){
                    .x = SQUARE_SIZE.x + 2.0 * SQUARE_BORDER,
                    .y = SQUARE_SIZE.y + 2.0 * SQUARE_BORDER,
                },
                square_background);
            DrawRectangleV(
                (:Vector2){
                    .x = square_xpos + SQUARE_SIZE.x * 0.0 + SQUARE_OFFSET * 0.0,
                    .y = square_ypos,
                },
                SQUARE_SIZE,
                player_color(PLAYER_RED));

            var square_background = BLACK;
            if player == PLAYER_BLUE {
                square_background = YELLOW;
            }
            DrawRectangleV(
                (:Vector2){
                    .x = square_xpos - SQUARE_BORDER + SQUARE_SIZE.x * 1.0 + SQUARE_OFFSET * 1.0,
                    .y = square_ypos - SQUARE_BORDER,
                },
                (:Vector2){
                    .x = SQUARE_SIZE.x + 2.0 * SQUARE_BORDER,
                    .y = SQUARE_SIZE.y + 2.0 * SQUARE_BORDER,
                },
                square_background);
            DrawRectangleV(
                (:Vector2){
                    .x = square_xpos + SQUARE_SIZE.x * 1.0 + SQUARE_OFFSET * 1.0,
                    .y = square_ypos,
                },
                SQUARE_SIZE,
                player_color(PLAYER_BLUE));

            var square_background = BLACK;
            if player == PLAYER_WHITE {
                square_background = YELLOW;
            }
            DrawRectangleV(
                (:Vector2){
                    .x = square_xpos - SQUARE_BORDER + SQUARE_SIZE.x * 2.0 + SQUARE_OFFSET * 2.0,
                    .y = square_ypos - SQUARE_BORDER,
                },
                (:Vector2){
                    .x = SQUARE_SIZE.x + 2.0 * SQUARE_BORDER,
                    .y = SQUARE_SIZE.y + 2.0 * SQUARE_BORDER,
                },
                square_background);
            DrawRectangleV(
                (:Vector2){
                    .x = square_xpos + SQUARE_SIZE.x * 2.0 + SQUARE_OFFSET * 2.0,
                    .y = square_ypos,
                },
                SQUARE_SIZE,
                player_color(PLAYER_WHITE));

            var square_background = BLACK;
            if player == PLAYER_ORANGE {
                square_background = YELLOW;
            }
            DrawRectangleV(
                (:Vector2){
                    .x = square_xpos - SQUARE_BORDER + SQUARE_SIZE.x * 3.0 + SQUARE_OFFSET * 3.0,
                    .y = square_ypos - SQUARE_BORDER,
                },
                (:Vector2){
                    .x = SQUARE_SIZE.x + 2.0 * SQUARE_BORDER,
                    .y = SQUARE_SIZE.y + 2.0 * SQUARE_BORDER,
                },
                square_background);
            DrawRectangleV(
                (:Vector2){
                    .x = square_xpos + SQUARE_SIZE.x * 3.0 + SQUARE_OFFSET * 3.0,
                    .y = square_ypos,
                },
                SQUARE_SIZE,
                player_color(PLAYER_ORANGE));
        }

        EndDrawing();
    }
}
