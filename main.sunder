import "c";
import "raylib";
import "std";

# Hex position using the cube coordinate system satisfying q + r + s == 0.
struct hex {
    var q: sint;
    var r: sint;
    var s: sint;

    func init(q: sint, r: sint, s: sint) hex {
        assert q + r + s == 0;
        return (:hex){.q = q, .r = r, .s = s};
    }

    func init_round(q_fractional: f32, r_fractional: f32, s_fractional: f32) hex {
        var q_rounded = f32::round(q_fractional);
        var r_rounded = f32::round(r_fractional);
        var s_rounded = f32::round(s_fractional);

        var q_diff = f32::abs(q_rounded - q_fractional);
        var r_diff = f32::abs(r_rounded - r_fractional);
        var s_diff = f32::abs(s_rounded - s_fractional);

        var q = (:sint)q_rounded;
        var r = (:sint)r_rounded;
        var s = (:sint)s_rounded;
        if q_diff > r_diff and q_diff > s_diff {
            q = (:sint)-r_rounded - (:sint)s_rounded;
        }
        elif r_diff > s_diff {
            r = (:sint)-q_rounded - (:sint)s_rounded;
        }
        else {
            s = (:sint)-q_rounded - (:sint)r_rounded;
        }

        return hex::init(q, r, s);
    }

    func hash(self: *hex) usize {
        var h = self.*.q.hash() +% self.*.q.hash() +% self.*.s.hash();
        return h *% h;
    }

    func compare(lhs: *hex, rhs: *hex) ssize {
        var cmp = sint::cmp(lhs.*.q, rhs.*.q);
        if cmp != 0 {
            return cmp;
        }

        var cmp = sint::cmp(lhs.*.r, rhs.*.r);
        if cmp != 0 {
            return cmp;
        }

        var cmp = sint::cmp(lhs.*.s, rhs.*.s);
        if cmp != 0 {
            return cmp;
        }

        return 0;
    }

    func format(self: *hex, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            return std::write_format(
                    writer,
                    "(q={}, r={}, s={})",
                    (:[]std::formatter)[
                        std::formatter::init[[sint]](&self.*.q),
                        std::formatter::init[[sint]](&self.*.r),
                        std::formatter::init[[sint]](&self.*.s)]);
        }

        return std::result[[void, std::error]]::init_value(void::VALUE);
    }

    func subtract(lhs: hex, rhs: hex) hex {
        return hex::init(lhs.q - rhs.q, lhs.r - rhs.r, lhs.s - rhs.s);
    }

    func distance(a: hex, b: hex) sint {
        var vec = hex::subtract(a, b);
        return (sint::abs(vec.q) + sint::abs(vec.r) + sint::abs(vec.s)) / 2;
    }
}

struct resource {
    var kind: *struct { var data: []byte; };

    let BRICK = (:resource){.kind = (:*struct { var data: []byte; })&"brick"};
    let ORE   = (:resource){.kind = (:*struct { var data: []byte; })&"ore"};
    let SHEEP = (:resource){.kind = (:*struct { var data: []byte; })&"sheep"};
    let WHEAT = (:resource){.kind = (:*struct { var data: []byte; })&"wheat"};
    let WOOD  = (:resource){.kind = (:*struct { var data: []byte; })&"wood"};

    func data(self: *resource) []byte {
        return self.*.kind.*.data;
    }

    func cstr(self: *resource) *byte {
        return startof(self.*.kind.*.data);
    }

    func format(self: *resource, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            return std::write_all(writer, self.*.data());
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }
}

struct tile {
    let DESERT   = &"desert";
    let OCEAN    = &"ocean";

    let FOREST   = &"forest";
    let FIELD    = &"field";
    let HILL     = &"hill";
    let MOUNTAIN = &"mountain";
    let PASTURE  = &"pasture";

    var hex: hex;
    var kind: *[]byte;

    func init(hex: hex, kind: typeof(tile::DESERT)) tile {
        return (:tile){
            .hex = hex,
            .kind = kind,
        };
    }

    func hash(self: *tile) usize {
        return self.*.hex.hash();
    }

    func compare(lhs: *tile, rhs: *tile) ssize {
        return std::compare[[hex]](&lhs.*.hex, &rhs.*.hex);
    }

    func resource(self: *tile) std::optional[[::resource]] {
        if self.*.kind == tile::DESERT {
            return std::optional[[::resource]]::EMPTY;
        }
        if self.*.kind == tile::OCEAN {
            return std::optional[[::resource]]::EMPTY;
        }
        if self.*.kind == tile::FOREST {
            return std::optional[[::resource]]::init_value(::resource::WOOD);
        }
        if self.*.kind == tile::FIELD {
            return std::optional[[::resource]]::init_value(::resource::WHEAT);
        }
        if self.*.kind == tile::HILL {
            return std::optional[[::resource]]::init_value(::resource::BRICK);
        }
        if self.*.kind == tile::MOUNTAIN {
            return std::optional[[::resource]]::init_value(::resource::ORE);
        }
        if self.*.kind == tile::PASTURE {
            return std::optional[[::resource]]::init_value(::resource::SHEEP);
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[std::optional[[::resource]]]]();
    }

    func color(self: *tile) Color {
        if self.*.kind == tile::DESERT {
            return (:Color){.r = 0xEE, .g = 0xCC, .b = 0x88, .a = 0xFF};
        }
        if self.*.kind == tile::OCEAN {
            return (:Color){.r = 0x66, .g = 0xBB, .b = 0xFF, .a = 0xFF};
        }
        if self.*.kind == tile::FOREST {
            return (:Color){.r = 0x11, .g = 0x55, .b = 0x11, .a = 0xFF};
        }
        if self.*.kind == tile::FIELD {
            return (:Color){.r = 0xDD, .g = 0xAA, .b = 0x22, .a = 0xFF};
        }
        if self.*.kind == tile::HILL {
            return (:Color){.r = 0xCC, .g = 0x55, .b = 0x44, .a = 0xFF};
        }
        if self.*.kind == tile::MOUNTAIN {
            return (:Color){.r = 0x88, .g = 0x88, .b = 0x88, .a = 0xFF};
        }
        if self.*.kind == tile::PASTURE {
            return (:Color){.r = 0x66, .g = 0xAA, .b = 0x66, .a = 0xFF};
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[Color]]();
    }

    func format(self: *tile, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            return std::write_all(writer, *self.*.kind);
        }

        if std::str::eq(fmt, "full") {
            var resource = self.*.resource();
            if resource.is_empty() {
                return std::write_all(writer, *self.*.kind);
            }

            var resource = resource.value();
            return std::write_format(
                writer,
                "{} ({})",
                (:[]std::formatter)[
                    std::formatter::init[[[]byte]](self.*.kind),
                    std::formatter::init[[::resource]](&resource)]);
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }
}

struct edge {
    var tiles: [2]tile;

    func init(a: tile, b: tile) edge {
        assert hex::distance(a.hex, b.hex) == 1;

        var tiles = (:[2]tile)[a, b];
        std::sort[[tile]](tiles[0:countof(tiles)]);

        return (:edge){
            .tiles = tiles,
        };
    }

    func hash(self: *edge) usize {
        var hash = 0u;
        for i in countof(self.*.tiles) {
            hash = hash +% self.*.tiles[i].hash();
        }
        return hash;
    }

    func compare(lhs: *edge, rhs: *edge) ssize {
        var cmp = tile::compare(&lhs.*.tiles[0], &rhs.*.tiles[0]);
        if cmp != 0 {
            return cmp;
        }

        var cmp = tile::compare(&lhs.*.tiles[1], &rhs.*.tiles[1]);
        if cmp != 0 {
            return cmp;
        }

        return 0;
    }

    func format(self: *edge, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            for i in countof(self.*.tiles) {
                if i != 0 {
                    std::print(writer, ", ");
                }
                std::print_format(
                    writer,
                    "{}",
                    (:[]std::formatter)[
                        std::formatter::init[[hex]](&self.*.tiles[i].hex)]);
            }

            return std::result[[void, std::error]]::init_value(void::VALUE);
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }
}

struct node {
    var tiles: [3]tile;

    func init(a: tile, b: tile, c: tile) node {
        assert hex::distance(a.hex, b.hex) == 1;
        assert hex::distance(b.hex, c.hex) == 1;
        assert hex::distance(c.hex, a.hex) == 1;

        var tiles = (:[3]tile)[a, b, c];
        std::sort[[tile]](tiles[0:countof(tiles)]);

        return (:node){
            .tiles = tiles,
        };
    }

    func hash(self: *node) usize {
        var hash = 0u;
        for i in countof(self.*.tiles) {
            hash = hash +% self.*.tiles[i].hash();
        }
        return hash;
    }

    func compare(lhs: *node, rhs: *node) ssize {
        var cmp = tile::compare(&lhs.*.tiles[0], &rhs.*.tiles[0]);
        if cmp != 0 {
            return cmp;
        }

        var cmp = tile::compare(&lhs.*.tiles[1], &rhs.*.tiles[1]);
        if cmp != 0 {
            return cmp;
        }

        var cmp = tile::compare(&lhs.*.tiles[2], &rhs.*.tiles[2]);
        if cmp != 0 {
            return cmp;
        }

        return 0;
    }

    func format(self: *node, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            for i in countof(self.*.tiles) {
                if i != 0 {
                    std::print(writer, ", ");
                }
                std::print_format(
                    writer,
                    "{}",
                    (:[]std::formatter)[
                        std::formatter::init[[hex]](&self.*.tiles[i].hex)]);
            }

            return std::result[[void, std::error]]::init_value(void::VALUE);
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }
}

func point_to_pointy_hex(point: Vector2, radius: f32) hex {
    var q = (f32::sqrt(3.0)/3.0 * point.x - 1.0/3.0 * point.y) / radius;
    var r = (2.0/3.0 * point.y) / radius;
    var s = -q - r;

    return hex::init_round(q, r, s);
}

func pointy_hex_to_point(hex: hex, radius: f32) Vector2 {
    var x = radius * (f32::sqrt(3.0) * (:f32)hex.q + f32::sqrt(3.0)/2.0 * (:f32)hex.r);
    var y = radius * (3.0/2.0 * (:f32)hex.r);
    return (:Vector2){.x = x, .y = y};
}

func draw_pointy_hexagon(center: Vector2, radius: f32, color: Color) void {
    let SIDES: sint = 6;
    let ANGLE: f32 = 30.0; # pointy-top orientation
    DrawPoly(center, SIDES, radius, ANGLE, color);
}

func draw_pointy_hexagon_outline(center: Vector2, radius: f32, color: Color) void {
    let SIDES: sint = 6;
    let ANGLE: f32 = 30.0; # pointy-top orientation
    DrawPolyLinesEx(center, SIDES, radius, ANGLE, radius / 8.0, color);
}

func draw_pointy_hexagon_border(center: Vector2, radius: f32, color: Color) void {
    let SIDES: sint = 6;
    let ANGLE: f32 = 30.0; # pointy-top orientation
    var thick: f32 = radius / 16.0;
    DrawPolyLinesEx(center, SIDES, radius + thick / 2.0, ANGLE, thick, color);
}

func distance(a: Vector2, b: Vector2) f32 {
    var x_dist = a.x - b.x;
    var y_dist = a.y - b.y;
    return f32::sqrt(x_dist * x_dist + y_dist * y_dist);
}

func draw_circle(center: Vector2, radius: f32, color: Color) void {
    # NOTE: DrawCircle and DrawCircleV, which forward to DrawCircleSector with
    # 36 segments, will produce a circle with holes for small (less than ~18.0)
    # radii when using FLAG_MSAA_4X_HINT. Higher segment counts seem to cause
    # more holes to appear in the drawn circle.

    # Draw the circle once with DrawCircleV in order to create an outline with
    # proper anti-aliasing.
    DrawCircleV(center, radius, color);

    # Draw the circle again with DrawCircleSector using a segment count that
    # will be lower for smaller radii in order to fill in the circle.
    var segments = (:sint)radius;
    DrawCircleSector(center, radius, 0.0, 360.0, segments, color);
}

func draw_text(font: Font, size: f32, color: Color, position: Vector2, text: []byte) void {
    var s = std::string::init_from_str(text);
    defer s.fini();

    let SPACING = 0.0f32;
    DrawTextEx(font, s.cstr(), position, size, SPACING, color);
}

func draw_text_cstr(font: Font, size: f32, color: Color, position: Vector2, text: *byte) void {
    let SPACING = 0.0f32;
    DrawTextEx(font, text, position, size, SPACING, color);
}

func draw_text_format(font: Font, size: f32, color: Color, position: Vector2, format: []byte, args: []std::formatter) void {
    var s = std::string::init_from_format(format, args);
    defer s.fini();

    let SPACING = 0.0f32;
    DrawTextEx(font, s.cstr(), position, size, SPACING, color);
}

func default_camera_zoom(radius: f32, h: f32) f32 {
    # Default the camera zoom so that the board and board-adjacent ocean tiles
    # fit on the screen. Approximate the length of the board and board-adjacent
    # ocean tiles as six tile diameters (five board tiles plus two ocean tiles
    # on either side minus one tile to somewhat account for radius overlap).
    return h / (6.0 * 2.0 * radius);
}

func init_tiles() std::hash_set[[tile]] {
    var tiles = std::hash_set[[tile]]::init();

    # top row
    tiles.insert(tile::init(hex::init(+0, -2, +2), tile::MOUNTAIN));
    tiles.insert(tile::init(hex::init(+1, -2, +1), tile::PASTURE));
    tiles.insert(tile::init(hex::init(+2, -2, +0), tile::FOREST));
    # top-middle row
    tiles.insert(tile::init(hex::init(-1, -1, +2), tile::FIELD));
    tiles.insert(tile::init(hex::init(+0, -1, +1), tile::HILL));
    tiles.insert(tile::init(hex::init(+1, -1, +0), tile::PASTURE));
    tiles.insert(tile::init(hex::init(+2, -1, -1), tile::HILL));
    # middle row
    tiles.insert(tile::init(hex::init(-2, +0, +2), tile::FIELD));
    tiles.insert(tile::init(hex::init(-1, +0, +1), tile::FOREST));
    tiles.insert(tile::init(hex::init(+0, +0, +0), tile::DESERT));
    tiles.insert(tile::init(hex::init(+1, +0, -1), tile::FOREST));
    tiles.insert(tile::init(hex::init(+2, +0, -2), tile::MOUNTAIN));
    # bottom-middle row
    tiles.insert(tile::init(hex::init(-2, +1, +1), tile::FOREST));
    tiles.insert(tile::init(hex::init(-1, +1, +0), tile::MOUNTAIN));
    tiles.insert(tile::init(hex::init(+0, +1, -1), tile::FIELD));
    tiles.insert(tile::init(hex::init(+1, +1, -2), tile::PASTURE));
    # bottom row
    tiles.insert(tile::init(hex::init(-2, +2, +0), tile::HILL));
    tiles.insert(tile::init(hex::init(-1, +2, -1), tile::FIELD));
    tiles.insert(tile::init(hex::init(+0, +2, -2), tile::PASTURE));
    # adjacent ocean
    tiles.insert(tile::init(hex::init(+0, -3, +3), tile::OCEAN));
    tiles.insert(tile::init(hex::init(+1, -3, +2), tile::OCEAN));
    tiles.insert(tile::init(hex::init(+2, -3, +1), tile::OCEAN));
    tiles.insert(tile::init(hex::init(+3, -3, +0), tile::OCEAN));
    tiles.insert(tile::init(hex::init(-1, -2, +3), tile::OCEAN));
    tiles.insert(tile::init(hex::init(+3, -2, -1), tile::OCEAN));
    tiles.insert(tile::init(hex::init(-2, -1, +3), tile::OCEAN));
    tiles.insert(tile::init(hex::init(+3, -1, -2), tile::OCEAN));
    tiles.insert(tile::init(hex::init(-3, +0, +3), tile::OCEAN));
    tiles.insert(tile::init(hex::init(+3, +0, -3), tile::OCEAN));
    tiles.insert(tile::init(hex::init(-3, +1, +2), tile::OCEAN));
    tiles.insert(tile::init(hex::init(+2, +1, -3), tile::OCEAN));
    tiles.insert(tile::init(hex::init(-3, +2, +1), tile::OCEAN));
    tiles.insert(tile::init(hex::init(+1, +2, -3), tile::OCEAN));
    tiles.insert(tile::init(hex::init(-3, +3, +0), tile::OCEAN));
    tiles.insert(tile::init(hex::init(-2, +3, -1), tile::OCEAN));
    tiles.insert(tile::init(hex::init(-1, +3, -2), tile::OCEAN));
    tiles.insert(tile::init(hex::init(+0, +3, -3), tile::OCEAN));

    return tiles;
}

func init_nodes(tiles: *std::hash_set[[tile]]) std::hash_set[[node]] {
    var nodes = std::hash_set[[node]]::init();

    var iter_i = std::hash_set_iterator[[tile]]::init(tiles);
    for iter_i.advance() {
        var iter_j = std::hash_set_iterator[[tile]]::init(tiles);
        for iter_j.advance() {
            var iter_k = std::hash_set_iterator[[tile]]::init(tiles);
            for iter_k.advance() {
                if hex::distance(iter_i.current().*.hex, iter_j.current().*.hex) != 1 {
                    continue;
                }
                if hex::distance(iter_j.current().*.hex, iter_k.current().*.hex) != 1 {
                    continue;
                }
                if hex::distance(iter_k.current().*.hex, iter_i.current().*.hex) != 1 {
                    continue;
                }
                var node = node::init(*iter_i.current(), *iter_j.current(), *iter_k.current());
                nodes.insert(node);
            }
        }
    }

    return nodes;
}

func init_edges(tiles: *std::hash_set[[tile]]) std::hash_set[[edge]] {
    var edges = std::hash_set[[edge]]::init();

    var iter_i = std::hash_set_iterator[[tile]]::init(tiles);
    for iter_i.advance() {
        var iter_j = std::hash_set_iterator[[tile]]::init(tiles);
        for iter_j.advance() {
            if hex::distance(iter_i.current().*.hex, iter_j.current().*.hex) != 1 {
                continue;
            }
            var edge = edge::init(*iter_i.current(), *iter_j.current());
            edges.insert(edge);
        }
    }

    return edges;
}

func main() void {
    var argparser = std::argument_parser::init((:[][]byte)[
        "fullscreen"
    ]);
    var opt_fullscreen = false;
    for argparser.advance() {
        if argparser.check_option("fullscreen") {
            opt_fullscreen = true;
        }
    }

    SetTraceLogLevel(LOG_WARNING);
    SetConfigFlags(FLAG_MSAA_4X_HINT);
    InitWindow(800, 600, startof("NATAC"));
    defer CloseWindow();
    SetTargetFPS(60);
    if (opt_fullscreen) {
        ToggleFullscreen();
    }

    let RADIUS = 48.0f32;

    let PUBLIC_PIXEL_TTF = embed("assets/PublicPixel.ttf");
    let FONT_SIZE = 16.0f32;
    let FONT_NUMCHARS: sint = '~' - ' ' + 1; # Printable ASCII
    var font = LoadFontFromMemory(
        startof(".ttf"),
        (:*u8)startof(PUBLIC_PIXEL_TTF),
        (:sint)countof(PUBLIC_PIXEL_TTF),
        (:sint)FONT_SIZE,
        std::ptr[[sint]]::NULL,
        FONT_NUMCHARS);
    defer UnloadFont(font);

    var tiles = init_tiles();
    defer tiles.fini();
    var nodes = init_nodes(&tiles);
    defer nodes.fini();
    var edges = init_edges(&tiles);
    defer edges.fini();

    var camera_rotation = 0.0f32;
    var camera_zoom = default_camera_zoom(RADIUS, (:f32)GetRenderHeight());
    if opt_fullscreen {
        camera_zoom = default_camera_zoom(RADIUS, (:f32)GetMonitorHeight(GetCurrentMonitor()));
    }

    for not WindowShouldClose() {
        if IsKeyPressed(KEY_F11) {
            ToggleFullscreen();
        }
        if IsKeyDown(KEY_Q) {
            camera_rotation = camera_rotation - 1.0;
        }
        if IsKeyDown(KEY_E) {
            camera_rotation = camera_rotation + 1.0;
        }
        if IsKeyDown(KEY_R) {
            camera_rotation = 0.0f32;
            camera_zoom = default_camera_zoom(RADIUS, (:f32)GetRenderHeight());
        }

        var mouse_wheel_y = GetMouseWheelMoveV().y;
        if mouse_wheel_y > 0.0 and camera_zoom < 2.0 {
            camera_zoom = camera_zoom + 0.1;
        }
        if mouse_wheel_y < 0.0 and camera_zoom > 0.5{
            camera_zoom = camera_zoom - 0.1;
        }

        BeginDrawing();
        ClearBackground((:Color){.r = 0x66, .g = 0xBB, .b = 0xFF, .a = 0xFF});

        var render_w = GetRenderWidth();
        var render_h = GetRenderHeight();
        var render_center = (:Vector2){
            .x = (:f32)render_w / 2.0,
            .y = (:f32)render_h / 2.0,
        };
        var camera = (:Camera2D){
            .target = (:Vector2){
                .x = 0.0f32,
                .y = 0.0f32
            },
            .offset = render_center,
            .rotation = camera_rotation,
            .zoom = camera_zoom,
        };

        BeginMode2D(camera);

        var iter = std::hash_set_iterator[[tile]]::init(&tiles);
        for iter.advance() {
            var tile = iter.current();
            var point = pointy_hex_to_point(tile.*.hex, RADIUS);
            draw_pointy_hexagon(point, RADIUS, tile.*.color());
        }

        var mouse = GetMousePosition();
        var world = GetScreenToWorld2D(mouse, camera);
        var world_hex = point_to_pointy_hex(world, RADIUS);
        var world_hex_center = pointy_hex_to_point(world_hex, RADIUS);

        var world_tile = std::optional[[tile]]::EMPTY;
        var iter = std::hash_set_iterator[[tile]]::init(&tiles);
        for iter.advance() {
            if std::eq[[hex]](&iter.current().*.hex, &world_hex) {
                world_tile = std::optional[[tile]]::init_value(*iter.current());
                draw_pointy_hexagon_outline(world_hex_center, RADIUS, YELLOW);
                break;
            }
        }
        draw_circle(world_hex_center, 4.0, YELLOW);

        var world_edge = std::optional[[edge]]::EMPTY;
        var iter = std::hash_set_iterator[[edge]]::init(&edges);
        for iter.advance() {
            var found = true;
            for i in countof(iter.current().*.tiles) {
                let DISTANCE = RADIUS * 1.2;
                var hex = iter.current().*.tiles[i].hex;
                if distance(world, pointy_hex_to_point(hex, RADIUS)) > DISTANCE {
                    found = false;
                    break;
                }
            }

            if found {
                world_edge = std::optional[[edge]]::init_value(*iter.current());
                for i in countof(iter.current().*.tiles) {
                    var point = pointy_hex_to_point(iter.current().*.tiles[i].hex, RADIUS);
                    draw_pointy_hexagon_outline(point, RADIUS, ORANGE);
                }
                break;
            }
        }

        var world_node = std::optional[[node]]::EMPTY;
        var iter = std::hash_set_iterator[[node]]::init(&nodes);
        for iter.advance() {
            var found = true;
            for i in countof(iter.current().*.tiles) {
                let DISTANCE = RADIUS * 1.2;
                var hex = iter.current().*.tiles[i].hex;
                if distance(world, pointy_hex_to_point(hex, RADIUS)) > DISTANCE {
                    found = false;
                    break;
                }
            }

            if found {
                world_node = std::optional[[node]]::init_value(*iter.current());
                for i in countof(iter.current().*.tiles) {
                    var point = pointy_hex_to_point(iter.current().*.tiles[i].hex, RADIUS);
                    draw_pointy_hexagon_outline(point, RADIUS, RED);
                }
                break;
            }
        }

        var iter = std::hash_set_iterator[[tile]]::init(&tiles);
        for iter.advance() {
            var tile = iter.current();
            if tile.*.kind == ::tile::OCEAN {
                continue;
            }
            var point = pointy_hex_to_point(tile.*.hex, RADIUS);
            draw_pointy_hexagon_border(point, RADIUS, BLACK);
        }

        EndMode2D();

        var fps = GetFPS();
        draw_text_format(font, FONT_SIZE, BLACK,
            (:Vector2){.x = 2.0, .y = 0.0},
            "FPS {}",
            (:[]std::formatter)[
                std::formatter::init[[typeof(fps)]](&fps)]);

        draw_text_format(font, FONT_SIZE, BLACK,
            (:Vector2){.x = 2.0, .y = 1.0 * FONT_SIZE},
            "MOUSE: x={.0}, y={.0}",
            (:[]std::formatter)[
                std::formatter::init[[f32]](&mouse.x),
                std::formatter::init[[f32]](&mouse.y)]);

        draw_text_format(font, FONT_SIZE, BLACK,
            (:Vector2){.x = 2.0, .y = 2.0 * FONT_SIZE},
            "WORLD: x={.0}, y={.0}",
            (:[]std::formatter)[
                std::formatter::init[[f32]](&world.x),
                std::formatter::init[[f32]](&world.y)]);

        draw_text_format(font, FONT_SIZE, BLACK,
            (:Vector2){.x = 2.0, .y = 3.0 * FONT_SIZE},
            "WORLD->HEX: q={}, r={}, s={}",
            (:[]std::formatter)[
                std::formatter::init[[sint]](&world_hex.q),
                std::formatter::init[[sint]](&world_hex.r),
                std::formatter::init[[sint]](&world_hex.s)]);

        draw_text_format(font, FONT_SIZE, BLACK,
            (:Vector2){.x = 2.0, .y = 4.0 * FONT_SIZE},
            "WORLD->HEX->WORLD: x={.0}, y={.0}",
            (:[]std::formatter)[
                std::formatter::init[[f32]](&world_hex_center.x),
                std::formatter::init[[f32]](&world_hex_center.y)]);

        if world_tile.is_value() {
            var world_tile = world_tile.value();
            draw_text_format(font, FONT_SIZE, BLACK,
                (:Vector2){.x = 2.0, .y = 5.0 * FONT_SIZE},
                "TILE: {} {full}",
                (:[]std::formatter)[
                    std::formatter::init[[hex]](&world_tile.hex),
                    std::formatter::init[[tile]](&world_tile)]);
        }
        else {
            draw_text(font, FONT_SIZE, BLACK,
                (:Vector2){.x = 2.0, .y = 5.0 * FONT_SIZE},
                "TILE: ocean");
        }

        if world_edge.is_value() {
            var world_edge = world_edge.value();
            draw_text_format(font, FONT_SIZE, BLACK,
                (:Vector2){.x = 2.0, .y = 6.0 * FONT_SIZE},
                "EDGE: {}",
                (:[]std::formatter)[
                    std::formatter::init[[edge]](&world_edge)]);
        }
        else {
            draw_text(font, FONT_SIZE, BLACK,
                (:Vector2){.x = 2.0, .y = 6.0 * FONT_SIZE},
                "EDGE: none");
        }

        if world_node.is_value() {
            var world_node = world_node.value();
            draw_text_format(font, FONT_SIZE, BLACK,
                (:Vector2){.x = 2.0, .y = 7.0 * FONT_SIZE},
                "NODE: {}",
                (:[]std::formatter)[
                    std::formatter::init[[node]](&world_node)]);
        }
        else {
            draw_text(font, FONT_SIZE, BLACK,
                (:Vector2){.x = 2.0, .y = 7.0 * FONT_SIZE},
                "NODE: none");
        }

        EndDrawing();
    }
}
