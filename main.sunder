import "c";
import "raylib";
import "std";

let RADIUS = 48.0f32;

# Hex position using the cube coordinate system satisfying q + r + s == 0.
struct hex {
    var q: sint;
    var r: sint;
    var s: sint;

    func init(q: sint, r: sint, s: sint) hex {
        assert q + r + s == 0;
        return (:hex){.q = q, .r = r, .s = s};
    }

    func init_round(q_fractional: f32, r_fractional: f32, s_fractional: f32) hex {
        var q_rounded = f32::round(q_fractional);
        var r_rounded = f32::round(r_fractional);
        var s_rounded = f32::round(s_fractional);

        var q_diff = f32::abs(q_rounded - q_fractional);
        var r_diff = f32::abs(r_rounded - r_fractional);
        var s_diff = f32::abs(s_rounded - s_fractional);

        var q = (:sint)q_rounded;
        var r = (:sint)r_rounded;
        var s = (:sint)s_rounded;
        if q_diff > r_diff and q_diff > s_diff {
            q = (:sint)-r_rounded - (:sint)s_rounded;
        }
        elif r_diff > s_diff {
            r = (:sint)-q_rounded - (:sint)s_rounded;
        }
        else {
            s = (:sint)-q_rounded - (:sint)r_rounded;
        }

        return hex::init(q, r, s);
    }

    func hash(self: *hex) usize {
        var h = self.*.q.hash() +% self.*.q.hash() +% self.*.s.hash();
        return h *% h;
    }

    func compare(lhs: *hex, rhs: *hex) ssize {
        var cmp = sint::cmp(lhs.*.q, rhs.*.q);
        if cmp != 0 {
            return cmp;
        }

        var cmp = sint::cmp(lhs.*.r, rhs.*.r);
        if cmp != 0 {
            return cmp;
        }

        var cmp = sint::cmp(lhs.*.s, rhs.*.s);
        if cmp != 0 {
            return cmp;
        }

        return 0;
    }
}

func point_to_pointy_hex(point: Vector2, radius: f32) hex {
    var q = (f32::sqrt(3.0)/3.0 * point.x - 1.0/3.0 * point.y) / radius;
    var r = (2.0/3.0 * point.y) / radius;
    var s = -q - r;

    return hex::init_round(q, r, s);
}

func pointy_hex_to_point(hex: hex, radius: f32) Vector2 {
    var x = radius * (f32::sqrt(3.0) * (:f32)hex.q + f32::sqrt(3.0)/2.0 * (:f32)hex.r);
    var y = radius * (3.0/2.0 * (:f32)hex.r);
    return (:Vector2){.x = x, .y = y};
}

func draw_pointy_hexagon(center: Vector2, radius: f32, color: Color) void {
    let SIDES: sint = 6;
    let ANGLE: f32 = 30.0; # pointy-top orientation
    DrawPoly(center, SIDES, radius, ANGLE, color);
}

func draw_pointy_hexagon_outline(center: Vector2, radius: f32, color: Color) void {
    let SIDES: sint = 6;
    let ANGLE: f32 = 30.0; # pointy-top orientation
    DrawPolyLinesEx(center, SIDES, radius, ANGLE, radius / 8.0, color);
}

func draw_pointy_hexagon_border(center: Vector2, radius: f32, color: Color) void {
    let SIDES: sint = 6;
    let ANGLE: f32 = 30.0; # pointy-top orientation
    var thick: f32 = radius / 16.0;
    DrawPolyLinesEx(center, SIDES, radius + thick / 2.0, ANGLE, thick, color);
}

func draw_circle(center: Vector2, radius: f32, color: Color) void {
    # NOTE: DrawCircle and DrawCircleV, which forward to DrawCircleSector with
    # 36 segments, will produce a circle with holes for small (less than ~18.0)
    # radii when using FLAG_MSAA_4X_HINT. Higher segment counts seem to cause
    # more holes to appear in the drawn circle.

    # Draw the circle once with DrawCircleV in order to create an outline with
    # proper anti-aliasing.
    DrawCircleV(center, radius, color);

    # Draw the circle again with DrawCircleSector using a segment count that
    # will be lower for smaller radii in order to fill in the circle.
    var segments = (:sint)radius;
    DrawCircleSector(center, radius, 0.0, 360.0, segments, color);
}

func draw_text(font: Font, size: f32, color: Color, position: Vector2, text: []byte) void {
    var s = std::string::init_from_str(text);
    defer s.fini();

    let SPACING = 0.0f32;
    DrawTextEx(font, s.cstr(), position, size, SPACING, color);
}

func draw_text_format(font: Font, size: f32, color: Color, position: Vector2, format: []byte, args: []std::formatter) void {
    var s = std::string::init_from_format(format, args);
    defer s.fini();

    let SPACING = 0.0f32;
    DrawTextEx(font, s.cstr(), position, size, SPACING, color);
}

struct resource {
    var kind: *struct { var data: []byte; };

    let BRICK = (:resource){.kind = (:*struct { var data: []byte; })&"brick"};
    let ORE   = (:resource){.kind = (:*struct { var data: []byte; })&"ore"};
    let SHEEP = (:resource){.kind = (:*struct { var data: []byte; })&"sheep"};
    let WHEAT = (:resource){.kind = (:*struct { var data: []byte; })&"wheat"};
    let WOOD  = (:resource){.kind = (:*struct { var data: []byte; })&"wood"};

    func data(self: *resource) []byte {
        return self.*.kind.*.data;
    }

    func cstr(self: *resource) *byte {
        return startof(self.*.kind.*.data);
    }

    func format(self: *resource, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            return std::write_all(writer, self.*.data());
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }
}

struct tile {
    let DESERT   = &"desert";
    let FOREST   = &"forest";
    let FIELD    = &"field";
    let HILL     = &"hill";
    let MOUNTAIN = &"mountain";
    let PASTURE  = &"pasture";

    var position: hex;
    var kind: *[]byte;

    func init(position: hex, kind: typeof(tile::DESERT)) tile {
        return (:tile){
            .position = position,
            .kind = kind,
        };
    }

    func hash(self: *tile) usize {
        return self.*.position.hash();
    }

    func compare(lhs: *tile, rhs: *tile) ssize {
        return std::compare[[hex]](&lhs.*.position, &rhs.*.position);
    }

    func resource(self: *tile) std::optional[[::resource]] {
        if self.*.kind == tile::DESERT {
            return std::optional[[::resource]]::EMPTY;
        }
        if self.*.kind == tile::FOREST {
            return std::optional[[::resource]]::init_value(::resource::WOOD);
        }
        if self.*.kind == tile::FIELD {
            return std::optional[[::resource]]::init_value(::resource::WHEAT);
        }
        if self.*.kind == tile::HILL {
            return std::optional[[::resource]]::init_value(::resource::BRICK);
        }
        if self.*.kind == tile::MOUNTAIN {
            return std::optional[[::resource]]::init_value(::resource::ORE);
        }
        if self.*.kind == tile::PASTURE {
            return std::optional[[::resource]]::init_value(::resource::SHEEP);
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[std::optional[[::resource]]]]();
    }

    func color(self: *tile) Color {
        if self.*.kind == tile::DESERT {
            return (:Color){.r = 0xEE, .g = 0xCC, .b = 0x88, .a = 0xFF};
        }
        if self.*.kind == tile::FOREST {
            return (:Color){.r = 0x11, .g = 0x55, .b = 0x11, .a = 0xFF};
        }
        if self.*.kind == tile::FIELD {
            return (:Color){.r = 0xDD, .g = 0xAA, .b = 0x22, .a = 0xFF};
        }
        if self.*.kind == tile::HILL {
            return (:Color){.r = 0xCC, .g = 0x55, .b = 0x44, .a = 0xFF};
        }
        if self.*.kind == tile::MOUNTAIN {
            return (:Color){.r = 0x88, .g = 0x88, .b = 0x88, .a = 0xFF};
        }
        if self.*.kind == tile::PASTURE {
            return (:Color){.r = 0x66, .g = 0xAA, .b = 0x66, .a = 0xFF};
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[Color]]();
    }

    func format(self: *tile, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if std::str::eq(fmt, "") {
            return std::write_all(writer, *self.*.kind);
        }

        if std::str::eq(fmt, "full") {
            var resource = self.*.resource();
            if resource.is_empty() {
                return std::write_all(writer, *self.*.kind);
            }

            var resource = resource.value();
            return std::write_format(
                writer,
                "{} ({})",
                (:[]std::formatter)[
                    std::formatter::init[[[]byte]](self.*.kind),
                    std::formatter::init[[::resource]](&resource)]);
        }

        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }
}

func main() void {
    SetTraceLogLevel(LOG_WARNING);
    SetConfigFlags(FLAG_MSAA_4X_HINT);
    InitWindow(800, 600, startof("NATAC"));
    defer CloseWindow();
    SetTargetFPS(60);

    let PUBLIC_PIXEL_TTF = embed("assets/PublicPixel.ttf");
    let FONT_SIZE = 16.0f32;
    let FONT_NUMCHARS: sint = '~' - ' ' + 1; # Printable ASCII
    var font = LoadFontFromMemory(
        startof(".ttf"),
        (:*u8)startof(PUBLIC_PIXEL_TTF),
        (:sint)countof(PUBLIC_PIXEL_TTF),
        (:sint)FONT_SIZE,
        std::ptr[[sint]]::NULL,
        FONT_NUMCHARS);
    defer UnloadFont(font);

    var tiles = std::hash_set[[tile]]::init();
    defer tiles.fini();
    # top row
    tiles.insert(tile::init(hex::init(+0, -2, +2), tile::MOUNTAIN));
    tiles.insert(tile::init(hex::init(+1, -2, +1), tile::PASTURE));
    tiles.insert(tile::init(hex::init(+2, -2, +0), tile::FOREST));
    # top-middle row
    tiles.insert(tile::init(hex::init(-1, -1, +2), tile::FIELD));
    tiles.insert(tile::init(hex::init(+0, -1, +1), tile::HILL));
    tiles.insert(tile::init(hex::init(+1, -1, +0), tile::PASTURE));
    tiles.insert(tile::init(hex::init(+2, -1, -1), tile::HILL));
    # middle row
    tiles.insert(tile::init(hex::init(-2, +0, +2), tile::FIELD));
    tiles.insert(tile::init(hex::init(-1, +0, +1), tile::FOREST));
    tiles.insert(tile::init(hex::init(+0, +0, +0), tile::DESERT));
    tiles.insert(tile::init(hex::init(+1, +0, -1), tile::FOREST));
    tiles.insert(tile::init(hex::init(+2, +0, -2), tile::MOUNTAIN));
    # bottom-middle row
    tiles.insert(tile::init(hex::init(-2, +1, +1), tile::FOREST));
    tiles.insert(tile::init(hex::init(-1, +1, +0), tile::MOUNTAIN));
    tiles.insert(tile::init(hex::init(+0, +1, -1), tile::FIELD));
    tiles.insert(tile::init(hex::init(+1, +1, -2), tile::PASTURE));
    # bottom row
    tiles.insert(tile::init(hex::init(-2, +2, +0), tile::HILL));
    tiles.insert(tile::init(hex::init(-1, +2, -1), tile::FIELD));
    tiles.insert(tile::init(hex::init(+0, +2, -2), tile::PASTURE));

    var camera_rotation = 0.0f32;
    var camera_zoom = 1.0f32;

    for not WindowShouldClose() {
        if IsKeyPressed(KEY_F11) {
            ToggleFullscreen();
        }
        if IsKeyDown(KEY_Q) {
            camera_rotation = camera_rotation - 1.0;
        }
        if IsKeyDown(KEY_E) {
            camera_rotation = camera_rotation + 1.0;
        }
        if IsKeyDown(KEY_R) {
            camera_rotation = 0.0f32;
            camera_zoom = 1.0;
        }

        var mouse_wheel_y = GetMouseWheelMoveV().y;
        if mouse_wheel_y > 0.0 {
            camera_zoom = camera_zoom + 0.1;
        }
        if mouse_wheel_y < 0.0 {
            camera_zoom = camera_zoom - 0.1;
        }
        if camera_zoom < 0.5 {
            camera_zoom = 0.5;
        }
        if camera_zoom > 2.0 {
            camera_zoom = 2.0;
        }

        BeginDrawing();
        ClearBackground(SKYBLUE);

        var render_w = GetRenderWidth();
        var render_h = GetRenderHeight();
        var render_center = (:Vector2){
            .x = (:f32)render_w / 2.0,
            .y = (:f32)render_h / 2.0,
        };
        var camera = (:Camera2D){
            .target = (:Vector2){
                .x = 0.0f32,
                .y = 0.0f32
            },
            .offset = render_center,
            .rotation = camera_rotation,
            .zoom = camera_zoom,
        };

        BeginMode2D(camera);

        var iter = std::hash_set_iterator[[tile]]::init(&tiles);
        for iter.advance() {
            var tile = iter.current();
            var point = pointy_hex_to_point(tile.*.position, RADIUS);
            draw_pointy_hexagon(point, RADIUS, tile.*.color());
        }

        var mouse = GetMousePosition();
        var world = GetScreenToWorld2D(mouse, camera);
        var world_hex = point_to_pointy_hex(world, RADIUS);
        var world_hex_center = pointy_hex_to_point(world_hex, RADIUS);


        var world_tile: *tile = uninit;
        var iter = std::hash_set_iterator[[tile]]::init(&tiles);
        for iter.advance() {
            if std::eq[[hex]](&iter.current().*.position, &world_hex) {
                world_tile = iter.current();
                draw_pointy_hexagon_outline(world_hex_center, RADIUS, PURPLE);
                break;
            }
        }
        draw_circle(world_hex_center, 4.0, PURPLE);

        var iter = std::hash_set_iterator[[tile]]::init(&tiles);
        for iter.advance() {
            var tile = iter.current();
            var point = pointy_hex_to_point(tile.*.position, RADIUS);
            draw_pointy_hexagon_border(point, RADIUS, BLACK);
        }

        EndMode2D();

        var fps = GetFPS();
        draw_text_format(font, FONT_SIZE, BLACK,
            (:Vector2){.x = 2.0, .y = 0.0},
            "FPS {}",
            (:[]std::formatter)[
                std::formatter::init[[typeof(fps)]](&fps)]);
        draw_text_format(font, FONT_SIZE, BLACK,
            (:Vector2){.x = 2.0, .y = 1.0 * FONT_SIZE},
            "MOUSE: x={.0}, y={.0}",
            (:[]std::formatter)[
                std::formatter::init[[f32]](&mouse.x),
                std::formatter::init[[f32]](&mouse.y)]);
        draw_text_format(font, FONT_SIZE, BLACK,
            (:Vector2){.x = 2.0, .y = 2.0 * FONT_SIZE},
            "WORLD: x={.0}, y={.0}",
            (:[]std::formatter)[
                std::formatter::init[[f32]](&world.x),
                std::formatter::init[[f32]](&world.y)]);
        draw_text_format(font, FONT_SIZE, BLACK,
            (:Vector2){.x = 2.0, .y = 3.0 * FONT_SIZE},
            "WORLD->HEX: q={}, r={}, s={}",
            (:[]std::formatter)[
                std::formatter::init[[sint]](&world_hex.q),
                std::formatter::init[[sint]](&world_hex.r),
                std::formatter::init[[sint]](&world_hex.s)]);
        draw_text_format(font, FONT_SIZE, BLACK,
            (:Vector2){.x = 2.0, .y = 4.0 * FONT_SIZE},
            "WORLD->HEX->WORLD: x={.0}, y={.0}",
            (:[]std::formatter)[
                std::formatter::init[[f32]](&world_hex_center.x),
                std::formatter::init[[f32]](&world_hex_center.y)]);
        if world_tile != std::ptr[[tile]]::NULL {
            draw_text_format(font, FONT_SIZE, BLACK,
                (:Vector2){.x = 2.0, .y = 5.0 * FONT_SIZE},
                "TILE: {full}",
                (:[]std::formatter)[
                    std::formatter::init[[tile]](world_tile)]);
        }
        else {
            draw_text(font, FONT_SIZE, BLACK,
                (:Vector2){.x = 2.0, .y = 5.0 * FONT_SIZE},
                "TILE: ocean");
        }

        EndDrawing();
    }
}
