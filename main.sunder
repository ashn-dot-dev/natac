import "c";
import "raylib";
import "std";

import "client.sunder";
import "server.sunder";
import "shared.sunder";

func main() void {
    var argparser = std::argument_parser::init((:[][]byte)[
        "debug",
        "fullscreen"
    ]);
    var opt_debug = false;
    var opt_fullscreen = false;
    for argparser.advance() {
        if argparser.check_option("debug") {
            opt_debug = true;
            continue;
        }
        if argparser.check_option("fullscreen") {
            opt_fullscreen = true;
            continue;
        }
    }

    SetTraceLogLevel(LOG_WARNING);
    SetConfigFlags(FLAG_MSAA_4X_HINT);
    InitWindow(800, 600, startof("NATAC"));
    defer CloseWindow();
    SetTargetFPS(60);
    if opt_fullscreen {
        ToggleFullscreen();
    }

    # The radius of the outer circle touching the corners of the hexagon.
    let HEX_RADIUS = 48.0f32;

    var sstate = server_state::init();
    defer sstate.fini();
    var cstate = client_state::init();
    defer cstate.fini();
    cstate.debug = opt_debug;
    cstate.player = player::RED;

    for not WindowShouldClose() {
        var message = sstate.to_server_message();
        cstate.update_from_server_message(&message);
        message.fini();

        if IsKeyPressed(KEY_F3) {
            cstate.debug = not cstate.debug;
        }
        if IsKeyPressed(KEY_F11) {
            ToggleFullscreen();
        }

        if IsKeyPressed(KEY_ONE) {
            cstate.player = player::RED;
        }
        if IsKeyPressed(KEY_TWO) {
            cstate.player = player::BLUE;
        }
        if IsKeyPressed(KEY_THREE) {
            cstate.player = player::WHITE;
        }
        if IsKeyPressed(KEY_FOUR) {
            cstate.player = player::ORANGE;
        }

        BeginDrawing();
        ClearBackground((:Color){.r = 0x66, .g = 0xBB, .b = 0xFF, .a = 0xFF});

        var render_w = GetRenderWidth();
        var render_h = GetRenderHeight();
        var render_center = (:Vector2){
            .x = (:f32)render_w / 2.0,
            .y = (:f32)render_h / 2.0,
        };
        var camera = (:Camera2D){
            .target = (:Vector2){
                .x = 0.0f32,
                .y = 0.0f32
            },
            .offset = render_center,
            .rotation = 0.0f32,
            .zoom = camera_zoom(HEX_RADIUS, (:f32)render_h),
        };

        BeginMode2D(camera);

        var iter = std::hash_map_iterator[[hex, tile]]::init(&cstate.tiles);
        for iter.advance() {
            var tile = iter.current().*.value;
            var point = pointy_hex_to_point(tile.*.hex, HEX_RADIUS);
            draw_pointy_hexagon(point, HEX_RADIUS, tile_color(*tile));
            var resource = tile.*.resource();
            if resource.is_value() {
                draw_number_token(point, tile.*.number_token, HEX_RADIUS, cstate.font);
            }
        }

        var mouse = GetMousePosition();
        var world = GetScreenToWorld2D(mouse, camera);
        var world_hex = point_to_pointy_hex(world, HEX_RADIUS);
        var world_hex_center = pointy_hex_to_point(world_hex, HEX_RADIUS);

        var world_tile = std::optional[[tile]]::EMPTY;
        var iter = std::hash_map_iterator[[hex, tile]]::init(&cstate.tiles);
        for iter.advance() {
            if std::eq[[hex]](iter.current().*.key, &world_hex) {
                world_tile = std::optional[[tile]]::init_value(*iter.current().*.value);
                draw_pointy_hexagon_outline(world_hex_center, HEX_RADIUS, YELLOW);
                break;
            }
        }

        var world_edge = std::optional[[edge]]::EMPTY;
        var iter = std::hash_set_iterator[[edge]]::init(&cstate.edges);
        for iter.advance() {
            var found = true;
            for i in countof(iter.current().*.hexes) {
                let DISTANCE = HEX_RADIUS * 1.2;
                var hex = iter.current().*.hexes[i];
                if vec2_distance(world, pointy_hex_to_point(hex, HEX_RADIUS)) > DISTANCE {
                    found = false;
                    break;
                }
            }

            if found {
                world_edge = std::optional[[edge]]::init_value(*iter.current());
                for i in countof(iter.current().*.hexes) {
                    var point = pointy_hex_to_point(iter.current().*.hexes[i], HEX_RADIUS);
                    draw_pointy_hexagon_outline(point, HEX_RADIUS, ORANGE);
                }
                break;
            }
        }

        var world_node = std::optional[[node]]::EMPTY;
        var iter = std::hash_set_iterator[[node]]::init(&cstate.nodes);
        for iter.advance() {
            var found = true;
            for i in countof(iter.current().*.hexes) {
                let DISTANCE = HEX_RADIUS * 1.2;
                var hex = iter.current().*.hexes[i];
                if vec2_distance(world, pointy_hex_to_point(hex, HEX_RADIUS)) > DISTANCE {
                    found = false;
                    break;
                }
            }

            if found {
                world_node = std::optional[[node]]::init_value(*iter.current());
                for i in countof(iter.current().*.hexes) {
                    var point = pointy_hex_to_point(iter.current().*.hexes[i], HEX_RADIUS);
                    draw_pointy_hexagon_outline(point, HEX_RADIUS, RED);
                }
                break;
            }
        }

        if world_node.is_value() and IsMouseButtonPressed(MOUSE_BUTTON_LEFT) {
            var existing = sstate.towns.lookup(world_node.value());
            if existing.is_value() and existing.value().player == cstate.player {
                sstate.place_town(town::init(
                    cstate.player,
                    world_node.value(),
                    town::CITY));
            }
            else {
                sstate.place_town(town::init(
                    cstate.player,
                    world_node.value(),
                    town::SETTLEMENT));
            }
        }
        elif world_edge.is_value() and IsMouseButtonPressed(MOUSE_BUTTON_LEFT) {
            var tile_a = sstate.tiles.lookup(world_edge.value().hexes[0]);
            var tile_b = sstate.tiles.lookup(world_edge.value().hexes[1]);
            assert tile_a.is_value() and tile_b.is_value();
            var is_road_across_water =
                tile_a.value().kind == tile::OCEAN and
                tile_b.value().kind == tile::OCEAN;
            if not is_road_across_water {
                sstate.place_road(road::init(
                    cstate.player,
                    world_edge.value()));
            }
        }
        elif world_node.is_value() and IsMouseButtonDown(MOUSE_BUTTON_RIGHT) {
            sstate.remove_town(world_node.value());
        }
        elif world_edge.is_value() and IsMouseButtonDown(MOUSE_BUTTON_RIGHT) {
            sstate.remove_road(world_edge.value());
        }

        var iter = std::hash_map_iterator[[hex, tile]]::init(&cstate.tiles);
        for iter.advance() {
            var tile = iter.current().*.value;
            if tile.*.kind == ::tile::OCEAN {
                continue;
            }
            var point = pointy_hex_to_point(tile.*.hex, HEX_RADIUS);
            draw_pointy_hexagon_border(point, HEX_RADIUS, BLACK);
        }

        var iter = std::hash_set_iterator[[port]]::init(&cstate.ports);
        for iter.advance() {
            var port = iter.current();
            draw_port(*port, HEX_RADIUS, cstate.font);
        }

        var iter = std::hash_map_iterator[[edge, road]]::init(&cstate.roads);
        for iter.advance() {
            var road = iter.current().*.value;
            var points = edge_to_points(road.*.edge, HEX_RADIUS);
            draw_road(points[0], points[1], HEX_RADIUS, player_color(road.*.player));
        }

        var iter = std::hash_map_iterator[[node, town]]::init(&cstate.towns);
        for iter.advance() {
            var town = iter.current().*.value;
            switch town.*.kind {
            ::town::SETTLEMENT {
                draw_settlement(node_to_point(town.*.node, HEX_RADIUS), HEX_RADIUS, player_color(town.*.player));
            }
            ::town::CITY {
                draw_city(node_to_point(town.*.node, HEX_RADIUS), HEX_RADIUS, player_color(town.*.player));
            }
            }
        }

        if world_node.is_value() {
            var world_node = world_node.value();
            var world_node_point = node_to_point(world_node, HEX_RADIUS);
            draw_circle(world_node_point, 6.0, RED);
            draw_circle_outline(world_node_point, 6.0, 1.0, BLACK);
        }
        elif world_edge.is_value() {
            var world_edge = world_edge.value();
            var points = edge_to_points(world_edge, HEX_RADIUS);
            draw_circle(points[0], 6.0, ORANGE);
            draw_circle(points[1], 6.0, ORANGE);
            draw_circle_outline(points[0], 6.0, 1.0, BLACK);
            draw_circle_outline(points[1], 6.0, 1.0, BLACK);
        }
        else {
            draw_circle(world_hex_center, 6.0, YELLOW);
            draw_circle_outline(world_hex_center, 6.0, 1.0, BLACK);
        }

        draw_robber(pointy_hex_to_point(cstate.robber, HEX_RADIUS), HEX_RADIUS);

        EndMode2D();

        if cstate.debug {
            var fps = GetFPS();
            draw_text_format(cstate.font, cstate.font_size, BLACK,
                (:Vector2){.x = 2.0, .y = 0.0},
                "FPS {}",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(fps)]](&fps)]);

            draw_text_format(cstate.font, cstate.font_size, BLACK,
                (:Vector2){.x = 2.0, .y = 1.0 * cstate.font_size},
                "MOUSE: x={.0}, y={.0}",
                (:[]std::formatter)[
                    std::formatter::init[[f32]](&mouse.x),
                    std::formatter::init[[f32]](&mouse.y)]);

            draw_text_format(cstate.font, cstate.font_size, BLACK,
                (:Vector2){.x = 2.0, .y = 2.0 * cstate.font_size},
                "WORLD: x={.0}, y={.0}",
                (:[]std::formatter)[
                    std::formatter::init[[f32]](&world.x),
                    std::formatter::init[[f32]](&world.y)]);

            draw_text_format(cstate.font, cstate.font_size, BLACK,
                (:Vector2){.x = 2.0, .y = 3.0 * cstate.font_size},
                "WORLD->HEX: q={}, r={}, s={}",
                (:[]std::formatter)[
                    std::formatter::init[[sint]](&world_hex.q),
                    std::formatter::init[[sint]](&world_hex.r),
                    std::formatter::init[[sint]](&world_hex.s)]);

            draw_text_format(cstate.font, cstate.font_size, BLACK,
                (:Vector2){.x = 2.0, .y = 4.0 * cstate.font_size},
                "WORLD->HEX->WORLD: x={.0}, y={.0}",
                (:[]std::formatter)[
                    std::formatter::init[[f32]](&world_hex_center.x),
                    std::formatter::init[[f32]](&world_hex_center.y)]);

            if world_node.is_value() {
                var world_node = world_node.value();
                draw_text_format(cstate.font, cstate.font_size, BLACK,
                    (:Vector2){.x = 2.0, .y = 5.0 * cstate.font_size},
                    "NODE: {}",
                    (:[]std::formatter)[
                        std::formatter::init[[node]](&world_node)]);
            }
            elif world_edge.is_value() {
                var world_edge = world_edge.value();
                draw_text_format(cstate.font, cstate.font_size, BLACK,
                    (:Vector2){.x = 2.0, .y = 5.0 * cstate.font_size},
                    "EDGE: {}",
                    (:[]std::formatter)[
                        std::formatter::init[[edge]](&world_edge)]);
            }
            elif world_tile.is_value() {
                var world_tile = world_tile.value();
                draw_text_format(cstate.font, cstate.font_size, BLACK,
                    (:Vector2){.x = 2.0, .y = 5.0 * cstate.font_size},
                    "TILE: {} {verbose}",
                    (:[]std::formatter)[
                        std::formatter::init[[hex]](&world_tile.hex),
                        std::formatter::init[[tile]](&world_tile)]);
            }

            let SQUARE_SIZE = (:Vector2){.x = 32.0, .y = 32.0};
            let SQUARE_OFFSET = 8.0f32;
            let SQUARE_BORDER = 2.0f32;
            var square_xpos = (:f32)render_w - 4.0 * SQUARE_SIZE.x - 4.0 * SQUARE_OFFSET;
            var square_ypos = SQUARE_OFFSET;

            var square_background = BLACK;
            if cstate.player == player::RED {
                square_background = YELLOW;
            }
            DrawRectangleV(
                (:Vector2){
                    .x = square_xpos - SQUARE_BORDER + SQUARE_SIZE.x * 0.0 + SQUARE_OFFSET * 0.0,
                    .y = square_ypos - SQUARE_BORDER,
                },
                (:Vector2){
                    .x = SQUARE_SIZE.x + 2.0 * SQUARE_BORDER,
                    .y = SQUARE_SIZE.y + 2.0 * SQUARE_BORDER,
                },
                square_background);
            DrawRectangleV(
                (:Vector2){
                    .x = square_xpos + SQUARE_SIZE.x * 0.0 + SQUARE_OFFSET * 0.0,
                    .y = square_ypos,
                },
                SQUARE_SIZE,
                player_color(player::RED));

            var square_background = BLACK;
            if cstate.player == player::BLUE {
                square_background = YELLOW;
            }
            DrawRectangleV(
                (:Vector2){
                    .x = square_xpos - SQUARE_BORDER + SQUARE_SIZE.x * 1.0 + SQUARE_OFFSET * 1.0,
                    .y = square_ypos - SQUARE_BORDER,
                },
                (:Vector2){
                    .x = SQUARE_SIZE.x + 2.0 * SQUARE_BORDER,
                    .y = SQUARE_SIZE.y + 2.0 * SQUARE_BORDER,
                },
                square_background);
            DrawRectangleV(
                (:Vector2){
                    .x = square_xpos + SQUARE_SIZE.x * 1.0 + SQUARE_OFFSET * 1.0,
                    .y = square_ypos,
                },
                SQUARE_SIZE,
                player_color(player::BLUE));

            var square_background = BLACK;
            if cstate.player == player::WHITE {
                square_background = YELLOW;
            }
            DrawRectangleV(
                (:Vector2){
                    .x = square_xpos - SQUARE_BORDER + SQUARE_SIZE.x * 2.0 + SQUARE_OFFSET * 2.0,
                    .y = square_ypos - SQUARE_BORDER,
                },
                (:Vector2){
                    .x = SQUARE_SIZE.x + 2.0 * SQUARE_BORDER,
                    .y = SQUARE_SIZE.y + 2.0 * SQUARE_BORDER,
                },
                square_background);
            DrawRectangleV(
                (:Vector2){
                    .x = square_xpos + SQUARE_SIZE.x * 2.0 + SQUARE_OFFSET * 2.0,
                    .y = square_ypos,
                },
                SQUARE_SIZE,
                player_color(player::WHITE));

            var square_background = BLACK;
            if cstate.player == player::ORANGE {
                square_background = YELLOW;
            }
            DrawRectangleV(
                (:Vector2){
                    .x = square_xpos - SQUARE_BORDER + SQUARE_SIZE.x * 3.0 + SQUARE_OFFSET * 3.0,
                    .y = square_ypos - SQUARE_BORDER,
                },
                (:Vector2){
                    .x = SQUARE_SIZE.x + 2.0 * SQUARE_BORDER,
                    .y = SQUARE_SIZE.y + 2.0 * SQUARE_BORDER,
                },
                square_background);
            DrawRectangleV(
                (:Vector2){
                    .x = square_xpos + SQUARE_SIZE.x * 3.0 + SQUARE_OFFSET * 3.0,
                    .y = square_ypos,
                },
                SQUARE_SIZE,
                player_color(player::ORANGE));
        }

        EndDrawing();
    }
}
