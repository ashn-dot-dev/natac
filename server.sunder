import "c";
import "std";

import "shared.sunder";

struct connection {
    var player: player;
    var sender: message_sender[[server_message]];

    # Send a server message to the connection.
    func send(self: *connection, message: *server_message) void {
        self.*.sender.send(message);
    }

    # Send a server message to the connection, then consume the message.
    func sendc(self: *connection, message: server_message) void {
        self.*.sender.send(&message);
        message.fini();
    }
}

struct server_state {
    var connections: std::vector[[connection]];
    var ticks: usize;
    var board: board;
    var rhand: hand;
    var bhand: hand;
    var whand: hand;
    var ohand: hand;
    var turn: turn;

    func init() server_state {
        return (:server_state){
            .connections = std::vector[[connection]]::init(),
            .ticks = 0,
            .board = board::init_starter_map_for_beginners(),
            .rhand = uninit,
            .bhand = uninit,
            .whand = uninit,
            .ohand = uninit,
            .turn = turn::init(player::NIL),
        };
    }

    func fini(self: *server_state) void {
        self.*.connections.fini();
        self.*.board.fini();
    }

    # Send a server message to all connections.
    func send_all(self: *server_state, message: *server_message) void {
        for i in self.*.connections.count() {
            self.*.connections.data()[i].send(message);
        }
    }

    # Send a server message to all connections, then consume the message.
    func sendc_all(self: *server_state, message: server_message) void {
        self.*.send_all(&message);
        message.fini();
    }

    func phand(self: *server_state, player: player) *hand {
        switch player {
        ::player::NIL {
            std::unreachable(fileof(), lineof());
        }
        ::player::RED {
            return &self.*.rhand;
        }
        ::player::BLUE {
            return &self.*.bhand;
        }
        ::player::WHITE {
            return &self.*.whand;
        }
        ::player::ORANGE {
            return &self.*.ohand;
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[*hand]]();
    }

    func change_turn(self: *server_state, player: player) void {
        self.*.turn = turn::init(player);
        var name = player_to_name(player);
        self.*.sendc_all(server_message::init_log_format(
            "It's {}'s turn!",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));
    }

    func process_roll(self: *server_state, connection: *connection) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot roll dice (it is not your turn)"));
            return;
        }
        if self.*.turn.phase != phase::RESOURCE_PRODUCTION {
            connection.*.sendc(server_message::init_rejected("cannot roll dice (it is not the resource production phase)"));
            return;
        }

        var roll_a = d6();
        var roll_b = d6();
        var roll = roll_a + roll_b;
        self.*.board.d6_a = roll_a;
        self.*.board.d6_b = roll_b;

        connection.*.sendc(server_message::init_accepted_format(
            "rolled {} + {} = {}",
            (:[]std::formatter)[
                std::formatter::init[[typeof(roll_a)]](&roll_a),
                std::formatter::init[[typeof(roll_b)]](&roll_b),
                std::formatter::init[[typeof(roll)]](&roll)]));
        var name = player_to_name(connection.*.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} rolled {} + {} = {}.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name),
                std::formatter::init[[typeof(roll_a)]](&roll_a),
                std::formatter::init[[typeof(roll_b)]](&roll_b),
                std::formatter::init[[typeof(roll)]](&roll)]));

        if roll == 7 {
            self.*.sendc_all(server_message::init_log("TODO: discard resources + robber"));
        }
        else {
            var iter = std::hash_map_iterator[[node, town]]::init(&self.*.board.towns);
            for iter.advance() {
                var amount: sint = uninit;
                var town = *iter.current().*.value;
                switch town.kind {
                ::town::SETTLEMENT {
                    amount = 1;
                }
                ::town::CITY {
                    amount = 2;
                }
                }
                var node = *iter.current().*.key;
                for i in countof(node.hexes) {
                    var tile = self.*.board.tiles.lookup(node.hexes[i]);
                    var tile = tile.value();
                    if tile.number != roll {
                        continue;
                    }
                    var hand = self.*.phand(town.player);
                    hand.*.brick += amount * (:sint)(tile.kind == ::tile::HILL);
                    hand.*.ore += amount * (:sint)(tile.kind == ::tile::MOUNTAIN);
                    hand.*.sheep += amount * (:sint)(tile.kind == ::tile::PASTURE);
                    hand.*.wheat += amount * (:sint)(tile.kind == ::tile::FIELD);
                    hand.*.wood += amount * (:sint)(tile.kind == ::tile::FOREST);
                }
            }
        }
        self.*.turn.phase = phase::MAIN;
    }

    func process_end_turn(self: *server_state, connection: *connection) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot end turn (it is not your turn)"));
            return;
        }
        if self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("cannot end turn (it is not the main)"));
            return;
        }

        connection.*.sendc(server_message::init_accepted("ended turn"));
        var name = player_to_name(connection.*.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} ended their turn.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));

        if self.*.turn.player == player::RED {
            self.*.change_turn(player::BLUE);
        }
        elif self.*.turn.player == player::BLUE {
            self.*.change_turn(player::WHITE);
        }
        elif self.*.turn.player == player::WHITE {
            self.*.change_turn(player::ORANGE);
        }
        elif self.*.turn.player == player::ORANGE {
            self.*.change_turn(player::RED);
        }
    }


    func process_build_road(self: *server_state, connection: *connection, road: road) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot build road (it is not your turn)"));
            return;
        }
        if self.*.turn.player != road.player {
            connection.*.sendc(server_message::init_rejected("cannot build road (it is not your road)"));
            return;
        }
        if self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("cannot build road (it is not the main phase)"));
            return;
        }

        var tile_a = self.*.board.tiles.lookup(road.edge.hexes[0]);
        var tile_b = self.*.board.tiles.lookup(road.edge.hexes[1]);
        var is_road_across_water =
            tile_a.value().kind == tile::OCEAN and
            tile_b.value().kind == tile::OCEAN;
        if is_road_across_water {
            connection.*.sendc(server_message::init_rejected("cannot build road (cannot build on water)"));
            return;
        }

        var existing = self.*.board.roads.lookup(road.edge);
        if existing.is_value() {
            connection.*.sendc(server_message::init_rejected("cannot build road (road exists at location)"));
            return;
        }

        var adjacent_edges = adjacent_edges_to_edge(road.edge, &self.*.board.edges, &self.*.board.nodes);
        defer adjacent_edges.fini();
        var adjacent_roads = std::hash_set[[::road]]::init();
        defer adjacent_roads.fini();
        var iter = std::hash_set_iterator[[edge]]::init(&adjacent_edges);
        for iter.advance() {
            var adjacent = self.*.board.roads.lookup(*iter.current());
            if adjacent.is_empty() {
                continue;
            }
            var adjacent = adjacent.value();
            if adjacent.player != road.player {
                continue;
            }
            adjacent_roads.insert(adjacent);
        }
        var adjacent_nodes = adjacent_nodes_to_edge(road.edge, &self.*.board.nodes);
        defer adjacent_nodes.fini();
        var adjacent_towns = std::hash_set[[town]]::init();
        defer adjacent_towns.fini();
        var iter = std::hash_set_iterator[[node]]::init(&adjacent_nodes);
        for iter.advance() {
            var adjacent = self.*.board.towns.lookup(*iter.current());
            if adjacent.is_empty() {
                continue;
            }
            var adjacent = adjacent.value();
            if adjacent.player != road.player {
                continue;
            }
            adjacent_towns.insert(adjacent);
        }
        if adjacent_roads.count() == 0 and adjacent_towns.count() == 0 {
            connection.*.sendc(server_message::init_rejected("cannot build road (no adjacent road or town)"));
            return;
        }

        var unobstructed_road_count = 0u;
        var iter = std::hash_set_iterator[[::road]]::init(&adjacent_roads);
        for iter.advance() {
            var a = adjacent_nodes_to_edge(road.edge, &self.*.board.nodes);
            defer a.fini();
            var b = adjacent_nodes_to_edge(iter.current().*.edge, &self.*.board.nodes);
            defer b.fini();
            var i = std::hash_set[[node]]::init_intersection(&a, &b);
            defer i.fini();
            assert i.count() == 1;
            var iter = std::hash_set_iterator[[node]]::init(&i);
            iter.advance();
            var town = self.*.board.towns.lookup(*iter.current());
            if town.is_empty() {
                # No town between the two road pieces.
                unobstructed_road_count = unobstructed_road_count + 1;
                continue;
            }
            var town = town.value();
            if town.player == road.player {
                # Town between the two road pieces belongs to the player
                # placing the road.
                unobstructed_road_count = unobstructed_road_count + 1;
                continue;
            }
        }
        if adjacent_towns.count() == 0 and unobstructed_road_count == 0 {
            connection.*.sendc(server_message::init_rejected("cannot build road (road is obstructed by town)"));
            return;
        }

        var player_road_count = 0u;
        var iter = std::hash_map_iterator[[edge, ::road]]::init(&self.*.board.roads);
        for iter.advance() {
            if iter.current().*.value.*.player == road.player {
                player_road_count = player_road_count + 1;
            }
        }
        if player_road_count >= 15 {
            connection.*.sendc(server_message::init_rejected("cannot build road (all roads placed)"));
            return;
        }

        var hand = self.*.phand(self.*.turn.player);
        if not (hand.*.brick >= 1 and hand.*.wood >= 1) {
            connection.*.sendc(server_message::init_rejected("cannot build road (insufficient resources)"));
            return;
        }

        hand.*.brick -= 1;
        hand.*.wood -= 1;
        insert_road(&self.*.board.roads, road);

        connection.*.sendc(server_message::init_accepted("built road"));
        var name = player_to_name(self.*.turn.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} built a road.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));
    }

    func process_build_town(self: *server_state, connection: *connection, town: town) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot build town (it is not your turn)"));
            return;
        }
        if self.*.turn.player != town.player {
            connection.*.sendc(server_message::init_rejected("cannot build town (it is not your town)"));
            return;
        }
        if self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("cannot build town (it is not the main phase)"));
            return;
        }

        var existing = self.*.board.towns.lookup(town.node);
        if existing.is_value() {
            var existing = existing.value();
            # Special case for upgrading a settlement to a city.
            if not (existing.player == town.player and existing.kind == ::town::SETTLEMENT and town.kind == ::town::CITY) {
                connection.*.sendc(server_message::init_rejected("cannot build town (town exists at location)"));
                return;
            }
        }

        var adjacent_nodes = adjacent_nodes_to_node(town.node, &self.*.board.nodes);
        defer adjacent_nodes.fini();
        var adjacent_town_count = 0u;
        var iter = std::hash_set_iterator[[node]]::init(&adjacent_nodes);
        for iter.advance() {
            if self.*.board.towns.contains(*iter.current()) {
                adjacent_town_count = adjacent_town_count + 1;
            }
        }
        if adjacent_town_count != 0 {
            connection.*.sendc(server_message::init_rejected("cannot build town (adjacent town)"));
            return;
        }

        var adjacent_edges = adjacent_edges_to_node(town.node, &self.*.board.edges);
        defer adjacent_edges.fini();
        var is_road_adjacent = false;
        var iter = std::hash_set_iterator[[edge]]::init(&adjacent_edges);
        for iter.advance() {
            var adjacent = self.*.board.roads.lookup(*iter.current());
            if adjacent.is_empty() {
                continue;
            }
            var adjacent = adjacent.value();
            if adjacent.player != town.player {
                continue;
            }

            is_road_adjacent = true;
        }
        if not is_road_adjacent {
            connection.*.sendc(server_message::init_rejected("cannot build town (no adjacent road)"));
            return;
        }

        var player_town_count = 0u;
        var iter = std::hash_map_iterator[[node, ::town]]::init(&self.*.board.towns);
        for iter.advance() {
            if iter.current().*.value.*.player == town.player and iter.current().*.value.*.kind == town.kind {
                player_town_count = player_town_count + 1;
            }
        }
        if town.kind == ::town::SETTLEMENT and player_town_count >= 5 {
            connection.*.sendc(server_message::init_rejected("cannot build town (all settlements placed)"));
            return;
        }
        if town.kind == ::town::CITY and player_town_count >= 4 {
            connection.*.sendc(server_message::init_rejected("cannot build town (all cities placed)"));
            return;
        }

        var hand = self.*.phand(self.*.turn.player);
        switch town.kind {
        ::town::SETTLEMENT {
            if not (hand.*.brick >= 1 and hand.*.sheep >= 1 and hand.*.wheat >= 1 and hand.*.wood >= 1) {
                connection.*.sendc(server_message::init_rejected("cannot build road (insufficient resources)"));
                return;
            }
            hand.*.brick -= 1;
            hand.*.sheep -= 1;
            hand.*.wheat -= 1;
            hand.*.wood -= 1;
        }
        ::town::CITY {
            if not (hand.*.ore >= 3 and hand.*.wheat >= 2) {
                connection.*.sendc(server_message::init_rejected("cannot build road (insufficient resources)"));
                return;
            }
            hand.*.ore -= 3;
            hand.*.wheat -= 2;
        }
        }
        insert_town(&self.*.board.towns, town);

        connection.*.sendc(server_message::init_accepted("built town"));
        var name = player_to_name(self.*.turn.player);
        var kind = "settlement";
        if town.kind == ::town::CITY {
            kind = "city";
        }
        self.*.sendc_all(server_message::init_log_format(
            "{} built a {}.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name),
                std::formatter::init[[typeof(kind)]](&kind)]));
    }

    func process_move_robber(self: *server_state, connection: *connection, hex: hex) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot move robber (it is not your turn)"));
            return;
        }
        # TODO: The robber should only be able to get moved during a specific
        # "move robber" turn phase. Currently is can always be moved during any
        # player's main phase.
        if self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("cannot move robber (it is not the main phase)"));
            return;
        }

        if std::eq[[::hex]](&hex, &self.*.board.robber) {
            connection.*.sendc(server_message::init_rejected("cannot move robber (robber already at location)"));
            return;
        }

        var tile = self.*.board.tiles.lookup(hex);
        if tile.is_empty() {
            connection.*.sendc(server_message::init_rejected("cannot move robber (invalid location)"));
            return;
        }

        var tile = tile.value();
        if tile.kind == ::tile::OCEAN {
            connection.*.sendc(server_message::init_rejected("cannot move robber (tile is ocean)"));
            return;
        }

        self.*.board.robber = hex;
        connection.*.sendc(server_message::init_accepted("moved robber"));
        var name = player_to_name(self.*.turn.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} moved the robber.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));
    }

    func process_select_player(self: *server_state, connection: *connection, selected: player) void {
        if connection.*.player == selected {
            connection.*.sendc(server_message::init_rejected("cannot select player (you are already that player)"));
            return;
        }

        for i in self.*.connections.count() {
            if &self.*.connections.data()[i] == connection {
                continue;
            }
            if self.*.connections.data()[i].player != selected {
                continue;
            }
            connection.*.sendc(server_message::init_rejected("cannot select player (someone else is already that player)"));
            return;
        }

        var was = player_to_name(connection.*.player);
        connection.*.player = selected;
        if connection.*.player != player::NIL {
            var hand = self.*.phand(connection.*.player);
            connection.*.sendc(server_message::init_hand(*hand));
        }

        var name = player_to_name(selected);
        connection.*.sendc(server_message::init_accepted_format(
            "selected player {}",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));
        connection.*.sendc(server_message::init_player(selected));

        self.*.sendc_all(server_message::init_log_format(
            "{} is now playing as {}.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(was)]](&was),
                std::formatter::init[[typeof(name)]](&name)]));
    }

    func update_from_client_message(self: *server_state, message: *client_message, connection: *connection) void {
        switch message.*.kind {
        client_message::ROLL {
            self.*.process_roll(connection);
        }
        client_message::END_TURN {
            self.*.process_end_turn(connection);
        }
        client_message::BUILD_ROAD {
            self.*.process_build_road(connection, message.*.data.build_road);
        }
        client_message::BUILD_TOWN {
            self.*.process_build_town(connection, message.*.data.build_town);
        }
        client_message::MOVE_ROBBER {
            self.*.process_move_robber(connection, message.*.data.move_robber);
        }
        client_message::SELECT_PLAYER {
            self.*.process_select_player(connection, message.*.data.select_player);
        }
        }
    }
}

func server_update(sstate: *server_state) void {
    # Initial server messages sent on the first game tick.
    if sstate.*.ticks == 0 {
        sstate.*.sendc_all(server_message::init_log("Welcome to Natac!"));
        sstate.*.change_turn(player::RED);
    }

    # The state of the board changes relatively infrequently, so it is not
    # necessary to serialize and send the entire board state every game tick.
    if sstate.*.ticks % 4 == 0 {
        sstate.*.sendc_all(server_message::init_state(
            &sstate.*.board,
            sstate.*.rhand.resources(),
            sstate.*.bhand.resources(),
            sstate.*.whand.resources(),
            sstate.*.ohand.resources(),
            sstate.*.turn));

        for i in sstate.*.connections.count() {
            if sstate.*.connections.data()[i].player == player::NIL {
                continue;
            }
            var hand = sstate.*.phand(sstate.*.connections.data()[i].player);
            sstate.*.connections.data()[i].sendc(server_message::init_hand(*hand));
        }
    }

    sstate.*.ticks +%= 1;
}
