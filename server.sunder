import "c";
import "std";

import "shared.sunder";

struct connection {
    var player: player;
    var sender: message_sender[[server_message]];

    # Send a server message to the connection.
    func send(self: *connection, message: *server_message) void {
        self.*.sender.send(message);
    }

    # Send a server message to the connection, then consume the message.
    func sendc(self: *connection, message: server_message) void {
        self.*.sender.send(&message);
        message.fini();
    }
}

struct server_state {
    var connections: std::vector[[connection]];
    var ticks: usize;
    var board: board;
    var r_info: hidden_player_info;
    var b_info: hidden_player_info;
    var w_info: hidden_player_info;
    var o_info: hidden_player_info;
    var r_discarded: bool;
    var b_discarded: bool;
    var w_discarded: bool;
    var o_discarded: bool;
    var turn: turn;

    func init() server_state {
        return (:server_state){
            .connections = std::vector[[connection]]::init(),
            .ticks = 0,
            .board = board::init_starter_map_for_beginners(),
            .r_info = uninit,
            .b_info = uninit,
            .w_info = uninit,
            .o_info = uninit,
            .r_discarded = false,
            .b_discarded = false,
            .w_discarded = false,
            .o_discarded = false,
            .turn = turn::init(player::NIL),
        };
    }

    func fini(self: *server_state) void {
        self.*.connections.fini();
        self.*.board.fini();
    }

    # Send a server message to all connections.
    func send_all(self: *server_state, message: *server_message) void {
        for i in self.*.connections.count() {
            self.*.connections.data()[i].send(message);
        }
    }

    # Send a server message to all connections, then consume the message.
    func sendc_all(self: *server_state, message: server_message) void {
        self.*.send_all(&message);
        message.fini();
    }

    func p_info(self: *server_state, player: player) *hidden_player_info {
        switch player {
        ::player::NIL {
            std::unreachable(fileof(), lineof());
        }
        ::player::RED {
            return &self.*.r_info;
        }
        ::player::BLUE {
            return &self.*.b_info;
        }
        ::player::WHITE {
            return &self.*.w_info;
        }
        ::player::ORANGE {
            return &self.*.o_info;
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[*hidden_player_info]]();
    }

    func p_discarded(self: *server_state, player: player) *bool {
        switch player {
        ::player::NIL {
            std::unreachable(fileof(), lineof());
        }
        ::player::RED {
            return &self.*.r_discarded;
        }
        ::player::BLUE {
            return &self.*.b_discarded;
        }
        ::player::WHITE {
            return &self.*.w_discarded;
        }
        ::player::ORANGE {
            return &self.*.o_discarded;
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[*bool]]();
    }

    func change_turn(self: *server_state, player: player) void {
        self.*.turn = turn::init(player);
        var name = player_to_name(player);
        self.*.sendc_all(server_message::init_log_format(
            "It's {}'s turn!",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));
    }

    func process_roll(self: *server_state, connection: *connection) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot roll dice (it is not your turn)"));
            return;
        }
        if self.*.turn.phase != phase::RESOURCE_PRODUCTION {
            connection.*.sendc(server_message::init_rejected("cannot roll dice (it is not the resource production phase)"));
            return;
        }

        var roll_a = d6();
        var roll_b = d6();
        var roll = roll_a + roll_b;
        self.*.board.d6_a = roll_a;
        self.*.board.d6_b = roll_b;

        connection.*.sendc(server_message::init_accepted_format(
            "rolled {} + {} = {}",
            (:[]std::formatter)[
                std::formatter::init[[typeof(roll_a)]](&roll_a),
                std::formatter::init[[typeof(roll_b)]](&roll_b),
                std::formatter::init[[typeof(roll)]](&roll)]));
        var name = player_to_name(connection.*.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} rolled {} + {} = {}.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name),
                std::formatter::init[[typeof(roll_a)]](&roll_a),
                std::formatter::init[[typeof(roll_b)]](&roll_b),
                std::formatter::init[[typeof(roll)]](&roll)]));

        if roll == 7 {
            if (self.*.r_info.resource_count() <= 7)
            and (self.*.b_info.resource_count() <= 7)
            and (self.*.w_info.resource_count() <= 7)
            and (self.*.o_info.resource_count() <= 7) {
                self.*.sendc_all(server_message::init_log("No players need to discard."));
                var name = player_to_name(self.*.turn.player);
                self.*.sendc_all(server_message::init_log_format(
                    "Waiting for {} to move the robber.",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(name)]](&name)]));
                self.*.turn.phase = phase::ROBBER;
            }
            else {
                self.*.sendc_all(server_message::init_log("Waiting for all players to discard."));
                self.*.r_discarded = self.*.r_info.resource_count() <= 7;
                self.*.b_discarded = self.*.b_info.resource_count() <= 7;
                self.*.w_discarded = self.*.w_info.resource_count() <= 7;
                self.*.o_discarded = self.*.o_info.resource_count() <= 7;
                self.*.turn.phase = phase::DISCARD;
            }
            return;
        }

        var iter = std::hash_map_iterator[[node, town]]::init(&self.*.board.towns);
        for iter.advance() {
            var amount: sint = uninit;
            var town = *iter.current().*.value;
            switch town.kind {
            ::town::SETTLEMENT {
                amount = 1;
            }
            ::town::CITY {
                amount = 2;
            }
            }
            var node = *iter.current().*.key;
            for i in countof(node.hexes) {
                var tile = self.*.board.tiles.lookup(node.hexes[i]);
                var tile = tile.value();
                if tile.number != roll {
                    continue;
                }
                var info = self.*.p_info(town.player);
                info.*.brick += amount * (:sint)(tile.kind == ::tile::HILL);
                info.*.ore += amount * (:sint)(tile.kind == ::tile::MOUNTAIN);
                info.*.sheep += amount * (:sint)(tile.kind == ::tile::PASTURE);
                info.*.wheat += amount * (:sint)(tile.kind == ::tile::FIELD);
                info.*.wood += amount * (:sint)(tile.kind == ::tile::FOREST);
            }
        }
        self.*.turn.phase = phase::MAIN;
    }

    func process_end_turn(self: *server_state, connection: *connection) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot end turn (it is not your turn)"));
            return;
        }
        if self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("cannot end turn (it is not the main phase)"));
            return;
        }

        connection.*.sendc(server_message::init_accepted("ended turn"));
        var name = player_to_name(connection.*.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} ended their turn.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));

        if self.*.turn.player == player::RED {
            self.*.change_turn(player::BLUE);
        }
        elif self.*.turn.player == player::BLUE {
            self.*.change_turn(player::WHITE);
        }
        elif self.*.turn.player == player::WHITE {
            self.*.change_turn(player::ORANGE);
        }
        elif self.*.turn.player == player::ORANGE {
            self.*.change_turn(player::RED);
        }
    }


    func process_build_road(self: *server_state, connection: *connection, road: road) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot build road (it is not your turn)"));
            return;
        }
        if self.*.turn.player != road.player {
            connection.*.sendc(server_message::init_rejected("cannot build road (it is not your road)"));
            return;
        }
        if self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("cannot build road (it is not the main phase)"));
            return;
        }

        var tile_a = self.*.board.tiles.lookup(road.edge.hexes[0]);
        var tile_b = self.*.board.tiles.lookup(road.edge.hexes[1]);
        var is_road_across_water =
            tile_a.value().kind == tile::OCEAN and
            tile_b.value().kind == tile::OCEAN;
        if is_road_across_water {
            connection.*.sendc(server_message::init_rejected("cannot build road (cannot build on water)"));
            return;
        }

        var existing = self.*.board.roads.lookup(road.edge);
        if existing.is_value() {
            connection.*.sendc(server_message::init_rejected("cannot build road (road exists at location)"));
            return;
        }

        var adjacent_edges = adjacent_edges_to_edge(road.edge, &self.*.board.edges, &self.*.board.nodes);
        defer adjacent_edges.fini();
        var adjacent_roads = std::hash_set[[::road]]::init();
        defer adjacent_roads.fini();
        var iter = std::hash_set_iterator[[edge]]::init(&adjacent_edges);
        for iter.advance() {
            var adjacent = self.*.board.roads.lookup(*iter.current());
            if adjacent.is_empty() {
                continue;
            }
            var adjacent = adjacent.value();
            if adjacent.player != road.player {
                continue;
            }
            adjacent_roads.insert(adjacent);
        }
        var adjacent_nodes = adjacent_nodes_to_edge(road.edge, &self.*.board.nodes);
        defer adjacent_nodes.fini();
        var adjacent_towns = std::hash_set[[town]]::init();
        defer adjacent_towns.fini();
        var iter = std::hash_set_iterator[[node]]::init(&adjacent_nodes);
        for iter.advance() {
            var adjacent = self.*.board.towns.lookup(*iter.current());
            if adjacent.is_empty() {
                continue;
            }
            var adjacent = adjacent.value();
            if adjacent.player != road.player {
                continue;
            }
            adjacent_towns.insert(adjacent);
        }
        if adjacent_roads.count() == 0 and adjacent_towns.count() == 0 {
            connection.*.sendc(server_message::init_rejected("cannot build road (no adjacent road or town)"));
            return;
        }

        var unobstructed_road_count = 0u;
        var iter = std::hash_set_iterator[[::road]]::init(&adjacent_roads);
        for iter.advance() {
            var a = adjacent_nodes_to_edge(road.edge, &self.*.board.nodes);
            defer a.fini();
            var b = adjacent_nodes_to_edge(iter.current().*.edge, &self.*.board.nodes);
            defer b.fini();
            var i = std::hash_set[[node]]::init_intersection(&a, &b);
            defer i.fini();
            assert i.count() == 1;
            var iter = std::hash_set_iterator[[node]]::init(&i);
            iter.advance();
            var town = self.*.board.towns.lookup(*iter.current());
            if town.is_empty() {
                # No town between the two road pieces.
                unobstructed_road_count = unobstructed_road_count + 1;
                continue;
            }
            var town = town.value();
            if town.player == road.player {
                # Town between the two road pieces belongs to the player
                # placing the road.
                unobstructed_road_count = unobstructed_road_count + 1;
                continue;
            }
        }
        if adjacent_towns.count() == 0 and unobstructed_road_count == 0 {
            connection.*.sendc(server_message::init_rejected("cannot build road (road is obstructed by town)"));
            return;
        }

        var player_road_count = 0u;
        var iter = std::hash_map_iterator[[edge, ::road]]::init(&self.*.board.roads);
        for iter.advance() {
            if iter.current().*.value.*.player == road.player {
                player_road_count = player_road_count + 1;
            }
        }
        if player_road_count >= 15 {
            connection.*.sendc(server_message::init_rejected("cannot build road (all roads placed)"));
            return;
        }

        var info = self.*.p_info(self.*.turn.player);
        if not (info.*.brick >= 1 and info.*.wood >= 1) {
            connection.*.sendc(server_message::init_rejected("cannot build road (insufficient resources)"));
            return;
        }

        info.*.brick -= 1;
        info.*.wood -= 1;
        insert_road(&self.*.board.roads, road);

        connection.*.sendc(server_message::init_accepted("built road"));
        var name = player_to_name(self.*.turn.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} built a road.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));
    }

    func process_build_town(self: *server_state, connection: *connection, town: town) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot build town (it is not your turn)"));
            return;
        }
        if self.*.turn.player != town.player {
            connection.*.sendc(server_message::init_rejected("cannot build town (it is not your town)"));
            return;
        }
        if self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("cannot build town (it is not the main phase)"));
            return;
        }

        var existing = self.*.board.towns.lookup(town.node);
        if existing.is_value() {
            var existing = existing.value();
            # Special case for upgrading a settlement to a city.
            if not (existing.player == town.player and existing.kind == ::town::SETTLEMENT and town.kind == ::town::CITY) {
                connection.*.sendc(server_message::init_rejected("cannot build town (town exists at location)"));
                return;
            }
        }

        var adjacent_nodes = adjacent_nodes_to_node(town.node, &self.*.board.nodes);
        defer adjacent_nodes.fini();
        var adjacent_town_count = 0u;
        var iter = std::hash_set_iterator[[node]]::init(&adjacent_nodes);
        for iter.advance() {
            if self.*.board.towns.contains(*iter.current()) {
                adjacent_town_count = adjacent_town_count + 1;
            }
        }
        if adjacent_town_count != 0 {
            connection.*.sendc(server_message::init_rejected("cannot build town (adjacent town)"));
            return;
        }

        var adjacent_edges = adjacent_edges_to_node(town.node, &self.*.board.edges);
        defer adjacent_edges.fini();
        var is_road_adjacent = false;
        var iter = std::hash_set_iterator[[edge]]::init(&adjacent_edges);
        for iter.advance() {
            var adjacent = self.*.board.roads.lookup(*iter.current());
            if adjacent.is_empty() {
                continue;
            }
            var adjacent = adjacent.value();
            if adjacent.player != town.player {
                continue;
            }

            is_road_adjacent = true;
        }
        if not is_road_adjacent {
            connection.*.sendc(server_message::init_rejected("cannot build town (no adjacent road)"));
            return;
        }

        var player_town_count = 0u;
        var iter = std::hash_map_iterator[[node, ::town]]::init(&self.*.board.towns);
        for iter.advance() {
            if iter.current().*.value.*.player == town.player and iter.current().*.value.*.kind == town.kind {
                player_town_count = player_town_count + 1;
            }
        }
        if town.kind == ::town::SETTLEMENT and player_town_count >= 5 {
            connection.*.sendc(server_message::init_rejected("cannot build town (all settlements placed)"));
            return;
        }
        if town.kind == ::town::CITY and player_town_count >= 4 {
            connection.*.sendc(server_message::init_rejected("cannot build town (all cities placed)"));
            return;
        }

        var info = self.*.p_info(self.*.turn.player);
        switch town.kind {
        ::town::SETTLEMENT {
            if not (info.*.brick >= 1 and info.*.sheep >= 1 and info.*.wheat >= 1 and info.*.wood >= 1) {
                connection.*.sendc(server_message::init_rejected("cannot build settlement (insufficient resources)"));
                return;
            }
            info.*.brick -= 1;
            info.*.sheep -= 1;
            info.*.wheat -= 1;
            info.*.wood -= 1;
        }
        ::town::CITY {
            if not (info.*.ore >= 3 and info.*.wheat >= 2) {
                connection.*.sendc(server_message::init_rejected("cannot build city (insufficient resources)"));
                return;
            }
            info.*.ore -= 3;
            info.*.wheat -= 2;
        }
        }
        insert_town(&self.*.board.towns, town);

        connection.*.sendc(server_message::init_accepted("built town"));
        var name = player_to_name(self.*.turn.player);
        var kind = "settlement";
        if town.kind == ::town::CITY {
            kind = "city";
        }
        self.*.sendc_all(server_message::init_log_format(
            "{} built a {}.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name),
                std::formatter::init[[typeof(kind)]](&kind)]));
    }

    func process_move_robber(self: *server_state, connection: *connection, hex: hex) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot move robber (it is not your turn)"));
            return;
        }
        if self.*.turn.phase != phase::ROBBER {
            connection.*.sendc(server_message::init_rejected("cannot move robber (it is not the robber phase)"));
            return;
        }

        if std::eq[[::hex]](&hex, &self.*.board.robber) {
            connection.*.sendc(server_message::init_rejected("cannot move robber (robber already at location)"));
            return;
        }

        var tile = self.*.board.tiles.lookup(hex);
        if tile.is_empty() {
            connection.*.sendc(server_message::init_rejected("cannot move robber (invalid location)"));
            return;
        }

        var tile = tile.value();
        if tile.kind == ::tile::OCEAN {
            connection.*.sendc(server_message::init_rejected("cannot move robber (tile is ocean)"));
            return;
        }

        self.*.board.robber = hex;
        connection.*.sendc(server_message::init_accepted("moved robber"));
        var name = player_to_name(self.*.turn.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} moved the robber.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));

        var adjacent_nodes = adjacent_nodes_to_hex(hex, &self.*.board.nodes);
        defer adjacent_nodes.fini();
        var iter = std::hash_set_iterator[[node]]::init(&adjacent_nodes);
        for iter.advance() {
            var optional = self.*.board.towns.lookup(*iter.current());
            if optional.is_empty() {
                continue;
            }
            var town = optional.value();
            if town.player == connection.*.player {
                continue;
            }
            if self.*.p_info(town.player).*.resource_count() != 0 {
                self.*.turn.phase = phase::STEAL;
                return;
            }
        }

        self.*.turn.phase = phase::MAIN;
    }

    func process_select_player(self: *server_state, connection: *connection, selected: player) void {
        if connection.*.player == selected {
            connection.*.sendc(server_message::init_rejected("cannot select player (you are already that player)"));
            return;
        }

        for i in self.*.connections.count() {
            if &self.*.connections.data()[i] == connection {
                continue;
            }
            if self.*.connections.data()[i].player != selected {
                continue;
            }
            connection.*.sendc(server_message::init_rejected("cannot select player (someone else is already that player)"));
            return;
        }

        var was = player_to_name(connection.*.player);
        connection.*.player = selected;
        if connection.*.player != player::NIL {
            var info = self.*.p_info(connection.*.player);
            connection.*.sendc(server_message::init_info(*info));
        }

        var name = player_to_name(selected);
        connection.*.sendc(server_message::init_accepted_format(
            "selected player {}",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));
        connection.*.sendc(server_message::init_player(selected));

        self.*.sendc_all(server_message::init_log_format(
            "{} is now playing as {}.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(was)]](&was),
                std::formatter::init[[typeof(name)]](&name)]));
    }

    func process_submit_player(self: *server_state, connection: *connection, player: player) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot submit player (it is not your turn)"));
            return;
        }
        if self.*.turn.phase != phase::STEAL {
            connection.*.sendc(server_message::init_rejected("cannot submit player (it is not the steal phase)"));
            return;
        }
        if self.*.turn.player == player {
            connection.*.sendc(server_message::init_rejected("cannot submit player (you cannot steal from yourself)"));
            return;
        }

        var t_name = player_to_name(self.*.turn.player);
        var f_name = player_to_name(player);

        var is_adjacent = false;
        var adjacent_nodes = adjacent_nodes_to_hex(self.*.board.robber, &self.*.board.nodes);
        defer adjacent_nodes.fini();
        var iter = std::hash_set_iterator[[node]]::init(&adjacent_nodes);
        for iter.advance() {
            var optional = self.*.board.towns.lookup(*iter.current());
            if optional.is_empty() {
                continue;
            }
            var town = optional.value();
            if town.player == player {
                is_adjacent = true;
                break;
            }
        }
        if not is_adjacent {
            connection.*.sendc(server_message::init_rejected_format(
                "cannot submit player (you cannot steal from {})",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(f_name)]](&f_name)]));
            return;
        }

        var t_info = self.*.p_info(self.*.turn.player);
        var f_info = self.*.p_info(player);
        if f_info.*.resource_count() == 0 {
            connection.*.sendc(server_message::init_rejected_format(
                "cannot submit player ({} has no resources)",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(f_name)]](&f_name)]));
            return;
        }

        var v = std::vector[[resource]]::init();
        defer v.fini();
        for _ in (:usize)f_info.*.brick {
            v.push(resource::BRICK);
        }
        for _ in (:usize)f_info.*.ore {
            v.push(resource::ORE);
        }
        for _ in (:usize)f_info.*.sheep {
            v.push(resource::SHEEP);
        }
        for _ in (:usize)f_info.*.wheat {
            v.push(resource::WHEAT);
        }
        for _ in (:usize)f_info.*.wood {
            v.push(resource::WOOD);
        }
        var r = v.data()[(:usize)random32() % v.count()];
        switch r {
        resource::BRICK {
            f_info.*.brick -= 1;
            t_info.*.brick += 1;
        }
        resource::ORE {
            f_info.*.ore -= 1;
            t_info.*.ore += 1;
        }
        resource::SHEEP {
            f_info.*.sheep -= 1;
            t_info.*.sheep += 1;
        }
        resource::WHEAT {
            f_info.*.wheat -= 1;
            t_info.*.wheat += 1;
        }
        resource::WOOD {
            f_info.*.wood -= 1;
            t_info.*.wood += 1;
        }
        }

        var r = r.data();
        connection.*.sendc(server_message::init_accepted_format(
            "stole {} from {}",
            (:[]std::formatter)[
                std::formatter::init[[typeof(r)]](&r),
                std::formatter::init[[typeof(f_name)]](&f_name)]));
        self.*.sendc_all(server_message::init_log_format(
            "{} stole from {}.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(t_name)]](&t_name),
                std::formatter::init[[typeof(f_name)]](&f_name)]));
        self.*.turn.phase = phase::MAIN;
    }

    func process_submit_resources(self: *server_state, connection: *connection, resources: resources) void {
        if self.*.turn.phase != phase::DISCARD {
            connection.*.sendc(server_message::init_rejected("cannot discard resources (it is not the discard phase)"));
            return;
        }
        var discarded = self.*.p_discarded(connection.*.player);
        if *discarded {
            connection.*.sendc(server_message::init_rejected("cannot discard resources (player has already discarded)"));
            return;
        }
        var info = self.*.p_info(connection.*.player);
        if info.*.resource_count() <= 7 {
            connection.*.sendc(server_message::init_rejected("cannot discard resources (player has seven or fewer resources)"));
            return;
        }
        if info.*.resource_count() / 2 != resources.count() {
            connection.*.sendc(server_message::init_rejected("cannot discard resources (player must discard exactly half of their resources rounded down)"));
            return;
        }
        if info.*.brick < resources.brick
        or info.*.ore < resources.ore
        or info.*.sheep < resources.sheep
        or info.*.wheat < resources.wheat
        or info.*.wood < resources.wood {
            connection.*.sendc(server_message::init_rejected("cannot discard resources (invalid resource selection)"));
            return;
        }
        info.*.brick -= resources.brick;
        info.*.ore -= resources.ore;
        info.*.sheep -= resources.sheep;
        info.*.wheat -= resources.wheat;
        info.*.wood -= resources.wood;
        *discarded = true;

        connection.*.sendc(server_message::init_accepted("discarded resources"));

        if self.*.r_discarded
        and self.*.b_discarded
        and self.*.w_discarded
        and self.*.o_discarded {
            var name = player_to_name(self.*.turn.player);
            self.*.sendc_all(server_message::init_log_format(
                "Waiting for {} to move the robber.",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name)]));
            self.*.turn.phase = phase::ROBBER;
            self.*.r_discarded = false;
            self.*.b_discarded = false;
            self.*.w_discarded = false;
            self.*.o_discarded = false;
        }
    }

    func update_from_client_message(self: *server_state, message: *client_message, connection: *connection) void {
        switch message.*.kind {
        client_message::ROLL {
            self.*.process_roll(connection);
        }
        client_message::END_TURN {
            self.*.process_end_turn(connection);
        }
        client_message::BUILD_ROAD {
            self.*.process_build_road(connection, message.*.data.build_road);
        }
        client_message::BUILD_TOWN {
            self.*.process_build_town(connection, message.*.data.build_town);
        }
        client_message::MOVE_ROBBER {
            self.*.process_move_robber(connection, message.*.data.move_robber);
        }
        client_message::SELECT_PLAYER {
            self.*.process_select_player(connection, message.*.data.select_player);
        }
        client_message::SUBMIT_PLAYER {
            self.*.process_submit_player(connection, message.*.data.submit_player);
        }
        client_message::SUBMIT_RESOURCES {
            self.*.process_submit_resources(connection, message.*.data.submit_resources);
        }
        }
    }
}

func server_update(sstate: *server_state) void {
    # Initial server messages sent on the first game tick.
    if sstate.*.ticks == 0 {
        sstate.*.sendc_all(server_message::init_log("Welcome to Natac!"));
        sstate.*.change_turn(player::RED);
    }

    # The state of the board changes relatively infrequently, so it is not
    # necessary to serialize and send the entire board state every game tick.
    if sstate.*.ticks % 4 == 0 {
        var r = (:public_player_info){
            .resources = sstate.*.r_info.resource_count(),
            .discarded = sstate.*.r_discarded,
        };
        var b = (:public_player_info){
            .resources = sstate.*.b_info.resource_count(),
            .discarded = sstate.*.b_discarded,
        };
        var w = (:public_player_info){
            .resources = sstate.*.w_info.resource_count(),
            .discarded = sstate.*.w_discarded,
        };
        var o = (:public_player_info){
            .resources = sstate.*.o_info.resource_count(),
            .discarded = sstate.*.o_discarded,
        };
        sstate.*.sendc_all(server_message::init_state(
            &sstate.*.board,
            sstate.*.turn,
            r,
            b,
            w,
            o));

        for i in sstate.*.connections.count() {
            if sstate.*.connections.data()[i].player == player::NIL {
                continue;
            }
            var info = sstate.*.p_info(sstate.*.connections.data()[i].player);
            sstate.*.connections.data()[i].sendc(server_message::init_info(*info));
        }
    }

    sstate.*.ticks +%= 1;
}
