import "c";
import "std";

import "util.sunder";
import "shared.sunder";

struct connection {
    var player: player;
    var sender: message_sender[[server_message]];

    # Send a server message to the connection.
    func send(self: *connection, message: *server_message) void {
        self.*.sender.send(message);
    }

    # Send a server message to the connection, then consume the message.
    func sendc(self: *connection, message: server_message) void {
        self.*.sender.send(&message);
        message.fini();
    }
}

struct server_state {
    var connections: std::vector[[connection]];
    var ticks: usize;
    var board: board;
    var dev_cards: std::vector[[dev_card]];
    var r_live: bool;
    var b_live: bool;
    var w_live: bool;
    var o_live: bool;
    var r_info: hidden_player_info;
    var b_info: hidden_player_info;
    var w_info: hidden_player_info;
    var o_info: hidden_player_info;
    var r_discarded: bool; # discard phase
    var b_discarded: bool; # discard phase
    var w_discarded: bool; # discard phase
    var o_discarded: bool; # discard phase
    var r_trade_submitted: bool; # trade phase
    var b_trade_submitted: bool; # trade phase
    var w_trade_submitted: bool; # trade phase
    var o_trade_submitted: bool; # trade phase
    var trade: trade;
    var turn: turn;
    # Previous turn phase before playing a devlopment card. Used for restoring
    # the turn state after a development card has resolved. An empty optional
    # indicates that a development card has not been played this turn.
    var prev_phase: std::optional[[phase]];
    var longest_road: player;
    var largest_army: player;
    var winner: player;

    func init() server_state {
        # TODO: Perform Fisherâ€“Yates shuffle on the dev card stack.
        var dev_cards = std::vector[[dev_card]]::init();
        # x14 Knight
        for _ in 14 {
            dev_cards.push(dev_card::KNIGHT);
        }
        # x02 Road Building
        for _ in 2 {
            dev_cards.push(dev_card::ROAD_BUILDING);
        }
        # x02 Year of Plenty
        for _ in 2 {
            dev_cards.push(dev_card::YEAR_OF_PLENTY);
        }
        # x02 Monopoly
        for _ in 2 {
            dev_cards.push(dev_card::MONOPOLY);
        }
        # x05 Victory Point
        for _ in 2 {
            dev_cards.push(dev_card::VICTORY_POINT);
        }

        return (:server_state){
            .connections = std::vector[[connection]]::init(),
            .ticks = 0,
            .board = board::init_starter_map_for_beginners(),
            .dev_cards = dev_cards,
            .r_live = false,
            .b_live = false,
            .w_live = false,
            .o_live = false,
            .r_info = uninit,
            .b_info = uninit,
            .w_info = uninit,
            .o_info = uninit,
            .r_discarded = false,
            .b_discarded = false,
            .w_discarded = false,
            .o_discarded = false,
            .r_trade_submitted = false,
            .b_trade_submitted = false,
            .w_trade_submitted = false,
            .o_trade_submitted = false,
            .trade = uninit,
            .turn = turn::init(0, player::NIL),
            .prev_phase = std::optional[[phase]]::EMPTY,
            .longest_road = player::NIL,
            .largest_army = player::NIL,
            .winner = player::NIL,
        };
    }

    func fini(self: *server_state) void {
        self.*.connections.fini();
        self.*.board.fini();
        self.*.dev_cards.fini();
    }

    # Send a server message to all connections.
    func send_all(self: *server_state, message: *server_message) void {
        for i in self.*.connections.count() {
            self.*.connections.data()[i].send(message);
        }
    }

    # Send a server message to all connections, then consume the message.
    func sendc_all(self: *server_state, message: server_message) void {
        self.*.send_all(&message);
        message.fini();
    }

    func p_live(self: *server_state, player: player) *bool {
        switch player {
        ::player::NIL {
            std::unreachable(fileof(), lineof());
        }
        ::player::RED {
            return &self.*.r_live;
        }
        ::player::BLUE {
            return &self.*.b_live;
        }
        ::player::WHITE {
            return &self.*.w_live;
        }
        ::player::ORANGE {
            return &self.*.o_live;
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[*bool]]();
    }

    func p_info(self: *server_state, player: player) *hidden_player_info {
        switch player {
        ::player::NIL {
            std::unreachable(fileof(), lineof());
        }
        ::player::RED {
            return &self.*.r_info;
        }
        ::player::BLUE {
            return &self.*.b_info;
        }
        ::player::WHITE {
            return &self.*.w_info;
        }
        ::player::ORANGE {
            return &self.*.o_info;
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[*hidden_player_info]]();
    }

    func p_discarded(self: *server_state, player: player) *bool {
        switch player {
        ::player::NIL {
            std::unreachable(fileof(), lineof());
        }
        ::player::RED {
            return &self.*.r_discarded;
        }
        ::player::BLUE {
            return &self.*.b_discarded;
        }
        ::player::WHITE {
            return &self.*.w_discarded;
        }
        ::player::ORANGE {
            return &self.*.o_discarded;
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[*bool]]();
    }

    func p_trade_submitted(self: *server_state, player: player) *bool {
        switch player {
        ::player::NIL {
            std::unreachable(fileof(), lineof());
        }
        ::player::RED {
            return &self.*.r_trade_submitted;
        }
        ::player::BLUE {
            return &self.*.b_trade_submitted;
        }
        ::player::WHITE {
            return &self.*.w_trade_submitted;
        }
        ::player::ORANGE {
            return &self.*.o_trade_submitted;
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[*bool]]();
    }

    func calculate_longest_road_visit(
        self: *server_state,
        edges: *std::hash_set[[edge]],
        edges_visited: *std::hash_set[[edge]],
        nodes_visited: *std::hash_set[[node]],
        visiting: edge,
        player: player
    ) usize {
        if edges_visited.*.contains(visiting) {
            return 0;
        }
        edges_visited.*.insert(visiting);

        var longest = 1u;
        var adjacent_nodes = adjacent_nodes_to_edge(visiting, &self.*.board.nodes);
        defer adjacent_nodes.fini();
        var iter = std::hash_set_iterator[[node]]::init(&adjacent_nodes);
        for iter.advance() {
            if nodes_visited.*.contains(*iter.current()) {
                continue;
            }
            nodes_visited.*.insert(*iter.current());

            var town = self.*.board.towns.lookup(*iter.current());
            if town.is_value() and town.value().*.player != player {
                continue;
            }

            var edges_visited = std::hash_set[[edge]]::init_assign(edges_visited);
            defer edges_visited.fini();
            var nodes_visited = std::hash_set[[node]]::init_assign(nodes_visited);
            defer nodes_visited.fini();

            var adjacent_edges = adjacent_edges_to_node(*iter.current(), &self.*.board.edges);
            defer adjacent_edges.fini();
            var iter = std::hash_set_iterator[[edge]]::init(&adjacent_edges);
            for iter.advance() {
                if not edges.*.contains(*iter.current()) {
                    continue;
                }
                var length = 1 + self.*.calculate_longest_road_visit(edges, &edges_visited, &nodes_visited, *iter.current(), player);
                longest = usize::max(longest, length);
            }
        }

        return longest;
    }

    func calculate_longest_road(self: *server_state, player: player) usize {
        var edges = std::hash_set[[edge]]::init();
        defer edges.fini();
        var iter = std::hash_map_iterator[[edge, road]]::init(&self.*.board.roads);
        for iter.advance() {
            if iter.current().*.value.*.player != player {
                continue;
            }
            edges.insert(*iter.current().*.key);
        }

        var longest = 0u;

        var iter = std::hash_set_iterator[[edge]]::init(&edges);
        for iter.advance() {
            var edges_visited = std::hash_set[[edge]]::init();
            defer edges_visited.fini();
            var nodes_visited = std::hash_set[[node]]::init();
            defer nodes_visited.fini();

            var length = self.*.calculate_longest_road_visit(&edges, &edges_visited, &nodes_visited, *iter.current(), player);
            longest = usize::max(longest, length);
        }

        return longest;
    }

    func public_victory_points(self: *server_state, player: player) sint {
        var victory_points: sint = 0;

        var iter = std::hash_map_iterator[[node, town]]::init(&self.*.board.towns);
        for iter.advance() {
            var town = *iter.current().*.value;
            if town.player != player {
                continue;
            }
            switch town.kind {
            ::town::SETTLEMENT {
                victory_points += 1;
            }
            ::town::CITY {
                victory_points += 2;
            }
            }
        }

        if self.*.longest_road == player {
            victory_points += 2;
        }

        if self.*.largest_army == player {
            victory_points += 2;
        }

        return victory_points;
    }

    func hidden_victory_points(self: *server_state, player: player) sint {
        var victory_points: sint = self.*.public_victory_points(player);

        var info = self.*.p_info(player);
        for i in info.*.dev_card_count {
            if info.*.dev_card_array[i].kind == dev_card::VICTORY_POINT {
                victory_points += 1;
            }
        }

        return victory_points;
    }

    func change_turn(self: *server_state, player: player) void {
        self.*.turn = turn::init(self.*.turn.number + 1, player);
        self.*.prev_phase = std::optional[[phase]]::EMPTY;
        var name = player_to_name(player);
        self.*.sendc_all(server_message::init_log_format(
            "It's {}'s turn!",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));
    }

    func process_roll(self: *server_state, connection: *connection) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot roll dice (it is not your turn)"));
            return;
        }
        if self.*.turn.phase != phase::RESOURCE_PRODUCTION {
            connection.*.sendc(server_message::init_rejected("cannot roll dice (it is not the resource production phase)"));
            return;
        }

        var roll_a = d6();
        var roll_b = d6();
        var roll = roll_a + roll_b;
        self.*.board.d6_a = roll_a;
        self.*.board.d6_b = roll_b;

        connection.*.sendc(server_message::init_accepted_format(
            "rolled {} + {} = {}",
            (:[]std::formatter)[
                std::formatter::init[[typeof(roll_a)]](&roll_a),
                std::formatter::init[[typeof(roll_b)]](&roll_b),
                std::formatter::init[[typeof(roll)]](&roll)]));
        var name = player_to_name(connection.*.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} rolled {} + {} = {}.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name),
                std::formatter::init[[typeof(roll_a)]](&roll_a),
                std::formatter::init[[typeof(roll_b)]](&roll_b),
                std::formatter::init[[typeof(roll)]](&roll)]));

        if roll == 7 {
            if (self.*.r_info.resource_count() <= 7)
            and (self.*.b_info.resource_count() <= 7)
            and (self.*.w_info.resource_count() <= 7)
            and (self.*.o_info.resource_count() <= 7) {
                self.*.sendc_all(server_message::init_log("No players need to discard."));
                var name = player_to_name(self.*.turn.player);
                self.*.sendc_all(server_message::init_log_format(
                    "Waiting for {} to move the robber.",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(name)]](&name)]));
                self.*.turn.phase = phase::ROBBER;
            }
            else {
                self.*.sendc_all(server_message::init_log("Waiting for all players to discard."));
                self.*.r_discarded = self.*.r_info.resource_count() <= 7;
                self.*.b_discarded = self.*.b_info.resource_count() <= 7;
                self.*.w_discarded = self.*.w_info.resource_count() <= 7;
                self.*.o_discarded = self.*.o_info.resource_count() <= 7;
                self.*.turn.phase = phase::DISCARD;
            }
            return;
        }

        var iter = std::hash_map_iterator[[node, town]]::init(&self.*.board.towns);
        for iter.advance() {
            var amount: sint = uninit;
            var town = *iter.current().*.value;
            switch town.kind {
            ::town::SETTLEMENT {
                amount = 1;
            }
            ::town::CITY {
                amount = 2;
            }
            }
            var node = *iter.current().*.key;
            for i in countof(node.hexes) {
                var tile = self.*.board.tiles.lookup(node.hexes[i]);
                var tile = tile.value();
                if tile.*.number != roll {
                    continue;
                }
                var info = self.*.p_info(town.player);
                info.*.brick += amount * (:sint)(tile.*.kind == ::tile::HILL);
                info.*.ore += amount * (:sint)(tile.*.kind == ::tile::MOUNTAIN);
                info.*.sheep += amount * (:sint)(tile.*.kind == ::tile::PASTURE);
                info.*.wheat += amount * (:sint)(tile.*.kind == ::tile::FIELD);
                info.*.wood += amount * (:sint)(tile.*.kind == ::tile::FOREST);
            }
        }
        self.*.turn.phase = phase::MAIN;
    }

    func process_end_turn(self: *server_state, connection: *connection) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot end turn (it is not your turn)"));
            return;
        }
        if self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("cannot end turn (it is not the main phase)"));
            return;
        }

        connection.*.sendc(server_message::init_accepted("ended turn"));
        var name = player_to_name(connection.*.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} ended their turn.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));

        var PLAYERS = (:[]player)[
            player::RED,
            player::BLUE,
            player::WHITE,
            player::ORANGE,
        ];
        var idx: usize = uninit;
        if self.*.turn.player == player::RED {
            idx = 0; # red
        }
        elif self.*.turn.player == player::BLUE {
            idx = 1; # blue
        }
        elif self.*.turn.player == player::WHITE {
            idx = 2; # white
        }
        elif self.*.turn.player == player::ORANGE {
            idx = 3; # orange
        }

        for true {
            idx += 1;
            idx %= countof(PLAYERS);
            if *self.*.p_live(PLAYERS[idx]) {
                break;
            }
        }
        self.*.change_turn(PLAYERS[idx]);
    }

    func process_build_road(self: *server_state, connection: *connection, road: road) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot build road (it is not your turn)"));
            return;
        }
        if self.*.turn.player != road.player {
            connection.*.sendc(server_message::init_rejected("cannot build road (it is not your road)"));
            return;
        }
        if self.*.turn.phase != phase::MAIN and self.*.turn.phase != phase::ROAD_BUILDING_1 and self.*.turn.phase != phase::ROAD_BUILDING_2 {
            connection.*.sendc(server_message::init_rejected("cannot build road (invalid phase)"));
            return;
        }

        var tile_a = self.*.board.tiles.lookup(road.edge.hexes[0]);
        var tile_b = self.*.board.tiles.lookup(road.edge.hexes[1]);
        var is_road_across_water =
            tile_a.value().*.kind == tile::OCEAN and
            tile_b.value().*.kind == tile::OCEAN;
        if is_road_across_water {
            connection.*.sendc(server_message::init_rejected("cannot build road (cannot build on water)"));
            return;
        }

        var existing = self.*.board.roads.lookup(road.edge);
        if existing.is_value() {
            connection.*.sendc(server_message::init_rejected("cannot build road (road exists at location)"));
            return;
        }

        var adjacent_edges = adjacent_edges_to_edge(road.edge, &self.*.board.edges, &self.*.board.nodes);
        defer adjacent_edges.fini();
        var adjacent_roads = std::hash_set[[::road]]::init();
        defer adjacent_roads.fini();
        var iter = std::hash_set_iterator[[edge]]::init(&adjacent_edges);
        for iter.advance() {
            var adjacent = self.*.board.roads.lookup(*iter.current());
            if adjacent.is_empty() {
                continue;
            }
            var adjacent = adjacent.value();
            if adjacent.*.player != road.player {
                continue;
            }
            adjacent_roads.insert(*adjacent);
        }
        var adjacent_nodes = adjacent_nodes_to_edge(road.edge, &self.*.board.nodes);
        defer adjacent_nodes.fini();
        var adjacent_towns = std::hash_set[[town]]::init();
        defer adjacent_towns.fini();
        var iter = std::hash_set_iterator[[node]]::init(&adjacent_nodes);
        for iter.advance() {
            var adjacent = self.*.board.towns.lookup(*iter.current());
            if adjacent.is_empty() {
                continue;
            }
            var adjacent = adjacent.value();
            if adjacent.*.player != road.player {
                continue;
            }
            adjacent_towns.insert(*adjacent);
        }
        if adjacent_roads.count() == 0 and adjacent_towns.count() == 0 {
            connection.*.sendc(server_message::init_rejected("cannot build road (no adjacent road or town)"));
            return;
        }

        var unobstructed_road_count = 0u;
        var iter = std::hash_set_iterator[[::road]]::init(&adjacent_roads);
        for iter.advance() {
            var a = adjacent_nodes_to_edge(road.edge, &self.*.board.nodes);
            defer a.fini();
            var b = adjacent_nodes_to_edge(iter.current().*.edge, &self.*.board.nodes);
            defer b.fini();
            var i = std::hash_set[[node]]::init_intersection(&a, &b);
            defer i.fini();
            assert i.count() == 1;
            var iter = std::hash_set_iterator[[node]]::init(&i);
            iter.advance();
            var town = self.*.board.towns.lookup(*iter.current());
            if town.is_empty() {
                # No town between the two road pieces.
                unobstructed_road_count += 1;
                continue;
            }
            var town = town.value();
            if town.*.player == road.player {
                # Town between the two road pieces belongs to the player
                # placing the road.
                unobstructed_road_count += 1;
                continue;
            }
        }
        if adjacent_towns.count() == 0 and unobstructed_road_count == 0 {
            connection.*.sendc(server_message::init_rejected("cannot build road (road is obstructed by town)"));
            return;
        }

        var player_road_count = 0u;
        var iter = std::hash_map_iterator[[edge, ::road]]::init(&self.*.board.roads);
        for iter.advance() {
            if iter.current().*.value.*.player == road.player {
                player_road_count += 1;
            }
        }
        if player_road_count >= 15 {
            connection.*.sendc(server_message::init_rejected("cannot build road (all roads placed)"));
            return;
        }

        var info = self.*.p_info(self.*.turn.player);
        if self.*.turn.phase == phase::MAIN {
            if not (info.*.brick >= 1 and info.*.wood >= 1) {
                connection.*.sendc(server_message::init_rejected("cannot build road (insufficient resources)"));
                return;
            }

            info.*.brick -= 1;
            info.*.wood -= 1;
        }
        insert_road(&self.*.board.roads, road);

        connection.*.sendc(server_message::init_accepted("built road"));
        var name = player_to_name(self.*.turn.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} built a road.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));

        if self.*.turn.phase == phase::ROAD_BUILDING_1 {
            self.*.turn.phase = phase::ROAD_BUILDING_2;
        }
        elif self.*.turn.phase == phase::ROAD_BUILDING_2 {
            assert self.*.prev_phase.is_value();
            self.*.turn.phase = self.*.prev_phase.value();
        }
    }

    func process_build_town(self: *server_state, connection: *connection, town: town) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot build town (it is not your turn)"));
            return;
        }
        if self.*.turn.player != town.player {
            connection.*.sendc(server_message::init_rejected("cannot build town (it is not your town)"));
            return;
        }
        if self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("cannot build town (it is not the main phase)"));
            return;
        }

        var existing = self.*.board.towns.lookup(town.node);
        if existing.is_value() {
            var existing = existing.value();
            # Special case for upgrading a settlement to a city.
            if not (existing.*.player == town.player and existing.*.kind == ::town::SETTLEMENT and town.kind == ::town::CITY) {
                connection.*.sendc(server_message::init_rejected("cannot build town (town exists at location)"));
                return;
            }
        }

        var adjacent_nodes = adjacent_nodes_to_node(town.node, &self.*.board.nodes);
        defer adjacent_nodes.fini();
        var adjacent_town_count = 0u;
        var iter = std::hash_set_iterator[[node]]::init(&adjacent_nodes);
        for iter.advance() {
            if self.*.board.towns.contains(*iter.current()) {
                adjacent_town_count = adjacent_town_count + 1;
            }
        }
        if adjacent_town_count != 0 {
            connection.*.sendc(server_message::init_rejected("cannot build town (adjacent town)"));
            return;
        }

        var adjacent_edges = adjacent_edges_to_node(town.node, &self.*.board.edges);
        defer adjacent_edges.fini();
        var is_road_adjacent = false;
        var iter = std::hash_set_iterator[[edge]]::init(&adjacent_edges);
        for iter.advance() {
            var adjacent = self.*.board.roads.lookup(*iter.current());
            if adjacent.is_empty() {
                continue;
            }
            var adjacent = adjacent.value();
            if adjacent.*.player != town.player {
                continue;
            }

            is_road_adjacent = true;
        }
        if not is_road_adjacent {
            connection.*.sendc(server_message::init_rejected("cannot build town (no adjacent road)"));
            return;
        }

        var player_town_count = 0u;
        var iter = std::hash_map_iterator[[node, ::town]]::init(&self.*.board.towns);
        for iter.advance() {
            if iter.current().*.value.*.player == town.player and iter.current().*.value.*.kind == town.kind {
                player_town_count = player_town_count + 1;
            }
        }
        if town.kind == ::town::SETTLEMENT and player_town_count >= 5 {
            connection.*.sendc(server_message::init_rejected("cannot build town (all settlements placed)"));
            return;
        }
        if town.kind == ::town::CITY and player_town_count >= 4 {
            connection.*.sendc(server_message::init_rejected("cannot build town (all cities placed)"));
            return;
        }

        var info = self.*.p_info(self.*.turn.player);
        switch town.kind {
        ::town::SETTLEMENT {
            if not (info.*.brick >= 1 and info.*.sheep >= 1 and info.*.wheat >= 1 and info.*.wood >= 1) {
                connection.*.sendc(server_message::init_rejected("cannot build settlement (insufficient resources)"));
                return;
            }
            info.*.brick -= 1;
            info.*.sheep -= 1;
            info.*.wheat -= 1;
            info.*.wood -= 1;
        }
        ::town::CITY {
            if not (info.*.ore >= 3 and info.*.wheat >= 2) {
                connection.*.sendc(server_message::init_rejected("cannot build city (insufficient resources)"));
                return;
            }
            info.*.ore -= 3;
            info.*.wheat -= 2;
        }
        }
        insert_town(&self.*.board.towns, town);

        connection.*.sendc(server_message::init_accepted("built town"));
        var name = player_to_name(self.*.turn.player);
        var kind = "settlement";
        if town.kind == ::town::CITY {
            kind = "city";
        }
        self.*.sendc_all(server_message::init_log_format(
            "{} built a {}.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name),
                std::formatter::init[[typeof(kind)]](&kind)]));
    }

    func process_buy_dev_card(self: *server_state, connection: *connection) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot buy development card (it is not your turn)"));
            return;
        }
        if self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("cannot buy development card (it is not the main phase)"));
            return;
        }

        if self.*.dev_cards.count() == 0 {
            connection.*.sendc(server_message::init_rejected("cannot buy development card (no development cards remaining)"));
            return;
        }

        var info = self.*.p_info(self.*.turn.player);
        if not (info.*.ore >= 1 and info.*.sheep >= 1 and info.*.wheat >= 1) {
            connection.*.sendc(server_message::init_rejected("cannot buy development card (insufficient resources)"));
            return;
        }
        info.*.ore -= 1;
        info.*.sheep -= 1;
        info.*.wheat -= 1;

        info.*.dev_card_array[info.*.dev_card_count] = (:purchased_dev_card){
            .kind = self.*.dev_cards.pop(),
            .turn = self.*.turn.number,
            .used = false,
        };
        info.*.dev_card_count += 1;

        connection.*.sendc(server_message::init_accepted("bought development card"));
        var name = player_to_name(self.*.turn.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} bought a development card.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));
    }

    func process_use_dev_card_knight(self: *server_state, connection: *connection) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot use development card (it is not your turn)"));
            return;
        }
        if self.*.turn.phase != phase::RESOURCE_PRODUCTION and self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("cannot use development card (invalid phase)"));
            return;
        }
        if self.*.prev_phase.is_value() {
            connection.*.sendc(server_message::init_rejected("cannot use development card (development card has already been played this turn)"));
            return;
        }

        var info = self.*.p_info(self.*.turn.player);
        var card = std::ptr[[purchased_dev_card]]::NULL;
        for i in info.*.dev_card_count {
            if info.*.dev_card_array[i].kind != dev_card::KNIGHT {
                continue;
            }
            if info.*.dev_card_array[i].turn >= self.*.turn.number {
                continue;
            }
            if info.*.dev_card_array[i].used {
                continue;
            }
            card = &info.*.dev_card_array[i];
        }
        if card == std::ptr[[purchased_dev_card]]::NULL {
            connection.*.sendc(server_message::init_rejected("cannot use development card (no valid knight)"));
            return;
        }

        var r_knights: sint = 0;
        var b_knights: sint = 0;
        var w_knights: sint = 0;
        var o_knights: sint = 0;
        for i in self.*.r_info.dev_card_count {
            if self.*.r_info.dev_card_array[i].kind != dev_card::KNIGHT {
                continue;
            }
            if not self.*.r_info.dev_card_array[i].used {
                continue;
            }
            r_knights += 1;
        }
        for i in self.*.b_info.dev_card_count {
            if self.*.b_info.dev_card_array[i].kind != dev_card::KNIGHT {
                continue;
            }
            if not self.*.b_info.dev_card_array[i].used {
                continue;
            }
            b_knights += 1;
        }
        for i in self.*.w_info.dev_card_count {
            if self.*.w_info.dev_card_array[i].kind != dev_card::KNIGHT {
                continue;
            }
            if not self.*.w_info.dev_card_array[i].used {
                continue;
            }
            w_knights += 1;
        }
        for i in self.*.o_info.dev_card_count {
            if self.*.o_info.dev_card_array[i].kind != dev_card::KNIGHT {
                continue;
            }
            if not self.*.o_info.dev_card_array[i].used {
                continue;
            }
            o_knights += 1;
        }
        var cur_max_knights = sint::max(r_knights, sint::max(b_knights, sint::max(w_knights, o_knights)));

        card.*.used = true;
        self.*.prev_phase = std::optional[[phase]]::init_value(self.*.turn.phase);
        self.*.turn.phase = phase::ROBBER;

        var name = player_to_name(self.*.turn.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} played a knight.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));

        var p_knights: sint = 0;
        for i in info.*.dev_card_count {
            if info.*.dev_card_array[i].kind != dev_card::KNIGHT {
                continue;
            }
            if not info.*.dev_card_array[i].used {
                continue;
            }
            p_knights += 1;
        }
        if p_knights == cur_max_knights + 1 and p_knights >= 3 {
            self.*.largest_army = self.*.turn.player;
            self.*.sendc_all(server_message::init_log_format(
                "{} has the largest army ({} knights).",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[sint]](&p_knights)]));
        }
    }

    func process_use_dev_card_road_building(self: *server_state, connection: *connection) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot use development card (it is not your turn)"));
            return;
        }
        if self.*.turn.phase != phase::RESOURCE_PRODUCTION and self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("cannot use development card (invalid phase)"));
            return;
        }
        if self.*.prev_phase.is_value() {
            connection.*.sendc(server_message::init_rejected("cannot use development card (development card has already been played this turn)"));
            return;
        }

        var info = self.*.p_info(self.*.turn.player);
        var card = std::ptr[[purchased_dev_card]]::NULL;
        for i in info.*.dev_card_count {
            if info.*.dev_card_array[i].kind != dev_card::ROAD_BUILDING {
                continue;
            }
            if info.*.dev_card_array[i].turn >= self.*.turn.number {
                continue;
            }
            if info.*.dev_card_array[i].used {
                continue;
            }
            card = &info.*.dev_card_array[i];
        }
        if card == std::ptr[[purchased_dev_card]]::NULL {
            connection.*.sendc(server_message::init_rejected("cannot use development card (no valid road building)"));
            return;
        }

        card.*.used = true;
        self.*.prev_phase = std::optional[[phase]]::init_value(self.*.turn.phase);
        self.*.turn.phase = phase::ROAD_BUILDING_1;

        var name = player_to_name(self.*.turn.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} played road building.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));
    }

    func process_use_dev_card_year_of_plenty(self: *server_state, connection: *connection, resources: resources) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot use development card (it is not your turn)"));
            return;
        }
        if self.*.turn.phase != phase::RESOURCE_PRODUCTION and self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("cannot use development card (invalid phase)"));
            return;
        }
        if self.*.prev_phase.is_value() {
            connection.*.sendc(server_message::init_rejected("cannot use development card (development card has already been played this turn)"));
            return;
        }

        var info = self.*.p_info(self.*.turn.player);
        var card = std::ptr[[purchased_dev_card]]::NULL;
        for i in info.*.dev_card_count {
            if info.*.dev_card_array[i].kind != dev_card::YEAR_OF_PLENTY {
                continue;
            }
            if info.*.dev_card_array[i].turn >= self.*.turn.number {
                continue;
            }
            if info.*.dev_card_array[i].used {
                continue;
            }
            card = &info.*.dev_card_array[i];
        }
        if card == std::ptr[[purchased_dev_card]]::NULL {
            connection.*.sendc(server_message::init_rejected("cannot use development card (no valid year of plenty)"));
            return;
        }

        if resources.count() != 2 {
            connection.*.sendc(server_message::init_rejected("cannot use development card (invalid resources)"));
            return;
        }
        info.*.brick += resources.brick;
        info.*.ore += resources.ore;
        info.*.sheep += resources.sheep;
        info.*.wheat += resources.wheat;
        info.*.wood += resources.wood;

        card.*.used = true;
        self.*.prev_phase = std::optional[[phase]]::init_value(self.*.turn.phase);
        self.*.turn.phase = self.*.turn.phase; # TODO: Should Year of Plenty have a distinct phase?

        var name = player_to_name(self.*.turn.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} played year of plenty.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));
        if resources.brick != 0 {
            self.*.sendc_all(server_message::init_log_format(
                "{} gained {} brick.",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[sint]](&resources.brick)]));
        }
        if resources.ore != 0 {
            self.*.sendc_all(server_message::init_log_format(
                "{} gained {} ore.",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[sint]](&resources.ore)]));
        }
        if resources.sheep != 0 {
            self.*.sendc_all(server_message::init_log_format(
                "{} gained {} sheep.",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[sint]](&resources.sheep)]));
        }
        if resources.wheat != 0 {
            self.*.sendc_all(server_message::init_log_format(
                "{} gained {} wheat.",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[sint]](&resources.wheat)]));
        }
        if resources.wood != 0 {
            self.*.sendc_all(server_message::init_log_format(
                "{} gained {} wood.",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[sint]](&resources.wood)]));
        }
    }

    func process_use_dev_card_monopoly(self: *server_state, connection: *connection, resource: resource) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot use development card (it is not your turn)"));
            return;
        }
        if self.*.turn.phase != phase::RESOURCE_PRODUCTION and self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("cannot use development card (invalid phase)"));
            return;
        }
        if self.*.prev_phase.is_value() {
            connection.*.sendc(server_message::init_rejected("cannot use development card (development card has already been played this turn)"));
            return;
        }

        var info = self.*.p_info(self.*.turn.player);
        var card = std::ptr[[purchased_dev_card]]::NULL;
        for i in info.*.dev_card_count {
            if info.*.dev_card_array[i].kind != dev_card::MONOPOLY {
                continue;
            }
            if info.*.dev_card_array[i].turn >= self.*.turn.number {
                continue;
            }
            if info.*.dev_card_array[i].used {
                continue;
            }
            card = &info.*.dev_card_array[i];
        }
        if card == std::ptr[[purchased_dev_card]]::NULL {
            connection.*.sendc(server_message::init_rejected("cannot use development card (no valid monopoly)"));
            return;
        }


        var kind: []byte = uninit;
        switch resource {
        ::resource::BRICK {
            kind = "brick";
        }
        ::resource::ORE {
            kind = "ore";
        }
        ::resource::SHEEP {
            kind = "sheep";
        }
        ::resource::WHEAT {
            kind = "wheat";
        }
        ::resource::WOOD {
            kind = "wood";
        }
        }
        var name = player_to_name(self.*.turn.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} played monopoly ({}).",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name),
                std::formatter::init[[typeof(kind)]](&kind)]));

        var gained: sint = 0;
        if self.*.r_live and self.*.turn.player != player::RED {
            var ref = self.*.r_info.resource_ref(resource);
            var name = player_to_name(player::RED);
            self.*.sendc_all(server_message::init_log_format(
                "{} lost {} {}.",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[typeof(*ref)]](ref),
                    std::formatter::init[[typeof(kind)]](&kind)]));
            gained += *ref;
            *ref = 0;
        }
        if self.*.b_live and self.*.turn.player != player::BLUE {
            var ref = self.*.b_info.resource_ref(resource);
            var name = player_to_name(player::BLUE);
            self.*.sendc_all(server_message::init_log_format(
                "{} lost {} {}.",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[typeof(*ref)]](ref),
                    std::formatter::init[[typeof(kind)]](&kind)]));
            gained += *ref;
            *ref = 0;
        }
        if self.*.w_live and self.*.turn.player != player::WHITE {
            var ref = self.*.w_info.resource_ref(resource);
            var name = player_to_name(player::WHITE);
            self.*.sendc_all(server_message::init_log_format(
                "{} lost {} {}.",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[typeof(*ref)]](ref),
                    std::formatter::init[[typeof(kind)]](&kind)]));
            gained += *ref;
            *ref = 0;
        }
        if self.*.o_live and self.*.turn.player != player::ORANGE {
            var ref = self.*.o_info.resource_ref(resource);
            var name = player_to_name(player::ORANGE);
            self.*.sendc_all(server_message::init_log_format(
                "{} lost {} {}.",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[typeof(*ref)]](ref),
                    std::formatter::init[[typeof(kind)]](&kind)]));
            gained += *ref;
            *ref = 0;
        }

        var ref = self.*.p_info(self.*.turn.player).*.resource_ref(resource);
        var name = player_to_name(player::ORANGE);
        self.*.sendc_all(server_message::init_log_format(
            "{} gained {} {}.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name),
                std::formatter::init[[typeof(gained)]](&gained),
                std::formatter::init[[typeof(kind)]](&kind)]));
        *ref += gained;

        card.*.used = true;
        self.*.prev_phase = std::optional[[phase]]::init_value(self.*.turn.phase);
        self.*.turn.phase = self.*.turn.phase; # TODO: Should Monopoly have a distinct phase?
    }

    func process_move_robber(self: *server_state, connection: *connection, hex: hex) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot move robber (it is not your turn)"));
            return;
        }
        if self.*.turn.phase != phase::ROBBER {
            connection.*.sendc(server_message::init_rejected("cannot move robber (it is not the robber phase)"));
            return;
        }

        if std::eq[[::hex]](&hex, &self.*.board.robber) {
            connection.*.sendc(server_message::init_rejected("cannot move robber (robber already at location)"));
            return;
        }

        var tile = self.*.board.tiles.lookup(hex);
        if tile.is_empty() {
            connection.*.sendc(server_message::init_rejected("cannot move robber (invalid location)"));
            return;
        }

        var tile = tile.value();
        if tile.*.kind == ::tile::OCEAN {
            connection.*.sendc(server_message::init_rejected("cannot move robber (tile is ocean)"));
            return;
        }

        self.*.board.robber = hex;
        connection.*.sendc(server_message::init_accepted("moved robber"));
        var name = player_to_name(self.*.turn.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} moved the robber.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));

        var adjacent_nodes = adjacent_nodes_to_hex(hex, &self.*.board.nodes);
        defer adjacent_nodes.fini();
        var iter = std::hash_set_iterator[[node]]::init(&adjacent_nodes);
        for iter.advance() {
            var optional = self.*.board.towns.lookup(*iter.current());
            if optional.is_empty() {
                continue;
            }
            var town = optional.value();
            if town.*.player == connection.*.player {
                continue;
            }
            if self.*.p_info(town.*.player).*.resource_count() != 0 {
                self.*.turn.phase = phase::STEAL;
                return;
            }
        }

        if self.*.prev_phase.is_value() {
            self.*.turn.phase = self.*.prev_phase.value();
        }
        else {
            self.*.turn.phase = phase::MAIN;
        }
    }

    func process_select_player(self: *server_state, connection: *connection, selected: player) void {
        if connection.*.player == selected {
            connection.*.sendc(server_message::init_rejected("cannot select player (you are already that player)"));
            return;
        }

        for i in self.*.connections.count() {
            if &self.*.connections.data()[i] == connection {
                continue;
            }
            if self.*.connections.data()[i].player != selected {
                continue;
            }
            connection.*.sendc(server_message::init_rejected("cannot select player (someone else is already that player)"));
            return;
        }

        if selected != player::NIL and not *self.*.p_live(selected) {
            var start_of_game =
                self.*.turn.number == 1 and
                self.*.turn.phase == phase::RESOURCE_PRODUCTION;
            if not start_of_game {
                connection.*.sendc(server_message::init_rejected("cannot select player (player is not part of the game)"));
                return;
            }

            # Insert Starter Map For Beginners Positions
            switch selected {
            player::NIL {
                # nothing
            }
            player::RED {
                insert_town(&self.*.board.towns, town::init(
                    player::RED,
                    node::init(
                        hex::init(-2, +0, +2),
                        hex::init(-2, +1, +1),
                        hex::init(-1, +0, +1)),
                    town::SETTLEMENT));
                insert_town(&self.*.board.towns, town::init(
                    player::RED,
                    node::init(
                        hex::init(+0, -2, +2),
                        hex::init(+0, -1, +1),
                        hex::init(+1, -2, +1)),
                    town::SETTLEMENT));
                insert_road(&self.*.board.roads, road::init(
                    player::RED,
                    edge::init(
                        hex::init(-2, +1, +1),
                        hex::init(-1, +0, +1))));
                insert_road(&self.*.board.roads, road::init(
                    player::RED,
                    edge::init(
                        hex::init(+0, -1, +1),
                        hex::init(+1, -2, +1))));

                # vvv ROADS FOR LONGEST ROAD TEST vvvv
                #insert_road(&self.*.board.roads, road::init(
                #    player::RED,
                #    edge::init(
                #        hex::init(-2, +0, +2),
                #        hex::init(-2, +1, +1))));
                #insert_road(&self.*.board.roads, road::init(
                #    player::RED,
                #    edge::init(
                #        hex::init(-2, +0, +2),
                #        hex::init(-1, +0, +1))));
                #insert_road(&self.*.board.roads, road::init(
                #    player::RED,
                #    edge::init(
                #        hex::init(+0, -1, +1),
                #        hex::init(+1, -2, +1))));
                #insert_road(&self.*.board.roads, road::init(
                #    player::RED,
                #    edge::init(
                #        hex::init(-2, +1, +1),
                #        hex::init(-1, +1, +0))));
                #insert_road(&self.*.board.roads, road::init(
                #    player::RED,
                #    edge::init(
                #        hex::init(-2, +2, +0),
                #        hex::init(-1, +1, +0))));
                #insert_road(&self.*.board.roads, road::init(
                #    player::RED,
                #    edge::init(
                #        hex::init(-2, +1, +1),
                #        hex::init(-2, +2, +0))));
                #insert_road(&self.*.board.roads, road::init(
                #    player::RED,
                #    edge::init(
                #        hex::init(-3, +2, +1),
                #        hex::init(-2, +2, +0))));
                # ^^^ ROADS FOR LONGEST ROAD TEST ^^^
            }
            player::BLUE {
                insert_town(&self.*.board.towns, town::init(
                    player::BLUE,
                    node::init(
                        hex::init(-2, +1, +1),
                        hex::init(-2, +2, +0),
                        hex::init(-1, +1, +0)),
                    town::SETTLEMENT));
                insert_town(&self.*.board.towns, town::init(
                    player::BLUE,
                    node::init(
                        hex::init(+0, +1, -1),
                        hex::init(+0, +2, -2),
                        hex::init(+1, +1, -2)),
                    town::SETTLEMENT));
                insert_road(&self.*.board.roads, road::init(
                    player::BLUE,
                    edge::init(
                        hex::init(-2, +2, +0),
                        hex::init(-1, +1, +0))));
                insert_road(&self.*.board.roads, road::init(
                    player::BLUE,
                    edge::init(
                        hex::init(+0, +1, -1),
                        hex::init(+1, +1, -2))));
            }
            player::WHITE {
                insert_town(&self.*.board.towns, town::init(
                    player::WHITE,
                    node::init(
                        hex::init(-1, -1, +2),
                        hex::init(-1, +0, +1),
                        hex::init(+0, -1, +1)),
                    town::SETTLEMENT));
                insert_town(&self.*.board.towns, town::init(
                    player::WHITE,
                    node::init(
                        hex::init(+1, +0, -1),
                        hex::init(+1, +1, -2),
                        hex::init(+2, +0, -2)),
                    town::SETTLEMENT));
                insert_road(&self.*.board.roads, road::init(
                    player::WHITE,
                    edge::init(
                        hex::init(-1, -1, +2),
                        hex::init(-1, +0, +1))));
                insert_road(&self.*.board.roads, road::init(
                    player::WHITE,
                    edge::init(
                        hex::init(+1, +0, -1),
                        hex::init(+2, +0, -2))));
            }
            player::ORANGE {
                insert_town(&self.*.board.towns, town::init(
                    player::ORANGE,
                    node::init(
                        hex::init(-1, +1, +0),
                        hex::init(-1, +2, -1),
                        hex::init(+0, +1, -1)),
                    town::SETTLEMENT));
                insert_town(&self.*.board.towns, town::init(
                    player::ORANGE,
                    node::init(
                        hex::init(+1, -1, +0),
                        hex::init(+2, -2, +0),
                        hex::init(+2, -1, -1)),
                    town::SETTLEMENT));
                insert_road(&self.*.board.roads, road::init(
                    player::ORANGE,
                    edge::init(
                        hex::init(-1, +2, -1),
                        hex::init(+0, +1, -1))));
                insert_road(&self.*.board.roads, road::init(
                    player::ORANGE,
                    edge::init(
                        hex::init(+1, -1, +0),
                        hex::init(+2, -2, +0))));
            }
            }
        }

        var was = player_to_name(connection.*.player);
        connection.*.player = selected;
        if connection.*.player != player::NIL {
            var info = self.*.p_info(connection.*.player);
            connection.*.sendc(server_message::init_info(*info));
            self.*.p_live(selected).* = true;
        }

        var name = player_to_name(selected);
        connection.*.sendc(server_message::init_accepted_format(
            "selected player {}",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));
        connection.*.sendc(server_message::init_player(selected));

        self.*.sendc_all(server_message::init_log_format(
            "{} is now playing as {}.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(was)]](&was),
                std::formatter::init[[typeof(name)]](&name)]));
    }

    func process_submit_player(self: *server_state, connection: *connection, player: player) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot submit player (it is not your turn)"));
            return;
        }
        if self.*.turn.phase != phase::STEAL {
            connection.*.sendc(server_message::init_rejected("cannot submit player (it is not the steal phase)"));
            return;
        }
        if self.*.turn.player == player {
            connection.*.sendc(server_message::init_rejected("cannot submit player (you cannot steal from yourself)"));
            return;
        }

        var t_name = player_to_name(self.*.turn.player);
        var f_name = player_to_name(player);

        var is_adjacent = false;
        var adjacent_nodes = adjacent_nodes_to_hex(self.*.board.robber, &self.*.board.nodes);
        defer adjacent_nodes.fini();
        var iter = std::hash_set_iterator[[node]]::init(&adjacent_nodes);
        for iter.advance() {
            var optional = self.*.board.towns.lookup(*iter.current());
            if optional.is_empty() {
                continue;
            }
            var town = optional.value();
            if town.*.player == player {
                is_adjacent = true;
                break;
            }
        }
        if not is_adjacent {
            connection.*.sendc(server_message::init_rejected_format(
                "cannot submit player (you cannot steal from {})",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(f_name)]](&f_name)]));
            return;
        }

        var t_info = self.*.p_info(self.*.turn.player);
        var f_info = self.*.p_info(player);
        if f_info.*.resource_count() == 0 {
            connection.*.sendc(server_message::init_rejected_format(
                "cannot submit player ({} has no resources)",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(f_name)]](&f_name)]));
            return;
        }

        var v = std::vector[[resource]]::init();
        defer v.fini();
        for _ in (:usize)f_info.*.brick {
            v.push(resource::BRICK);
        }
        for _ in (:usize)f_info.*.ore {
            v.push(resource::ORE);
        }
        for _ in (:usize)f_info.*.sheep {
            v.push(resource::SHEEP);
        }
        for _ in (:usize)f_info.*.wheat {
            v.push(resource::WHEAT);
        }
        for _ in (:usize)f_info.*.wood {
            v.push(resource::WOOD);
        }
        var r = v.data()[(:usize)random32() % v.count()];
        switch r {
        resource::BRICK {
            f_info.*.brick -= 1;
            t_info.*.brick += 1;
        }
        resource::ORE {
            f_info.*.ore -= 1;
            t_info.*.ore += 1;
        }
        resource::SHEEP {
            f_info.*.sheep -= 1;
            t_info.*.sheep += 1;
        }
        resource::WHEAT {
            f_info.*.wheat -= 1;
            t_info.*.wheat += 1;
        }
        resource::WOOD {
            f_info.*.wood -= 1;
            t_info.*.wood += 1;
        }
        }

        var r = r.data();
        connection.*.sendc(server_message::init_accepted_format(
            "stole {} from {}",
            (:[]std::formatter)[
                std::formatter::init[[typeof(r)]](&r),
                std::formatter::init[[typeof(f_name)]](&f_name)]));
        self.*.sendc_all(server_message::init_log_format(
            "{} stole from {}.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(t_name)]](&t_name),
                std::formatter::init[[typeof(f_name)]](&f_name)]));

        if self.*.prev_phase.is_value() {
            self.*.turn.phase = self.*.prev_phase.value();
        }
        else {
            self.*.turn.phase = phase::MAIN;
        }
    }

    func process_submit_resources(self: *server_state, connection: *connection, resources: resources) void {
        if self.*.turn.phase != phase::DISCARD {
            connection.*.sendc(server_message::init_rejected("cannot discard resources (it is not the discard phase)"));
            return;
        }
        var discarded = self.*.p_discarded(connection.*.player);
        if *discarded {
            connection.*.sendc(server_message::init_rejected("cannot discard resources (player has already discarded)"));
            return;
        }
        var info = self.*.p_info(connection.*.player);
        if info.*.resource_count() <= 7 {
            connection.*.sendc(server_message::init_rejected("cannot discard resources (player has seven or fewer resources)"));
            return;
        }
        if info.*.resource_count() / 2 != resources.count() {
            connection.*.sendc(server_message::init_rejected("cannot discard resources (player must discard exactly half of their resources rounded down)"));
            return;
        }
        if info.*.brick < resources.brick
        or info.*.ore < resources.ore
        or info.*.sheep < resources.sheep
        or info.*.wheat < resources.wheat
        or info.*.wood < resources.wood {
            connection.*.sendc(server_message::init_rejected("cannot discard resources (invalid resource selection)"));
            return;
        }
        info.*.brick -= resources.brick;
        info.*.ore -= resources.ore;
        info.*.sheep -= resources.sheep;
        info.*.wheat -= resources.wheat;
        info.*.wood -= resources.wood;
        *discarded = true;

        connection.*.sendc(server_message::init_accepted("discarded resources"));

        if (self.*.r_live and self.*.r_discarded)
        and (self.*.b_live and self.*.b_discarded)
        and (self.*.w_live and self.*.w_discarded)
        and (self.*.o_live and self.*.o_discarded) {
            var name = player_to_name(self.*.turn.player);
            self.*.sendc_all(server_message::init_log_format(
                "Waiting for {} to move the robber.",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name)]));
            self.*.turn.phase = phase::ROBBER;
            self.*.r_discarded = false;
            self.*.b_discarded = false;
            self.*.w_discarded = false;
            self.*.o_discarded = false;
        }
    }

    func process_trade_n_for_1(self: *server_state, connection: *connection, trade_n_for_1: typeof(client_message::SELF.data.trade_n_for_1)) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot trade with the bank (it is not your turn)"));
            return;
        }
        if self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("cannot trade with the bank (it is not the main phase)"));
            return;
        }

        var n_to_1 = n_to_1(&self.*.board, self.*.turn.player, trade_n_for_1.recv);
        if trade_n_for_1.n != n_to_1 {
            connection.*.sendc(server_message::init_rejected("cannot trade with the bank (invalid n:1 trade)"));
            return;
        }

        if trade_n_for_1.n != n_to_1 {
            connection.*.sendc(server_message::init_rejected("cannot trade with the bank (invalid n:1 trade)"));
            return;
        }

        var ref = self.*.p_info(self.*.turn.player).*.resource_ref(trade_n_for_1.give);
        if *ref < trade_n_for_1.n {
            connection.*.sendc(server_message::init_rejected("cannot trade with the bank (insufficient resources)"));
            return;
        }

        *ref -= trade_n_for_1.n;
        var ref = self.*.p_info(self.*.turn.player).*.resource_ref(trade_n_for_1.recv);
        *ref += 1;

        connection.*.sendc(server_message::init_accepted("trade complete"));
        var name = player_to_name(connection.*.player);
        var give = trade_n_for_1.give.data();
        var recv = trade_n_for_1.recv.data();
        self.*.sendc_all(server_message::init_log_format(
            "{} traded {} {} for {} {}.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name),
                std::formatter::init[[typeof(give)]](&give),
                std::formatter::init[[typeof(n_to_1)]](&n_to_1),
                std::formatter::init[[typeof(trade_n_for_1.n)]](&trade_n_for_1.n),
                std::formatter::init[[typeof(recv)]](&recv)]));
    }

    func process_trade_players(self: *server_state, connection: *connection, trade: trade) void {
        if self.*.turn.player != connection.*.player {
            connection.*.sendc(server_message::init_rejected("cannot trade with players (it is not your turn)"));
            return;
        }
        if self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("cannot trade with players (it is not the main phase)"));
            return;
        }

        if trade.give.count() == 0 {
            connection.*.sendc(server_message::init_rejected("cannot trade with players (cannot give zero resources)"));
            return;
        }
        if trade.recv.count() == 0 {
            connection.*.sendc(server_message::init_rejected("cannot trade with players (cannot receive zero resources)"));
            return;
        }

        var giver = self.*.p_info(self.*.turn.player);
        if giver.*.brick < trade.give.brick
        or giver.*.ore < trade.give.ore
        or giver.*.sheep < trade.give.sheep
        or giver.*.wheat < trade.give.wheat
        or giver.*.wood < trade.give.wood {
            connection.*.sendc(server_message::init_rejected("cannot trade with players (insufficient resources)"));
            return;
        }

        var name = player_to_name(connection.*.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} proposed a trade.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));
        self.*.r_trade_submitted = false;
        self.*.b_trade_submitted = false;
        self.*.w_trade_submitted = false;
        self.*.o_trade_submitted = false;
        self.*.p_trade_submitted(connection.*.player).* = true;
        self.*.trade = trade;
        self.*.turn.phase = phase::TRADE;
        connection.*.sendc(server_message::init_accepted("trade proposed"));
    }

    func process_trade_accept(self: *server_state, connection: *connection, trade: trade) void {
        if self.*.turn.phase != phase::TRADE {
            connection.*.sendc(server_message::init_rejected("cannot accept trade (it is not the trade phase)"));
            return;
        }

        if std::ne[[::trade]](&self.*.trade, &trade) {
            connection.*.sendc(server_message::init_rejected("cannot accept trade (mismatched trade)"));
            return;
        }

        var submitted = self.*.p_trade_submitted(connection.*.player);
        if *submitted {
            connection.*.sendc(server_message::init_rejected("cannot accept trade (already submitted)"));
            return;
        }

        var giver = self.*.p_info(self.*.turn.player);
        var recvr = self.*.p_info(connection.*.player);
        if recvr.*.brick < trade.recv.brick
        or recvr.*.ore < trade.recv.ore
        or recvr.*.sheep < trade.recv.sheep
        or recvr.*.wheat < trade.recv.wheat
        or recvr.*.wood < trade.recv.wood {
            connection.*.sendc(server_message::init_rejected("cannot accept trade (insufficient resources)"));
            return;
        }

        giver.*.brick -= self.*.trade.give.brick;
        giver.*.brick += self.*.trade.recv.brick;
        giver.*.ore -= self.*.trade.give.ore;
        giver.*.ore += self.*.trade.recv.ore;
        giver.*.sheep -= self.*.trade.give.sheep;
        giver.*.sheep += self.*.trade.recv.sheep;
        giver.*.wheat -= self.*.trade.give.wheat;
        giver.*.wheat += self.*.trade.recv.wheat;
        giver.*.wood -= self.*.trade.give.wood;
        giver.*.wood += self.*.trade.recv.wood;

        recvr.*.brick += self.*.trade.give.brick;
        recvr.*.brick -= self.*.trade.recv.brick;
        recvr.*.ore += self.*.trade.give.ore;
        recvr.*.ore -= self.*.trade.recv.ore;
        recvr.*.sheep += self.*.trade.give.sheep;
        recvr.*.sheep -= self.*.trade.recv.sheep;
        recvr.*.wheat += self.*.trade.give.wheat;
        recvr.*.wheat -= self.*.trade.recv.wheat;
        recvr.*.wood += self.*.trade.give.wood;
        recvr.*.wood -= self.*.trade.recv.wood;

        self.*.r_trade_submitted = false;
        self.*.b_trade_submitted = false;
        self.*.w_trade_submitted = false;
        self.*.o_trade_submitted = false;
        self.*.turn.phase = phase::MAIN;
        connection.*.sendc(server_message::init_accepted("trade accepted"));
    }

    func process_trade_reject(self: *server_state, connection: *connection, trade: trade) void {
        if self.*.turn.phase != phase::TRADE {
            connection.*.sendc(server_message::init_rejected("cannot reject trade (it is not the trade phase)"));
            return;
        }

        if std::ne[[::trade]](&self.*.trade, &trade) {
            connection.*.sendc(server_message::init_rejected("cannot reject trade (mismatched trade)"));
            return;
        }

        var submitted = self.*.p_trade_submitted(connection.*.player);
        if *submitted {
            connection.*.sendc(server_message::init_rejected("cannot reject trade (already submitted)"));
            return;
        }

        *submitted = true;

        connection.*.sendc(server_message::init_accepted("trade rejected"));
        if (not self.*.r_live or self.*.r_trade_submitted)
        and (not self.*.b_live or self.*.b_trade_submitted)
        and (not self.*.w_live or self.*.w_trade_submitted)
        and (not self.*.o_live or self.*.o_trade_submitted) {
            self.*.turn.phase = phase::MAIN;
        }
    }

    func update_from_client_message(self: *server_state, message: *client_message, connection: *connection) void {
        # TODO: Checking for a winner before every message is a hack for not
        # having an end-of-game state. Remove this once such a state is added.
        if self.*.winner != player::NIL {
            return; # Do not process additonal messages.
        }

        switch message.*.kind {
        client_message::ROLL {
            self.*.process_roll(connection);
        }
        client_message::END_TURN {
            self.*.process_end_turn(connection);
        }
        client_message::BUILD_ROAD {
            self.*.process_build_road(connection, message.*.data.build_road);
        }
        client_message::BUILD_TOWN {
            self.*.process_build_town(connection, message.*.data.build_town);
        }
        client_message::BUY_DEV_CARD {
            self.*.process_buy_dev_card(connection);
        }
        client_message::USE_DEV_CARD_KNGIHT {
            self.*.process_use_dev_card_knight(connection);
        }
        client_message::USE_DEV_CARD_ROAD_BUILDING {
            self.*.process_use_dev_card_road_building(connection);
        }
        client_message::USE_DEV_CARD_YEAR_OF_PLENTY {
            self.*.process_use_dev_card_year_of_plenty(connection, message.*.data.use_dev_card_year_of_plenty);
        }
        client_message::USE_DEV_CARD_MONOPOLY {
            self.*.process_use_dev_card_monopoly(connection, message.*.data.use_dev_card_monopoly);
        }
        client_message::MOVE_ROBBER {
            self.*.process_move_robber(connection, message.*.data.move_robber);
        }
        client_message::SELECT_PLAYER {
            self.*.process_select_player(connection, message.*.data.select_player);
        }
        client_message::SUBMIT_PLAYER {
            self.*.process_submit_player(connection, message.*.data.submit_player);
        }
        client_message::SUBMIT_RESOURCES {
            self.*.process_submit_resources(connection, message.*.data.submit_resources);
        }
        client_message::TRADE_N_FOR_1 {
            self.*.process_trade_n_for_1(connection, message.*.data.trade_n_for_1);
        }
        client_message::TRADE_PLAYERS {
            self.*.process_trade_players(connection, message.*.data.trade_players);
        }
        client_message::TRADE_ACCEPT {
            self.*.process_trade_accept(connection, message.*.data.trade_accept);
        }
        client_message::TRADE_REJECT {
            self.*.process_trade_reject(connection, message.*.data.trade_reject);
        }
        }

        # TODO: Probably don't need to re-calculate longest road after every
        # message. Once the structure of the server is a little bit more
        # stable, only update victory points when they would change (i.e. road
        # built or town built).
        var r_longest_road = self.*.calculate_longest_road(player::RED);
        var b_longest_road = self.*.calculate_longest_road(player::BLUE);
        var w_longest_road = self.*.calculate_longest_road(player::WHITE);
        var o_longest_road = self.*.calculate_longest_road(player::ORANGE);
        var p_longest_road = usize::max(r_longest_road, usize::max(b_longest_road, usize::max(w_longest_road, o_longest_road)));
        let MIN_LONGEST_ROAD = 5u;
        if p_longest_road >= MIN_LONGEST_ROAD {
            var tied =
                (:usize)(r_longest_road == p_longest_road) +
                (:usize)(b_longest_road == p_longest_road) +
                (:usize)(w_longest_road == p_longest_road) +
                (:usize)(o_longest_road == p_longest_road) > 1;
            # Cases where someone loses longest road without someone stealing longest road.
            if tied and r_longest_road < p_longest_road and self.*.longest_road == player::RED {
                self.*.longest_road = player::NIL;
                var name = player_to_name(self.*.longest_road);
                self.*.sendc_all(server_message::init_log_format(
                    "{} lost the longest road.",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(name)]](&name)]));
            }
            if tied and b_longest_road < p_longest_road and self.*.longest_road == player::BLUE {
                self.*.longest_road = player::NIL;
                var name = player_to_name(self.*.longest_road);
                self.*.sendc_all(server_message::init_log_format(
                    "{} lost the longest road.",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(name)]](&name)]));
            }
            if tied and w_longest_road < p_longest_road and self.*.longest_road == player::WHITE {
                self.*.longest_road = player::NIL;
                var name = player_to_name(self.*.longest_road);
                self.*.sendc_all(server_message::init_log_format(
                    "{} lost the longest road.",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(name)]](&name)]));
            }
            if tied and o_longest_road < p_longest_road and self.*.longest_road == player::ORANGE {
                self.*.longest_road = player::NIL;
                var name = player_to_name(self.*.longest_road);
                self.*.sendc_all(server_message::init_log_format(
                    "{} lost the longest road.",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(name)]](&name)]));
            }
            # Cases where someone steals longest road.
            if not tied and r_longest_road == p_longest_road and self.*.longest_road != player::RED {
                self.*.longest_road = player::RED;
                var name = player_to_name(self.*.longest_road);
                self.*.sendc_all(server_message::init_log_format(
                    "{} has the longest road ({} segments).",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(name)]](&name),
                        std::formatter::init[[usize]](&r_longest_road)]));
            }
            if not tied and b_longest_road == p_longest_road and self.*.longest_road != player::BLUE {
                self.*.longest_road = player::BLUE;
                var name = player_to_name(self.*.longest_road);
                self.*.sendc_all(server_message::init_log_format(
                    "{} has the longest road ({} segments).",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(name)]](&name),
                        std::formatter::init[[usize]](&b_longest_road)]));
            }
            if not tied and w_longest_road == p_longest_road and self.*.longest_road != player::WHITE {
                self.*.longest_road = player::WHITE;
                var name = player_to_name(self.*.longest_road);
                self.*.sendc_all(server_message::init_log_format(
                    "{} has the longest road ({} segments).",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(name)]](&name),
                        std::formatter::init[[usize]](&w_longest_road)]));
            }
            if not tied and o_longest_road == p_longest_road and self.*.longest_road != player::ORANGE {
                self.*.longest_road = player::ORANGE;
                var name = player_to_name(self.*.longest_road);
                self.*.sendc_all(server_message::init_log_format(
                    "{} has the longest road ({} segments).",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(name)]](&name),
                        std::formatter::init[[usize]](&o_longest_road)]));
            }
        }
        else {
            if self.*.longest_road != player::NIL {
                var name = player_to_name(self.*.longest_road);
                self.*.sendc_all(server_message::init_log_format(
                    "{} lost the longest road.",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(name)]](&name)]));
            }
            self.*.longest_road = player::NIL;
        }

        # TODO: Probably don't need to update every player's victory points
        # after every message. Once the structure of the server is a little bit
        # more stable, only update victory points when they would change (i.e.
        # road built, town built, dev card drawn, knight played, etc.).
        self.*.r_info.victory_points = self.*.hidden_victory_points(player::RED);
        self.*.b_info.victory_points = self.*.hidden_victory_points(player::BLUE);
        self.*.w_info.victory_points = self.*.hidden_victory_points(player::WHITE);
        self.*.o_info.victory_points = self.*.hidden_victory_points(player::ORANGE);

        # TODO: Checking for a winner after every message is a hack for not
        # having an end-of-game state. Remove this once such a state is added.
        let WINNING_VICTORY_POINTS: sint = 10;
        if self.*.r_info.victory_points >= WINNING_VICTORY_POINTS {
            var name = player_to_name(player::RED);
            self.*.sendc_all(server_message::init_log_format(
                "{} has {} victory points! {} wins the game!",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[sint]](&self.*.r_info.victory_points),
                    std::formatter::init[[typeof(name)]](&name)]));
            self.*.winner = player::RED;
            self.*.turn.player = player::NIL;
        }
        if self.*.b_info.victory_points >= WINNING_VICTORY_POINTS {
            var name = player_to_name(player::BLUE);
            self.*.sendc_all(server_message::init_log_format(
                "{} has {} victory points! {} wins the game!",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[sint]](&self.*.b_info.victory_points),
                    std::formatter::init[[typeof(name)]](&name)]));
            self.*.winner = player::BLUE;
            self.*.turn.player = player::NIL;
        }
        if self.*.w_info.victory_points >= WINNING_VICTORY_POINTS {
            var name = player_to_name(player::WHITE);
            self.*.sendc_all(server_message::init_log_format(
                "{} has {} victory points! {} wins the game!",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[sint]](&self.*.w_info.victory_points),
                    std::formatter::init[[typeof(name)]](&name)]));
            self.*.winner = player::WHITE;
            self.*.turn.player = player::NIL;
        }
        if self.*.o_info.victory_points >= WINNING_VICTORY_POINTS {
            var name = player_to_name(player::ORANGE);
            self.*.sendc_all(server_message::init_log_format(
                "{} has {} victory points! {} wins the game!",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[sint]](&self.*.o_info.victory_points),
                    std::formatter::init[[typeof(name)]](&name)]));
            self.*.winner = player::ORANGE;
            self.*.turn.player = player::NIL;
        }
    }
}

func server_update(sstate: *server_state) void {
    # Initial server messages sent on the first game tick.
    if sstate.*.ticks == 0 {
        sstate.*.sendc_all(server_message::init_log("Welcome to Natac!"));
        sstate.*.change_turn(player::RED);
    }

    var r = (:public_player_info){
        .live = sstate.*.r_live,
        .victory_points = sstate.*.public_victory_points(player::RED),
        .resources = sstate.*.r_info.resource_count(),
        .dev_cards = (:sint)sstate.*.r_info.dev_card_count,
        .discarded = sstate.*.r_discarded,
        .trade_submitted = sstate.*.r_trade_submitted,
    };
    var b = (:public_player_info){
        .live = sstate.*.b_live,
        .victory_points = sstate.*.public_victory_points(player::BLUE),
        .resources = sstate.*.b_info.resource_count(),
        .dev_cards = (:sint)sstate.*.b_info.dev_card_count,
        .discarded = sstate.*.b_discarded,
        .trade_submitted = sstate.*.b_trade_submitted,
    };
    var w = (:public_player_info){
        .live = sstate.*.w_live,
        .victory_points = sstate.*.public_victory_points(player::WHITE),
        .resources = sstate.*.w_info.resource_count(),
        .dev_cards = (:sint)sstate.*.w_info.dev_card_count,
        .discarded = sstate.*.w_discarded,
        .trade_submitted = sstate.*.w_trade_submitted,
    };
    var o = (:public_player_info){
        .live = sstate.*.o_live,
        .victory_points = sstate.*.public_victory_points(player::ORANGE),
        .resources = sstate.*.o_info.resource_count(),
        .dev_cards = (:sint)sstate.*.o_info.dev_card_count,
        .discarded = sstate.*.o_discarded,
        .trade_submitted = sstate.*.o_trade_submitted,
    };
    sstate.*.sendc_all(server_message::init_state(
        &sstate.*.board,
        sstate.*.turn,
        sstate.*.trade,
        r,
        b,
        w,
        o));

    for i in sstate.*.connections.count() {
        if sstate.*.connections.data()[i].player == player::NIL {
            continue;
        }
        var info = sstate.*.p_info(sstate.*.connections.data()[i].player);
        sstate.*.connections.data()[i].sendc(server_message::init_info(*info));
    }

    sstate.*.ticks +%= 1;
    sleep_sec(1.0 / 60.0);
}
