import "c";
import "std";

import "util.sunder";
import "shared.sunder";

struct connection {
    var player: std::optional[[player]];
    var sender: message_sender[[server_message]];

    # Send a reliable server message to the connection.
    func send(self: *connection, message: *server_message) void {
        self.*.sender.send(message);
    }

    # Send an unreliable server message to the connection.
    func send_unreliable(self: *connection, message: *server_message) void {
        self.*.sender.send_unreliable(message);
    }

    # Send a reliable server message to the connection, then consume the
    # message.
    func sendc(self: *connection, message: server_message) void {
        self.*.sender.send(&message);
        message.fini();
    }

    # Send an unreliable server message to the connection, then consume the
    # message.
    func sendc_unreliable(self: *connection, message: server_message) void {
        self.*.sender.send_unreliable(&message);
        message.fini();
    }
}

struct server_state {
    var connections: std::vector[[connection]];
    var ticks: usize;
    var board: board;
    var dev_cards: std::vector[[dev_card]];
    var r_live: bool;
    var b_live: bool;
    var w_live: bool;
    var o_live: bool;
    var r_info: hidden_player_info;
    var b_info: hidden_player_info;
    var w_info: hidden_player_info;
    var o_info: hidden_player_info;
    var r_discarded: bool; # discard phase
    var b_discarded: bool; # discard phase
    var w_discarded: bool; # discard phase
    var o_discarded: bool; # discard phase
    var r_trade_submitted: bool; # trade phase
    var b_trade_submitted: bool; # trade phase
    var w_trade_submitted: bool; # trade phase
    var o_trade_submitted: bool; # trade phase
    var trade: trade;
    # The player turn order for the game. Shuffled from the four player colors.
    # If the Nth player is not live, then that player's turn is skipped.
    var turn_order: [4]player;
    # The current turn.
    var turn: turn;
    # The phase a development card was played this turn. Used for restoring the
    # turn state after a development card has resolved. An empty optional
    # indicates that a development card has not been played this turn.
    var dev_card_used: std::optional[[phase]];
    var longest_road: std::optional[[player]];
    var largest_army: std::optional[[player]];
    var winner: std::optional[[player]];

    func init() server_state {
        var dev_cards = std::vector[[dev_card]]::init();
        # x14 Knight
        for _ in 14 {
            dev_cards.push(dev_card::KNIGHT);
        }
        # x02 Road Building
        for _ in 2 {
            dev_cards.push(dev_card::ROAD_BUILDING);
        }
        # x02 Year of Plenty
        for _ in 2 {
            dev_cards.push(dev_card::YEAR_OF_PLENTY);
        }
        # x02 Monopoly
        for _ in 2 {
            dev_cards.push(dev_card::MONOPOLY);
        }
        # x05 Victory Point
        for _ in 2 {
            dev_cards.push(dev_card::VICTORY_POINT);
        }
        shuffle[[dev_card]](dev_cards.data());

        var turn_order = (:[4]player)[
            player::RED,
            player::BLUE,
            player::WHITE,
            player::ORANGE,
        ];
        shuffle[[player]]((:[]player){&turn_order[0], countof(turn_order)});

        var turn = turn::init(0, turn_order[0]);
        turn.phase = phase::GAME_INIT;

        return (:server_state){
            .connections = std::vector[[connection]]::init(),
            .ticks = 0,
            .board = board::init_starter_map_for_beginners(),
            .dev_cards = dev_cards,
            .r_live = false,
            .b_live = false,
            .w_live = false,
            .o_live = false,
            .r_info = uninit,
            .b_info = uninit,
            .w_info = uninit,
            .o_info = uninit,
            .r_discarded = false,
            .b_discarded = false,
            .w_discarded = false,
            .o_discarded = false,
            .r_trade_submitted = false,
            .b_trade_submitted = false,
            .w_trade_submitted = false,
            .o_trade_submitted = false,
            .trade = uninit,
            .turn_order = turn_order,
            .turn = turn,
            .dev_card_used = std::optional[[phase]]::EMPTY,
            .longest_road = std::optional[[player]]::EMPTY,
            .largest_army = std::optional[[player]]::EMPTY,
            .winner = std::optional[[player]]::EMPTY,
        };
    }

    func fini(self: *server_state) void {
        self.*.connections.fini();
        self.*.board.fini();
        self.*.dev_cards.fini();
    }

    # Send a reliable server message to all connections.
    func send_all(self: *server_state, message: *server_message) void {
        for i in self.*.connections.count() {
            self.*.connections.data()[i].send(message);
        }
    }

    # Send an unreliable server message to all connections.
    func send_all_unreliable(self: *server_state, message: *server_message) void {
        for i in self.*.connections.count() {
            self.*.connections.data()[i].send_unreliable(message);
        }
    }

    # Send a reliable server message to all connections, then consume the
    # message.
    func sendc_all(self: *server_state, message: server_message) void {
        self.*.send_all(&message);
        message.fini();
    }

    # Send an unreliable server message to all connections, then consume the
    # message.
    func sendc_all_unreliable(self: *server_state, message: server_message) void {
        self.*.send_all_unreliable(&message);
        message.fini();
    }

    func p_live(self: *server_state, player: player) *bool {
        var out: *bool = uninit;
        switch player {
        ::player::RED {
            out = &self.*.r_live;
        }
        ::player::BLUE {
            out = &self.*.b_live;
        }
        ::player::WHITE {
            out = &self.*.w_live;
        }
        ::player::ORANGE {
            out = &self.*.o_live;
        }
        }
        return out;
    }

    func p_info(self: *server_state, player: player) *hidden_player_info {
        var out: *hidden_player_info = uninit;
        switch player {
        ::player::RED {
            out = &self.*.r_info;
        }
        ::player::BLUE {
            out = &self.*.b_info;
        }
        ::player::WHITE {
            out = &self.*.w_info;
        }
        ::player::ORANGE {
            out = &self.*.o_info;
        }
        }
        return out;
    }

    func p_discarded(self: *server_state, player: player) *bool {
        var out: *bool = uninit;
        switch player {
        ::player::RED {
            out = &self.*.r_discarded;
        }
        ::player::BLUE {
            out = &self.*.b_discarded;
        }
        ::player::WHITE {
            out = &self.*.w_discarded;
        }
        ::player::ORANGE {
            out = &self.*.o_discarded;
        }
        }
        return out;
    }

    func p_trade_submitted(self: *server_state, player: player) *bool {
        var out: *bool = uninit;
        switch player {
        ::player::RED {
            out = &self.*.r_trade_submitted;
        }
        ::player::BLUE {
            out = &self.*.b_trade_submitted;
        }
        ::player::WHITE {
            out = &self.*.w_trade_submitted;
        }
        ::player::ORANGE {
            out = &self.*.o_trade_submitted;
        }
        }
        return out;
    }

    func calculate_longest_road_visit(
        self: *server_state,
        edges: *std::hash_set[[edge]],
        edges_visited: *std::hash_set[[edge]],
        nodes_visited: *std::hash_set[[node]],
        visiting: edge,
        player: player
    ) usize {
        if edges_visited.*.contains(visiting) {
            return 0;
        }
        edges_visited.*.insert(visiting);

        var longest = 1u;
        var adjacent_nodes = adjacent_nodes_to_edge(visiting, &self.*.board.nodes);
        defer adjacent_nodes.fini();
        var iter = std::hash_set_iterator[[node]]::init(&adjacent_nodes);
        for iter.advance() {
            if nodes_visited.*.contains(*iter.current()) {
                continue;
            }
            nodes_visited.*.insert(*iter.current());

            var town = self.*.board.towns.lookup(*iter.current());
            if town.is_value() and town.value().*.player != player {
                continue;
            }

            var edges_visited = std::hash_set[[edge]]::init_assign(edges_visited);
            defer edges_visited.fini();
            var nodes_visited = std::hash_set[[node]]::init_assign(nodes_visited);
            defer nodes_visited.fini();

            var adjacent_edges = adjacent_edges_to_node(*iter.current(), &self.*.board.edges);
            defer adjacent_edges.fini();
            var iter = std::hash_set_iterator[[edge]]::init(&adjacent_edges);
            for iter.advance() {
                if not edges.*.contains(*iter.current()) {
                    continue;
                }
                var length = 1 + self.*.calculate_longest_road_visit(edges, &edges_visited, &nodes_visited, *iter.current(), player);
                longest = usize::max(longest, length);
            }
        }

        return longest;
    }

    func calculate_longest_road(self: *server_state, player: player) usize {
        var edges = std::hash_set[[edge]]::init();
        defer edges.fini();
        var iter = std::hash_map_iterator[[edge, road]]::init(&self.*.board.roads);
        for iter.advance() {
            if iter.current().*.value.*.player != player {
                continue;
            }
            edges.insert(*iter.current().*.key);
        }

        var longest = 0u;

        var iter = std::hash_set_iterator[[edge]]::init(&edges);
        for iter.advance() {
            var edges_visited = std::hash_set[[edge]]::init();
            defer edges_visited.fini();
            var nodes_visited = std::hash_set[[node]]::init();
            defer nodes_visited.fini();

            var length = self.*.calculate_longest_road_visit(&edges, &edges_visited, &nodes_visited, *iter.current(), player);
            longest = usize::max(longest, length);
        }

        return longest;
    }

    func public_victory_points(self: *server_state, player: player) sint {
        var victory_points: sint = 0;

        var iter = std::hash_map_iterator[[node, town]]::init(&self.*.board.towns);
        for iter.advance() {
            var town = *iter.current().*.value;
            if town.player != player {
                continue;
            }
            switch town.kind {
            ::town::SETTLEMENT {
                victory_points += 1;
            }
            ::town::CITY {
                victory_points += 2;
            }
            }
        }

        if self.*.longest_road.is_value() and self.*.longest_road.value() == player {
            victory_points += 2;
        }

        if self.*.largest_army.is_value() and self.*.largest_army.value() == player {
            victory_points += 2;
        }

        return victory_points;
    }

    func prev_player(self: *server_state, player: player) player {
        var idx = usize::MAX;
        for i in countof(self.*.turn_order) {
            if player == self.*.turn_order[i] {
                idx = i;
                break;
            }
        }
        assert idx != usize::MAX;

        for true {
            if idx == 0 {
                idx = countof(self.*.turn_order);
            }
            idx -= 1;
            if *self.*.p_live(self.*.turn_order[idx]) {
                break;
            }
        }

        return self.*.turn_order[idx];
    }

    func next_player(self: *server_state, player: player) player {
        var idx = usize::MAX;
        for i in countof(self.*.turn_order) {
            if player == self.*.turn_order[i] {
                idx = i;
                break;
            }
        }
        assert idx != usize::MAX;

        for true {
            idx += 1;
            idx %= countof(self.*.turn_order);
            if *self.*.p_live(self.*.turn_order[idx]) {
                break;
            }
        }

        return self.*.turn_order[idx];
    }

    func hidden_victory_points(self: *server_state, player: player) sint {
        var victory_points: sint = self.*.public_victory_points(player);

        var info = self.*.p_info(player);
        for i in info.*.dev_card_count {
            if info.*.dev_card_array[i].kind == dev_card::VICTORY_POINT {
                victory_points += 1;
            }
        }

        return victory_points;
    }

    func game_init_advance(self: *server_state) void {
        switch self.*.turn.phase {
        phase::GAME_INIT {
            if *self.*.p_live(self.*.turn_order[0]) {
                self.*.turn.phase = phase::GAME_INIT_BUILD_TOWN;
                self.*.turn.player = self.*.turn_order[0];
                return;
            }
            if *self.*.p_live(self.*.turn_order[1]) {
                self.*.turn.phase = phase::GAME_INIT_BUILD_TOWN;
                self.*.turn.player = self.*.turn_order[1];
                return;
            }
            if *self.*.p_live(self.*.turn_order[2]) {
                self.*.turn.phase = phase::GAME_INIT_BUILD_TOWN;
                self.*.turn.player = self.*.turn_order[2];
                return;
            }
            if *self.*.p_live(self.*.turn_order[3]) {
                self.*.turn.phase = phase::GAME_INIT_BUILD_TOWN;
                self.*.turn.player = self.*.turn_order[3];
                return;
            }
        }
        else {
            std::unreachable(fileof(), lineof());
        }
        }
    }

    func change_turn(self: *server_state, player: player) void {
        self.*.turn = turn::init(self.*.turn.number + 1, player);
        self.*.dev_card_used = std::optional[[phase]]::EMPTY;
        var name = player_to_name(player);
        self.*.sendc_all(server_message::init_log_format(
            "It's {}'s turn!",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));
    }

    func process_begin_game(self: *server_state, connection: *connection) void {
        if connection.*.player.is_empty() {
            connection.*.sendc(server_message::init_rejected("Cannot begin the game (you are not an active player)."));
            return;
        }
        if self.*.turn.phase != phase::GAME_INIT {
            connection.*.sendc(server_message::init_rejected("Cannot begin the game (the game has already started)."));
            return;
        }

        self.*.game_init_advance();
    }

    func process_roll(self: *server_state, connection: *connection) void {
        if connection.*.player.is_empty() or connection.*.player.value() != self.*.turn.player {
            connection.*.sendc(server_message::init_rejected("Cannot roll dice (it is not your turn)."));
            return;
        }
        if self.*.turn.phase != phase::RESOURCE_PRODUCTION {
            connection.*.sendc(server_message::init_rejected("Cannot roll dice (it is not the resource production phase)."));
            return;
        }

        var roll_a = d6();
        var roll_b = d6();
        var roll = roll_a + roll_b;
        self.*.board.d6_a = roll_a;
        self.*.board.d6_b = roll_b;

        var name = player_to_name(connection.*.player.value());
        self.*.sendc_all(server_message::init_log_format(
            "{} rolled {} + {} = {}.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name),
                std::formatter::init[[typeof(roll_a)]](&roll_a),
                std::formatter::init[[typeof(roll_b)]](&roll_b),
                std::formatter::init[[typeof(roll)]](&roll)]));

        if roll == 7 {
            if (self.*.r_info.resource_count() <= 7)
            and (self.*.b_info.resource_count() <= 7)
            and (self.*.w_info.resource_count() <= 7)
            and (self.*.o_info.resource_count() <= 7) {
                self.*.sendc_all(server_message::init_log("No players need to discard."));
                var name = player_to_name(self.*.turn.player);
                self.*.sendc_all(server_message::init_log_format(
                    "Waiting for {} to move the robber.",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(name)]](&name)]));
                self.*.turn.phase = phase::ROBBER;
            }
            else {
                self.*.sendc_all(server_message::init_log("Waiting for all players to discard."));
                self.*.r_discarded = self.*.r_info.resource_count() <= 7;
                self.*.b_discarded = self.*.b_info.resource_count() <= 7;
                self.*.w_discarded = self.*.w_info.resource_count() <= 7;
                self.*.o_discarded = self.*.o_info.resource_count() <= 7;
                self.*.turn.phase = phase::DISCARD;
            }
            return;
        }

        var iter = std::hash_map_iterator[[node, town]]::init(&self.*.board.towns);
        for iter.advance() {
            var amount: sint = uninit;
            var town = *iter.current().*.value;
            switch town.kind {
            ::town::SETTLEMENT {
                amount = 1;
            }
            ::town::CITY {
                amount = 2;
            }
            }
            var node = *iter.current().*.key;
            for i in countof(node.hexes) {
                var tile = self.*.board.tiles.lookup(node.hexes[i]);
                var tile = tile.value();
                if tile.*.number != roll {
                    continue;
                }
                var info = self.*.p_info(town.player);
                info.*.brick += amount * (:sint)(tile.*.kind == ::tile::HILL);
                info.*.ore += amount * (:sint)(tile.*.kind == ::tile::MOUNTAIN);
                info.*.sheep += amount * (:sint)(tile.*.kind == ::tile::PASTURE);
                info.*.wheat += amount * (:sint)(tile.*.kind == ::tile::FIELD);
                info.*.wood += amount * (:sint)(tile.*.kind == ::tile::FOREST);
            }
        }
        self.*.turn.phase = phase::MAIN;
    }

    func process_end_turn(self: *server_state, connection: *connection) void {
        if connection.*.player.is_empty() or connection.*.player.value() != self.*.turn.player {
            connection.*.sendc(server_message::init_rejected("Cannot end turn (it is not your turn)."));
            return;
        }
        if self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("Cannot end turn (it is not the main phase)."));
            return;
        }

        var name = player_to_name(connection.*.player.value());
        self.*.sendc_all(server_message::init_log_format(
            "{} ended their turn.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));

        self.*.change_turn(self.*.next_player(self.*.turn.player));
    }

    func process_build_road(self: *server_state, connection: *connection, road: road) void {
        if connection.*.player.is_empty() or connection.*.player.value() != self.*.turn.player {
            connection.*.sendc(server_message::init_rejected("Cannot build road (it is not your turn)."));
            return;
        }
        if self.*.turn.player != road.player {
            connection.*.sendc(server_message::init_rejected("Cannot build road (it is not your road)."));
            return;
        }
        if self.*.turn.phase != phase::GAME_INIT_BUILD_ROAD and self.*.turn.phase != phase::MAIN and self.*.turn.phase != phase::ROAD_BUILDING_1 and self.*.turn.phase != phase::ROAD_BUILDING_2 {
            connection.*.sendc(server_message::init_rejected("Cannot build road (invalid phase)."));
            return;
        }

        var tile_a = self.*.board.tiles.lookup(road.edge.hexes[0]);
        var tile_b = self.*.board.tiles.lookup(road.edge.hexes[1]);
        var is_road_across_water =
            tile_a.value().*.kind == tile::OCEAN and
            tile_b.value().*.kind == tile::OCEAN;
        if is_road_across_water {
            connection.*.sendc(server_message::init_rejected("Cannot build road (cannot build on water)."));
            return;
        }

        var existing = self.*.board.roads.lookup(road.edge);
        if existing.is_value() {
            connection.*.sendc(server_message::init_rejected("Cannot build road (road exists at location)."));
            return;
        }

        var adjacent_edges = adjacent_edges_to_edge(road.edge, &self.*.board.edges, &self.*.board.nodes);
        defer adjacent_edges.fini();
        var adjacent_roads = std::hash_set[[::road]]::init();
        defer adjacent_roads.fini();
        var iter = std::hash_set_iterator[[edge]]::init(&adjacent_edges);
        for iter.advance() {
            var adjacent = self.*.board.roads.lookup(*iter.current());
            if adjacent.is_empty() {
                continue;
            }
            var adjacent = adjacent.value();
            if adjacent.*.player != road.player {
                continue;
            }
            adjacent_roads.insert(*adjacent);
        }
        var adjacent_nodes = adjacent_nodes_to_edge(road.edge, &self.*.board.nodes);
        defer adjacent_nodes.fini();
        var adjacent_towns = std::hash_set[[town]]::init();
        defer adjacent_towns.fini();
        var iter = std::hash_set_iterator[[node]]::init(&adjacent_nodes);
        for iter.advance() {
            var adjacent = self.*.board.towns.lookup(*iter.current());
            if adjacent.is_empty() {
                continue;
            }
            var adjacent = adjacent.value();
            if adjacent.*.player != road.player {
                continue;
            }
            adjacent_towns.insert(*adjacent);
        }
        if adjacent_roads.count() == 0 and adjacent_towns.count() == 0 {
            connection.*.sendc(server_message::init_rejected("Cannot build road (no adjacent road or town)."));
            return;
        }

        var unobstructed_road_count = 0u;
        var iter = std::hash_set_iterator[[::road]]::init(&adjacent_roads);
        for iter.advance() {
            var a = adjacent_nodes_to_edge(road.edge, &self.*.board.nodes);
            defer a.fini();
            var b = adjacent_nodes_to_edge(iter.current().*.edge, &self.*.board.nodes);
            defer b.fini();
            var i = std::hash_set[[node]]::init_intersection(&a, &b);
            defer i.fini();
            assert i.count() == 1;
            var iter = std::hash_set_iterator[[node]]::init(&i);
            iter.advance();
            var town = self.*.board.towns.lookup(*iter.current());
            if town.is_empty() {
                # No town between the two road pieces.
                unobstructed_road_count += 1;
                continue;
            }
            var town = town.value();
            if town.*.player == road.player {
                # Town between the two road pieces belongs to the player
                # placing the road.
                unobstructed_road_count += 1;
                continue;
            }
        }
        if adjacent_towns.count() == 0 and unobstructed_road_count == 0 {
            connection.*.sendc(server_message::init_rejected("Cannot build road (road is obstructed by town)."));
            return;
        }

        var player_road_count = 0u;
        var iter = std::hash_map_iterator[[edge, ::road]]::init(&self.*.board.roads);
        for iter.advance() {
            if iter.current().*.value.*.player == road.player {
                player_road_count += 1;
            }
        }
        if player_road_count >= 15 {
            connection.*.sendc(server_message::init_rejected("Cannot build road (all roads placed)."));
            return;
        }

        var info = self.*.p_info(self.*.turn.player);
        if self.*.turn.phase == phase::MAIN {
            if not (info.*.brick >= 1 and info.*.wood >= 1) {
                connection.*.sendc(server_message::init_rejected("Cannot build road (insufficient resources)."));
                return;
            }

            info.*.brick -= 1;
            info.*.wood -= 1;
        }
        insert_road(&self.*.board.roads, road);

        var name = player_to_name(self.*.turn.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} built a road.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));

        if self.*.turn.phase == phase::GAME_INIT_BUILD_ROAD {
            var live_count =
                (:usize)*self.*.p_live(player::RED) +
                (:usize)*self.*.p_live(player::BLUE) +
                (:usize)*self.*.p_live(player::WHITE) +
                (:usize)*self.*.p_live(player::ORANGE);
            if self.*.board.towns.count() < live_count {
                # First placement -> pass to next player in the turn order.
                var next = self.*.next_player(self.*.turn.player);
                self.*.turn.phase = phase::GAME_INIT_BUILD_TOWN;
                self.*.turn.player = next;
            }
            elif self.*.board.towns.count() == live_count {
                # First placement -> place next pair in reverse order.
                self.*.turn.phase = phase::GAME_INIT_BUILD_TOWN;
            }
            elif self.*.board.towns.count() < live_count * 2 {
                # Second placement -> pass to prevous player in the turn order.
                var prev = self.*.prev_player(self.*.turn.player);
                self.*.turn.phase = phase::GAME_INIT_BUILD_TOWN;
                self.*.turn.player = prev;
            }
            else {
                # Second placement -> initial placements are over.
                self.*.change_turn(self.*.turn.player);
            }
        }
        elif self.*.turn.phase == phase::ROAD_BUILDING_1 {
            self.*.turn.phase = phase::ROAD_BUILDING_2;
        }
        elif self.*.turn.phase == phase::ROAD_BUILDING_2 {
            assert self.*.dev_card_used.is_value();
            self.*.turn.phase = self.*.dev_card_used.value();
        }
    }

    func process_build_town(self: *server_state, connection: *connection, town: town) void {
        if connection.*.player.is_empty() or connection.*.player.value() != self.*.turn.player {
            connection.*.sendc(server_message::init_rejected("Cannot build town (it is not your turn)."));
            return;
        }
        if self.*.turn.player != town.player {
            connection.*.sendc(server_message::init_rejected("Cannot build town (it is not your town)."));
            return;
        }
        if self.*.turn.phase != phase::GAME_INIT_BUILD_TOWN and self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("Cannot build town (invalid phase)."));
            return;
        }

        var existing = self.*.board.towns.lookup(town.node);
        if existing.is_value() {
            var existing = existing.value();
            # Special case for upgrading a settlement to a city.
            if not (existing.*.player == town.player and existing.*.kind == ::town::SETTLEMENT and town.kind == ::town::CITY) {
                connection.*.sendc(server_message::init_rejected("Cannot build town (town exists at location)."));
                return;
            }
        }

        var adjacent_nodes = adjacent_nodes_to_node(town.node, &self.*.board.nodes);
        defer adjacent_nodes.fini();
        var adjacent_town_count = 0u;
        var iter = std::hash_set_iterator[[node]]::init(&adjacent_nodes);
        for iter.advance() {
            if self.*.board.towns.contains(*iter.current()) {
                adjacent_town_count = adjacent_town_count + 1;
            }
        }
        if adjacent_town_count != 0 {
            connection.*.sendc(server_message::init_rejected("Cannot build town (adjacent town)."));
            return;
        }

        var adjacent_edges = adjacent_edges_to_node(town.node, &self.*.board.edges);
        defer adjacent_edges.fini();
        var is_road_adjacent = false;
        var iter = std::hash_set_iterator[[edge]]::init(&adjacent_edges);
        for iter.advance() {
            var adjacent = self.*.board.roads.lookup(*iter.current());
            if adjacent.is_empty() {
                continue;
            }
            var adjacent = adjacent.value();
            if adjacent.*.player != town.player {
                continue;
            }

            is_road_adjacent = true;
        }
        if not is_road_adjacent and self.*.turn.phase != phase::GAME_INIT_BUILD_TOWN {
            connection.*.sendc(server_message::init_rejected("Cannot build town (no adjacent road)."));
            return;
        }

        if self.*.turn.phase == phase::GAME_INIT_BUILD_TOWN and town.kind == ::town::CITY {
            connection.*.sendc(server_message::init_rejected("Cannot build town (cannot place a city at the start of the game)."));
            return;
        }

        var player_town_count = 0u;
        var iter = std::hash_map_iterator[[node, ::town]]::init(&self.*.board.towns);
        for iter.advance() {
            if iter.current().*.value.*.player == town.player and iter.current().*.value.*.kind == town.kind {
                player_town_count = player_town_count + 1;
            }
        }
        if town.kind == ::town::SETTLEMENT and player_town_count >= 5 {
            connection.*.sendc(server_message::init_rejected("Cannot build town (all settlements placed)."));
            return;
        }
        if town.kind == ::town::CITY and player_town_count >= 4 {
            connection.*.sendc(server_message::init_rejected("Cannot build town (all cities placed)."));
            return;
        }

        var info = self.*.p_info(self.*.turn.player);
        if self.*.turn.phase != phase::GAME_INIT_BUILD_TOWN {
            switch town.kind {
            ::town::SETTLEMENT {
                if not (info.*.brick >= 1 and info.*.sheep >= 1 and info.*.wheat >= 1 and info.*.wood >= 1) {
                    connection.*.sendc(server_message::init_rejected("Cannot build settlement (insufficient resources)."));
                    return;
                }
                info.*.brick -= 1;
                info.*.sheep -= 1;
                info.*.wheat -= 1;
                info.*.wood -= 1;
            }
            ::town::CITY {
                if not (info.*.ore >= 3 and info.*.wheat >= 2) {
                    connection.*.sendc(server_message::init_rejected("Cannot build city (insufficient resources)."));
                    return;
                }
                info.*.ore -= 3;
                info.*.wheat -= 2;
            }
            }
        }
        insert_town(&self.*.board.towns, town);

        var name = player_to_name(self.*.turn.player);
        var kind = "settlement";
        if town.kind == ::town::CITY {
            kind = "city";
        }
        self.*.sendc_all(server_message::init_log_format(
            "{} built a {}.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name),
                std::formatter::init[[typeof(kind)]](&kind)]));

        if self.*.turn.phase == phase::GAME_INIT_BUILD_TOWN {
            var live_count =
                (:usize)*self.*.p_live(player::RED) +
                (:usize)*self.*.p_live(player::BLUE) +
                (:usize)*self.*.p_live(player::WHITE) +
                (:usize)*self.*.p_live(player::ORANGE);
            if self.*.board.towns.count() > live_count {
                # Second placement -> give resoruces.
                var iter = std::hash_map_iterator[[hex, tile]]::init(&self.*.board.tiles);
                for iter.advance() {
                    if std::eq[[hex]](&town.node.hexes[0], iter.current().*.key)
                    or std::eq[[hex]](&town.node.hexes[1], iter.current().*.key)
                    or std::eq[[hex]](&town.node.hexes[2], iter.current().*.key) {
                        var info = self.*.p_info(town.player);
                        var tile = iter.current().*.value;
                        info.*.brick += (:sint)(tile.*.kind == ::tile::HILL);
                        info.*.ore += (:sint)(tile.*.kind == ::tile::MOUNTAIN);
                        info.*.sheep += (:sint)(tile.*.kind == ::tile::PASTURE);
                        info.*.wheat += (:sint)(tile.*.kind == ::tile::FIELD);
                        info.*.wood += (:sint)(tile.*.kind == ::tile::FOREST);
                    }
                }
            }

            self.*.turn.phase = phase::GAME_INIT_BUILD_ROAD;
        }
    }

    func process_buy_dev_card(self: *server_state, connection: *connection) void {
        if connection.*.player.is_empty() or connection.*.player.value() != self.*.turn.player {
            connection.*.sendc(server_message::init_rejected("Cannot buy development card (it is not your turn)."));
            return;
        }
        if self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("Cannot buy development card (it is not the main phase)."));
            return;
        }

        if self.*.dev_cards.count() == 0 {
            connection.*.sendc(server_message::init_rejected("Cannot buy development card (no development cards remaining)."));
            return;
        }

        var info = self.*.p_info(self.*.turn.player);
        if not (info.*.ore >= 1 and info.*.sheep >= 1 and info.*.wheat >= 1) {
            connection.*.sendc(server_message::init_rejected("Cannot buy development card (insufficient resources)."));
            return;
        }
        info.*.ore -= 1;
        info.*.sheep -= 1;
        info.*.wheat -= 1;

        info.*.dev_card_array[info.*.dev_card_count] = (:purchased_dev_card){
            .kind = self.*.dev_cards.pop(),
            .turn = self.*.turn.number,
            .used = false,
        };
        info.*.dev_card_count += 1;

        var name = player_to_name(self.*.turn.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} bought a development card.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));
    }

    func process_use_dev_card_knight(self: *server_state, connection: *connection) void {
        if connection.*.player.is_empty() or connection.*.player.value() != self.*.turn.player {
            connection.*.sendc(server_message::init_rejected("Cannot use development card (it is not your turn)."));
            return;
        }
        if self.*.turn.phase != phase::RESOURCE_PRODUCTION and self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("Cannot use development card (invalid phase)."));
            return;
        }
        if self.*.dev_card_used.is_value() {
            connection.*.sendc(server_message::init_rejected("Cannot use development card (development card has already been played this turn)."));
            return;
        }

        var info = self.*.p_info(self.*.turn.player);
        var card = std::ptr[[purchased_dev_card]]::NULL;
        for i in info.*.dev_card_count {
            if info.*.dev_card_array[i].kind != dev_card::KNIGHT {
                continue;
            }
            if info.*.dev_card_array[i].turn >= self.*.turn.number {
                continue;
            }
            if info.*.dev_card_array[i].used {
                continue;
            }
            card = &info.*.dev_card_array[i];
        }
        if card == std::ptr[[purchased_dev_card]]::NULL {
            connection.*.sendc(server_message::init_rejected("Cannot use development card (no valid knight)."));
            return;
        }

        var r_knights: sint = 0;
        var b_knights: sint = 0;
        var w_knights: sint = 0;
        var o_knights: sint = 0;
        for i in self.*.r_info.dev_card_count {
            if self.*.r_info.dev_card_array[i].kind != dev_card::KNIGHT {
                continue;
            }
            if not self.*.r_info.dev_card_array[i].used {
                continue;
            }
            r_knights += 1;
        }
        for i in self.*.b_info.dev_card_count {
            if self.*.b_info.dev_card_array[i].kind != dev_card::KNIGHT {
                continue;
            }
            if not self.*.b_info.dev_card_array[i].used {
                continue;
            }
            b_knights += 1;
        }
        for i in self.*.w_info.dev_card_count {
            if self.*.w_info.dev_card_array[i].kind != dev_card::KNIGHT {
                continue;
            }
            if not self.*.w_info.dev_card_array[i].used {
                continue;
            }
            w_knights += 1;
        }
        for i in self.*.o_info.dev_card_count {
            if self.*.o_info.dev_card_array[i].kind != dev_card::KNIGHT {
                continue;
            }
            if not self.*.o_info.dev_card_array[i].used {
                continue;
            }
            o_knights += 1;
        }
        var cur_max_knights = sint::max(r_knights, sint::max(b_knights, sint::max(w_knights, o_knights)));

        card.*.used = true;
        self.*.dev_card_used = std::optional[[phase]]::init_value(self.*.turn.phase);
        self.*.turn.phase = phase::ROBBER;

        var name = player_to_name(self.*.turn.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} played a knight.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));

        var p_knights: sint = 0;
        for i in info.*.dev_card_count {
            if info.*.dev_card_array[i].kind != dev_card::KNIGHT {
                continue;
            }
            if not info.*.dev_card_array[i].used {
                continue;
            }
            p_knights += 1;
        }
        if p_knights == cur_max_knights + 1 and p_knights >= 3 {
            self.*.largest_army = std::optional[[player]]::init_value(self.*.turn.player);
            self.*.sendc_all(server_message::init_log_format(
                "{} has the largest army ({} knights).",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[sint]](&p_knights)]));
        }
    }

    func process_use_dev_card_road_building(self: *server_state, connection: *connection) void {
        if connection.*.player.is_empty() or connection.*.player.value() != self.*.turn.player {
            connection.*.sendc(server_message::init_rejected("Cannot use development card (it is not your turn)."));
            return;
        }
        if self.*.turn.phase != phase::RESOURCE_PRODUCTION and self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("Cannot use development card (invalid phase)."));
            return;
        }
        if self.*.dev_card_used.is_value() {
            connection.*.sendc(server_message::init_rejected("Cannot use development card (development card has already been played this turn)."));
            return;
        }

        var info = self.*.p_info(self.*.turn.player);
        var card = std::ptr[[purchased_dev_card]]::NULL;
        for i in info.*.dev_card_count {
            if info.*.dev_card_array[i].kind != dev_card::ROAD_BUILDING {
                continue;
            }
            if info.*.dev_card_array[i].turn >= self.*.turn.number {
                continue;
            }
            if info.*.dev_card_array[i].used {
                continue;
            }
            card = &info.*.dev_card_array[i];
        }
        if card == std::ptr[[purchased_dev_card]]::NULL {
            connection.*.sendc(server_message::init_rejected("Cannot use development card (no valid road building)."));
            return;
        }

        card.*.used = true;
        self.*.dev_card_used = std::optional[[phase]]::init_value(self.*.turn.phase);
        self.*.turn.phase = phase::ROAD_BUILDING_1;

        var name = player_to_name(self.*.turn.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} played road building.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));
    }

    func process_use_dev_card_year_of_plenty(self: *server_state, connection: *connection, resources: resources) void {
        if connection.*.player.is_empty() or connection.*.player.value() != self.*.turn.player {
            connection.*.sendc(server_message::init_rejected("Cannot use development card (it is not your turn)."));
            return;
        }
        if self.*.turn.phase != phase::RESOURCE_PRODUCTION and self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("Cannot use development card (invalid phase)."));
            return;
        }
        if self.*.dev_card_used.is_value() {
            connection.*.sendc(server_message::init_rejected("Cannot use development card (development card has already been played this turn)."));
            return;
        }

        var info = self.*.p_info(self.*.turn.player);
        var card = std::ptr[[purchased_dev_card]]::NULL;
        for i in info.*.dev_card_count {
            if info.*.dev_card_array[i].kind != dev_card::YEAR_OF_PLENTY {
                continue;
            }
            if info.*.dev_card_array[i].turn >= self.*.turn.number {
                continue;
            }
            if info.*.dev_card_array[i].used {
                continue;
            }
            card = &info.*.dev_card_array[i];
        }
        if card == std::ptr[[purchased_dev_card]]::NULL {
            connection.*.sendc(server_message::init_rejected("Cannot use development card (no valid year of plenty)."));
            return;
        }

        if resources.count() != 2 {
            connection.*.sendc(server_message::init_rejected("Cannot use development card (invalid resources)."));
            return;
        }
        info.*.brick += resources.brick;
        info.*.ore += resources.ore;
        info.*.sheep += resources.sheep;
        info.*.wheat += resources.wheat;
        info.*.wood += resources.wood;

        card.*.used = true;
        self.*.dev_card_used = std::optional[[phase]]::init_value(self.*.turn.phase);
        self.*.turn.phase = self.*.turn.phase; # TODO: Should Year of Plenty have a distinct phase?

        var name = player_to_name(self.*.turn.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} played year of plenty.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));
        if resources.brick != 0 {
            self.*.sendc_all(server_message::init_log_format(
                "{} gained {} brick.",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[sint]](&resources.brick)]));
        }
        if resources.ore != 0 {
            self.*.sendc_all(server_message::init_log_format(
                "{} gained {} ore.",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[sint]](&resources.ore)]));
        }
        if resources.sheep != 0 {
            self.*.sendc_all(server_message::init_log_format(
                "{} gained {} sheep.",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[sint]](&resources.sheep)]));
        }
        if resources.wheat != 0 {
            self.*.sendc_all(server_message::init_log_format(
                "{} gained {} wheat.",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[sint]](&resources.wheat)]));
        }
        if resources.wood != 0 {
            self.*.sendc_all(server_message::init_log_format(
                "{} gained {} wood.",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[sint]](&resources.wood)]));
        }
    }

    func process_use_dev_card_monopoly(self: *server_state, connection: *connection, resource: resource) void {
        if connection.*.player.is_empty() or connection.*.player.value() != self.*.turn.player {
            connection.*.sendc(server_message::init_rejected("Cannot use development card (it is not your turn)."));
            return;
        }
        if self.*.turn.phase != phase::RESOURCE_PRODUCTION and self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("Cannot use development card (invalid phase)."));
            return;
        }
        if self.*.dev_card_used.is_value() {
            connection.*.sendc(server_message::init_rejected("Cannot use development card (development card has already been played this turn)."));
            return;
        }

        var info = self.*.p_info(self.*.turn.player);
        var card = std::ptr[[purchased_dev_card]]::NULL;
        for i in info.*.dev_card_count {
            if info.*.dev_card_array[i].kind != dev_card::MONOPOLY {
                continue;
            }
            if info.*.dev_card_array[i].turn >= self.*.turn.number {
                continue;
            }
            if info.*.dev_card_array[i].used {
                continue;
            }
            card = &info.*.dev_card_array[i];
        }
        if card == std::ptr[[purchased_dev_card]]::NULL {
            connection.*.sendc(server_message::init_rejected("Cannot use development card (no valid monopoly)."));
            return;
        }


        var kind: []byte = uninit;
        switch resource {
        ::resource::BRICK {
            kind = "brick";
        }
        ::resource::ORE {
            kind = "ore";
        }
        ::resource::SHEEP {
            kind = "sheep";
        }
        ::resource::WHEAT {
            kind = "wheat";
        }
        ::resource::WOOD {
            kind = "wood";
        }
        }
        var name = player_to_name(self.*.turn.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} played monopoly ({}).",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name),
                std::formatter::init[[typeof(kind)]](&kind)]));

        var gained: sint = 0;
        if self.*.r_live and self.*.turn.player != player::RED {
            var ref = self.*.r_info.resource_ref(resource);
            var name = player_to_name(player::RED);
            self.*.sendc_all(server_message::init_log_format(
                "{} lost {} {}.",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[typeof(*ref)]](ref),
                    std::formatter::init[[typeof(kind)]](&kind)]));
            gained += *ref;
            *ref = 0;
        }
        if self.*.b_live and self.*.turn.player != player::BLUE {
            var ref = self.*.b_info.resource_ref(resource);
            var name = player_to_name(player::BLUE);
            self.*.sendc_all(server_message::init_log_format(
                "{} lost {} {}.",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[typeof(*ref)]](ref),
                    std::formatter::init[[typeof(kind)]](&kind)]));
            gained += *ref;
            *ref = 0;
        }
        if self.*.w_live and self.*.turn.player != player::WHITE {
            var ref = self.*.w_info.resource_ref(resource);
            var name = player_to_name(player::WHITE);
            self.*.sendc_all(server_message::init_log_format(
                "{} lost {} {}.",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[typeof(*ref)]](ref),
                    std::formatter::init[[typeof(kind)]](&kind)]));
            gained += *ref;
            *ref = 0;
        }
        if self.*.o_live and self.*.turn.player != player::ORANGE {
            var ref = self.*.o_info.resource_ref(resource);
            var name = player_to_name(player::ORANGE);
            self.*.sendc_all(server_message::init_log_format(
                "{} lost {} {}.",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[typeof(*ref)]](ref),
                    std::formatter::init[[typeof(kind)]](&kind)]));
            gained += *ref;
            *ref = 0;
        }

        var ref = self.*.p_info(self.*.turn.player).*.resource_ref(resource);
        var name = player_to_name(self.*.turn.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} gained {} {}.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name),
                std::formatter::init[[typeof(gained)]](&gained),
                std::formatter::init[[typeof(kind)]](&kind)]));
        *ref += gained;

        card.*.used = true;
        self.*.dev_card_used = std::optional[[phase]]::init_value(self.*.turn.phase);
        self.*.turn.phase = self.*.turn.phase; # TODO: Should Monopoly have a distinct phase?
    }

    func process_move_robber(self: *server_state, connection: *connection, hex: hex) void {
        if connection.*.player.is_empty() or connection.*.player.value() != self.*.turn.player {
            connection.*.sendc(server_message::init_rejected("Cannot move robber (it is not your turn)."));
            return;
        }
        if self.*.turn.phase != phase::ROBBER {
            connection.*.sendc(server_message::init_rejected("Cannot move robber (it is not the robber phase)."));
            return;
        }

        if std::eq[[::hex]](&hex, &self.*.board.robber) {
            connection.*.sendc(server_message::init_rejected("Cannot move robber (robber already at location)."));
            return;
        }

        var tile = self.*.board.tiles.lookup(hex);
        if tile.is_empty() {
            connection.*.sendc(server_message::init_rejected("Cannot move robber (invalid location)."));
            return;
        }

        var tile = tile.value();
        if tile.*.kind == ::tile::OCEAN {
            connection.*.sendc(server_message::init_rejected("Cannot move robber (tile is ocean)."));
            return;
        }

        self.*.board.robber = hex;
        var name = player_to_name(self.*.turn.player);
        self.*.sendc_all(server_message::init_log_format(
            "{} moved the robber.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));

        var adjacent_nodes = adjacent_nodes_to_hex(hex, &self.*.board.nodes);
        defer adjacent_nodes.fini();
        var iter = std::hash_set_iterator[[node]]::init(&adjacent_nodes);
        for iter.advance() {
            var optional = self.*.board.towns.lookup(*iter.current());
            if optional.is_empty() {
                continue;
            }
            var town = optional.value();
            if town.*.player == connection.*.player.value() {
                continue;
            }
            if self.*.p_info(town.*.player).*.resource_count() != 0 {
                self.*.turn.phase = phase::STEAL;
                return;
            }
        }

        if self.*.dev_card_used.is_value() {
            self.*.turn.phase = self.*.dev_card_used.value();
        }
        else {
            self.*.turn.phase = phase::MAIN;
        }
    }

    func process_select_player(self: *server_state, connection: *connection, selected: player) void {
        if connection.*.player.is_value() and connection.*.player.value() == selected {
            connection.*.sendc(server_message::init_rejected("Cannot select player (you are already that player)."));
            return;
        }

        for i in self.*.connections.count() {
            if &self.*.connections.data()[i] == connection {
                continue;
            }
            if self.*.connections.data()[i].player.is_empty() {
                continue;
            }
            if self.*.connections.data()[i].player.value() != selected {
                continue;
            }
            connection.*.sendc(server_message::init_rejected("Cannot select player (someone else is already that player)."));
            return;
        }

        if not *self.*.p_live(selected) and self.*.turn.phase != phase::GAME_INIT {
            connection.*.sendc(server_message::init_rejected("Cannot select player (player is not part of the game)."));
            return;
        }

        var was = "SPECTATOR";
        if connection.*.player.is_value() {
            was = player_to_name(connection.*.player.value());
        }
        connection.*.player = std::optional[[player]]::init_value(selected);
        if connection.*.player.is_value() {
            var info = self.*.p_info(connection.*.player.value());
            connection.*.sendc(server_message::init_info(*info));
            self.*.p_live(selected).* = true;
        }

        var name = player_to_name(selected);
        connection.*.sendc(server_message::init_player(selected));

        self.*.sendc_all(server_message::init_log_format(
            "{} is now playing as {}.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(was)]](&was),
                std::formatter::init[[typeof(name)]](&name)]));
    }

    func process_submit_player(self: *server_state, connection: *connection, player: player) void {
        if connection.*.player.is_empty() or connection.*.player.value() != self.*.turn.player {
            connection.*.sendc(server_message::init_rejected("Cannot submit player (it is not your turn)."));
            return;
        }
        if self.*.turn.phase != phase::STEAL {
            connection.*.sendc(server_message::init_rejected("Cannot submit player (it is not the steal phase)."));
            return;
        }
        if self.*.turn.player == player {
            connection.*.sendc(server_message::init_rejected("Cannot submit player (you cannot steal from yourself)."));
            return;
        }

        var t_name = player_to_name(self.*.turn.player);
        var f_name = player_to_name(player);

        var is_adjacent = false;
        var adjacent_nodes = adjacent_nodes_to_hex(self.*.board.robber, &self.*.board.nodes);
        defer adjacent_nodes.fini();
        var iter = std::hash_set_iterator[[node]]::init(&adjacent_nodes);
        for iter.advance() {
            var optional = self.*.board.towns.lookup(*iter.current());
            if optional.is_empty() {
                continue;
            }
            var town = optional.value();
            if town.*.player == player {
                is_adjacent = true;
                break;
            }
        }
        if not is_adjacent {
            connection.*.sendc(server_message::init_rejected_format(
                "cannot submit player (you cannot steal from {})",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(f_name)]](&f_name)]));
            return;
        }

        var t_info = self.*.p_info(self.*.turn.player);
        var f_info = self.*.p_info(player);
        if f_info.*.resource_count() == 0 {
            connection.*.sendc(server_message::init_rejected_format(
                "cannot submit player ({} has no resources)",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(f_name)]](&f_name)]));
            return;
        }

        var v = std::vector[[resource]]::init();
        defer v.fini();
        for _ in (:usize)f_info.*.brick {
            v.push(resource::BRICK);
        }
        for _ in (:usize)f_info.*.ore {
            v.push(resource::ORE);
        }
        for _ in (:usize)f_info.*.sheep {
            v.push(resource::SHEEP);
        }
        for _ in (:usize)f_info.*.wheat {
            v.push(resource::WHEAT);
        }
        for _ in (:usize)f_info.*.wood {
            v.push(resource::WOOD);
        }
        var r = v.data()[random[[usize]]() % v.count()];
        switch r {
        resource::BRICK {
            f_info.*.brick -= 1;
            t_info.*.brick += 1;
        }
        resource::ORE {
            f_info.*.ore -= 1;
            t_info.*.ore += 1;
        }
        resource::SHEEP {
            f_info.*.sheep -= 1;
            t_info.*.sheep += 1;
        }
        resource::WHEAT {
            f_info.*.wheat -= 1;
            t_info.*.wheat += 1;
        }
        resource::WOOD {
            f_info.*.wood -= 1;
            t_info.*.wood += 1;
        }
        }

        var r_name = r.data();
        for i in self.*.connections.count() {
            var connection = &self.*.connections.data()[i];
            if connection.*.player.is_value() and connection.*.player.value() == self.*.turn.player {
                connection.*.sendc(server_message::init_log_format(
                    "You stole {} from {}.",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(t_name)]](&r_name),
                        std::formatter::init[[typeof(f_name)]](&f_name)]));
                continue;
            }
            if connection.*.player.is_value() and connection.*.player.value() == player {
                connection.*.sendc(server_message::init_log_format(
                    "{} stole {} from you.",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(t_name)]](&t_name),
                        std::formatter::init[[typeof(f_name)]](&r_name)]));
                continue;
            }
            connection.*.sendc(server_message::init_log_format(
                "{} stole from {}.",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(t_name)]](&t_name),
                    std::formatter::init[[typeof(f_name)]](&f_name)]));
        }

        if self.*.dev_card_used.is_value() {
            self.*.turn.phase = self.*.dev_card_used.value();
        }
        else {
            self.*.turn.phase = phase::MAIN;
        }
    }

    func process_submit_resources(self: *server_state, connection: *connection, resources: resources) void {
        if connection.*.player.is_empty() {
            connection.*.sendc(server_message::init_rejected("Cannot discard resources (invalid player)."));
            return;
        }
        if self.*.turn.phase != phase::DISCARD {
            connection.*.sendc(server_message::init_rejected("Cannot discard resources (it is not the discard phase)."));
            return;
        }
        var discarded = self.*.p_discarded(connection.*.player.value());
        if *discarded {
            connection.*.sendc(server_message::init_rejected("Cannot discard resources (player has already discarded)."));
            return;
        }
        var info = self.*.p_info(connection.*.player.value());
        if info.*.resource_count() <= 7 {
            connection.*.sendc(server_message::init_rejected("Cannot discard resources (player has seven or fewer resources)."));
            return;
        }
        if info.*.resource_count() / 2 != resources.count() {
            connection.*.sendc(server_message::init_rejected("Cannot discard resources (player must discard exactly half of their resources rounded down)."));
            return;
        }
        if info.*.brick < resources.brick
        or info.*.ore < resources.ore
        or info.*.sheep < resources.sheep
        or info.*.wheat < resources.wheat
        or info.*.wood < resources.wood {
            connection.*.sendc(server_message::init_rejected("Cannot discard resources (invalid resource selection)."));
            return;
        }
        info.*.brick -= resources.brick;
        info.*.ore -= resources.ore;
        info.*.sheep -= resources.sheep;
        info.*.wheat -= resources.wheat;
        info.*.wood -= resources.wood;
        *discarded = true;

        if (not self.*.r_live or self.*.r_discarded)
        and (not self.*.b_live or self.*.b_discarded)
        and (not self.*.w_live or self.*.w_discarded)
        and (not self.*.o_live or self.*.o_discarded) {
            var name = player_to_name(self.*.turn.player);
            self.*.sendc_all(server_message::init_log_format(
                "Waiting for {} to move the robber.",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name)]));
            self.*.turn.phase = phase::ROBBER;
            self.*.r_discarded = false;
            self.*.b_discarded = false;
            self.*.w_discarded = false;
            self.*.o_discarded = false;
        }
    }

    func process_trade_n_for_1(self: *server_state, connection: *connection, trade_n_for_1: typeof(client_message::SELF.data.trade_n_for_1)) void {
        if connection.*.player.is_empty() or connection.*.player.value() != self.*.turn.player {
            connection.*.sendc(server_message::init_rejected("Cannot trade with the bank (it is not your turn)."));
            return;
        }
        if self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("Cannot trade with the bank (it is not the main phase)."));
            return;
        }

        var n_to_1 = n_to_1(&self.*.board, self.*.turn.player, trade_n_for_1.give);
        if trade_n_for_1.n != n_to_1 {
            connection.*.sendc(server_message::init_rejected("Cannot trade with the bank (invalid n:1 trade)."));
            return;
        }

        if trade_n_for_1.n != n_to_1 {
            connection.*.sendc(server_message::init_rejected("Cannot trade with the bank (invalid n:1 trade)."));
            return;
        }

        var ref = self.*.p_info(self.*.turn.player).*.resource_ref(trade_n_for_1.give);
        if *ref < trade_n_for_1.n {
            connection.*.sendc(server_message::init_rejected("Cannot trade with the bank (insufficient resources)."));
            return;
        }

        *ref -= trade_n_for_1.n;
        var ref = self.*.p_info(self.*.turn.player).*.resource_ref(trade_n_for_1.recv);
        *ref += 1;

        var name = player_to_name(connection.*.player.value());
        var give = trade_n_for_1.give.data();
        var recv = trade_n_for_1.recv.data();
        self.*.sendc_all(server_message::init_log_format(
            "{} traded {} {} for 1 {}.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name),
                std::formatter::init[[typeof(give)]](&give),
                std::formatter::init[[typeof(n_to_1)]](&n_to_1),
                std::formatter::init[[typeof(recv)]](&recv)]));
    }

    func process_trade_players(self: *server_state, connection: *connection, trade: trade) void {
        if connection.*.player.is_empty() or connection.*.player.value() != self.*.turn.player {
            connection.*.sendc(server_message::init_rejected("Cannot trade with players (it is not your turn)."));
            return;
        }
        if self.*.turn.phase != phase::MAIN {
            connection.*.sendc(server_message::init_rejected("Cannot trade with players (it is not the main phase)."));
            return;
        }

        if trade.give.count() == 0 {
            connection.*.sendc(server_message::init_rejected("Cannot trade with players (cannot give zero resources)."));
            return;
        }
        if trade.recv.count() == 0 {
            connection.*.sendc(server_message::init_rejected("Cannot trade with players (cannot receive zero resources)."));
            return;
        }

        var giver = self.*.p_info(self.*.turn.player);
        if giver.*.brick < trade.give.brick
        or giver.*.ore < trade.give.ore
        or giver.*.sheep < trade.give.sheep
        or giver.*.wheat < trade.give.wheat
        or giver.*.wood < trade.give.wood {
            connection.*.sendc(server_message::init_rejected("Cannot trade with players (insufficient resources)."));
            return;
        }

        var name = player_to_name(connection.*.player.value());
        self.*.sendc_all(server_message::init_log_format(
            "{} proposed a trade.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));
        self.*.r_trade_submitted = false;
        self.*.b_trade_submitted = false;
        self.*.w_trade_submitted = false;
        self.*.o_trade_submitted = false;
        self.*.p_trade_submitted(connection.*.player.value()).* = true;
        self.*.trade = trade;
        self.*.turn.phase = phase::TRADE;
    }

    func process_trade_accept(self: *server_state, connection: *connection, trade: trade) void {
        if connection.*.player.is_empty() {
            connection.*.sendc(server_message::init_rejected("Cannot accept trade (invalid player)."));
            return;
        }
        if self.*.turn.phase != phase::TRADE {
            connection.*.sendc(server_message::init_rejected("Cannot accept trade (it is not the trade phase)."));
            return;
        }

        if std::ne[[::trade]](&self.*.trade, &trade) {
            connection.*.sendc(server_message::init_rejected("Cannot accept trade (mismatched trade)."));
            return;
        }

        var submitted = self.*.p_trade_submitted(connection.*.player.value());
        if *submitted {
            connection.*.sendc(server_message::init_rejected("Cannot accept trade (already submitted)."));
            return;
        }

        var giver = self.*.p_info(self.*.turn.player);
        var recvr = self.*.p_info(connection.*.player.value());
        if recvr.*.brick < trade.recv.brick
        or recvr.*.ore < trade.recv.ore
        or recvr.*.sheep < trade.recv.sheep
        or recvr.*.wheat < trade.recv.wheat
        or recvr.*.wood < trade.recv.wood {
            connection.*.sendc(server_message::init_rejected("Cannot accept trade (insufficient resources)."));
            return;
        }

        giver.*.brick -= self.*.trade.give.brick;
        giver.*.brick += self.*.trade.recv.brick;
        giver.*.ore -= self.*.trade.give.ore;
        giver.*.ore += self.*.trade.recv.ore;
        giver.*.sheep -= self.*.trade.give.sheep;
        giver.*.sheep += self.*.trade.recv.sheep;
        giver.*.wheat -= self.*.trade.give.wheat;
        giver.*.wheat += self.*.trade.recv.wheat;
        giver.*.wood -= self.*.trade.give.wood;
        giver.*.wood += self.*.trade.recv.wood;

        recvr.*.brick += self.*.trade.give.brick;
        recvr.*.brick -= self.*.trade.recv.brick;
        recvr.*.ore += self.*.trade.give.ore;
        recvr.*.ore -= self.*.trade.recv.ore;
        recvr.*.sheep += self.*.trade.give.sheep;
        recvr.*.sheep -= self.*.trade.recv.sheep;
        recvr.*.wheat += self.*.trade.give.wheat;
        recvr.*.wheat -= self.*.trade.recv.wheat;
        recvr.*.wood += self.*.trade.give.wood;
        recvr.*.wood -= self.*.trade.recv.wood;

        self.*.r_trade_submitted = false;
        self.*.b_trade_submitted = false;
        self.*.w_trade_submitted = false;
        self.*.o_trade_submitted = false;
        self.*.turn.phase = phase::MAIN;

        var name = player_to_name(connection.*.player.value());
        self.*.sendc_all(server_message::init_log_format(
            "{} accepted the trade offer.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));
    }

    func process_trade_reject(self: *server_state, connection: *connection, trade: trade) void {
        if connection.*.player.is_empty() {
            connection.*.sendc(server_message::init_rejected("Cannot reject trade (invalid player)."));
            return;
        }
        if self.*.turn.phase != phase::TRADE {
            connection.*.sendc(server_message::init_rejected("Cannot reject trade (it is not the trade phase)."));
            return;
        }

        if std::ne[[::trade]](&self.*.trade, &trade) {
            connection.*.sendc(server_message::init_rejected("Cannot reject trade (mismatched trade)."));
            return;
        }

        var submitted = self.*.p_trade_submitted(connection.*.player.value());
        if *submitted {
            connection.*.sendc(server_message::init_rejected("Cannot reject trade (already submitted)."));
            return;
        }
        *submitted = true;

        var name = player_to_name(connection.*.player.value());
        self.*.sendc_all(server_message::init_log_format(
            "{} rejected the trade offer.",
            (:[]std::formatter)[
                std::formatter::init[[typeof(name)]](&name)]));

        if (not self.*.r_live or self.*.r_trade_submitted)
        and (not self.*.b_live or self.*.b_trade_submitted)
        and (not self.*.w_live or self.*.w_trade_submitted)
        and (not self.*.o_live or self.*.o_trade_submitted) {
            self.*.sendc_all(server_message::init_log("All players have rejected the trade offer."));
            self.*.r_trade_submitted = false;
            self.*.b_trade_submitted = false;
            self.*.w_trade_submitted = false;
            self.*.o_trade_submitted = false;
            self.*.turn.phase = phase::MAIN;
        }
    }

    func process_trade_withdraw(self: *server_state, connection: *connection) void {
        if connection.*.player.is_empty() or connection.*.player.value() != self.*.turn.player {
            connection.*.sendc(server_message::init_rejected("Cannot withdraw trade (it is not your turn)."));
            return;
        }
        if self.*.turn.phase != phase::TRADE {
            connection.*.sendc(server_message::init_rejected("Cannot withdraw trade (it is not the trade phase)."));
            return;
        }

        self.*.sendc_all(server_message::init_log("The trade offer has been withdrawn."));
        self.*.r_trade_submitted = false;
        self.*.b_trade_submitted = false;
        self.*.w_trade_submitted = false;
        self.*.o_trade_submitted = false;
        self.*.turn.phase = phase::MAIN;
    }

    func update_from_client_message(self: *server_state, message: *client_message, connection: *connection) void {
        # TODO: Checking for a winner before every message is a hack for not
        # having an end-of-game state. Remove this once such a state is added.
        if self.*.winner.is_value() {
            return; # Do not process additonal messages.
        }

        switch message.*.kind {
        client_message::BEGIN_GAME {
            self.*.process_begin_game(connection);
        }
        client_message::ROLL {
            self.*.process_roll(connection);
        }
        client_message::END_TURN {
            self.*.process_end_turn(connection);
        }
        client_message::BUILD_ROAD {
            self.*.process_build_road(connection, message.*.data.build_road);
        }
        client_message::BUILD_TOWN {
            self.*.process_build_town(connection, message.*.data.build_town);
        }
        client_message::BUY_DEV_CARD {
            self.*.process_buy_dev_card(connection);
        }
        client_message::USE_DEV_CARD_KNGIHT {
            self.*.process_use_dev_card_knight(connection);
        }
        client_message::USE_DEV_CARD_ROAD_BUILDING {
            self.*.process_use_dev_card_road_building(connection);
        }
        client_message::USE_DEV_CARD_YEAR_OF_PLENTY {
            self.*.process_use_dev_card_year_of_plenty(connection, message.*.data.use_dev_card_year_of_plenty);
        }
        client_message::USE_DEV_CARD_MONOPOLY {
            self.*.process_use_dev_card_monopoly(connection, message.*.data.use_dev_card_monopoly);
        }
        client_message::MOVE_ROBBER {
            self.*.process_move_robber(connection, message.*.data.move_robber);
        }
        client_message::SELECT_PLAYER {
            self.*.process_select_player(connection, message.*.data.select_player);
        }
        client_message::SUBMIT_PLAYER {
            self.*.process_submit_player(connection, message.*.data.submit_player);
        }
        client_message::SUBMIT_RESOURCES {
            self.*.process_submit_resources(connection, message.*.data.submit_resources);
        }
        client_message::TRADE_N_FOR_1 {
            self.*.process_trade_n_for_1(connection, message.*.data.trade_n_for_1);
        }
        client_message::TRADE_PLAYERS {
            self.*.process_trade_players(connection, message.*.data.trade_players);
        }
        client_message::TRADE_ACCEPT {
            self.*.process_trade_accept(connection, message.*.data.trade_accept);
        }
        client_message::TRADE_REJECT {
            self.*.process_trade_reject(connection, message.*.data.trade_reject);
        }
        client_message::TRADE_WITHDRAW {
            self.*.process_trade_withdraw(connection);
        }
        }

        # TODO: Probably don't need to re-calculate longest road after every
        # message. Once the structure of the server is a little bit more
        # stable, only update victory points when they would change (i.e. road
        # built or town built).
        var r_longest_road = self.*.calculate_longest_road(player::RED);
        var b_longest_road = self.*.calculate_longest_road(player::BLUE);
        var w_longest_road = self.*.calculate_longest_road(player::WHITE);
        var o_longest_road = self.*.calculate_longest_road(player::ORANGE);
        var p_longest_road = usize::max(r_longest_road, usize::max(b_longest_road, usize::max(w_longest_road, o_longest_road)));
        let MIN_LONGEST_ROAD = 5u;
        if p_longest_road >= MIN_LONGEST_ROAD {
            var tied =
                (:usize)(r_longest_road == p_longest_road) +
                (:usize)(b_longest_road == p_longest_road) +
                (:usize)(w_longest_road == p_longest_road) +
                (:usize)(o_longest_road == p_longest_road) > 1;
            # Cases where someone loses longest road without someone stealing longest road.
            if tied and r_longest_road < p_longest_road and self.*.longest_road.is_value() and self.*.longest_road.value() == player::RED {
                var name = player_to_name(self.*.longest_road.value());
                self.*.sendc_all(server_message::init_log_format(
                    "{} lost the longest road.",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(name)]](&name)]));
                self.*.longest_road = std::optional[[player]]::EMPTY;
            }
            if tied and b_longest_road < p_longest_road and self.*.longest_road.is_value() and self.*.longest_road.value() == player::BLUE {
                var name = player_to_name(self.*.longest_road.value());
                self.*.sendc_all(server_message::init_log_format(
                    "{} lost the longest road.",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(name)]](&name)]));
                self.*.longest_road = std::optional[[player]]::EMPTY;
            }
            if tied and w_longest_road < p_longest_road and self.*.longest_road.is_value() and self.*.longest_road.value() == player::WHITE {
                var name = player_to_name(self.*.longest_road.value());
                self.*.sendc_all(server_message::init_log_format(
                    "{} lost the longest road.",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(name)]](&name)]));
                self.*.longest_road = std::optional[[player]]::EMPTY;
            }
            if tied and o_longest_road < p_longest_road and self.*.longest_road.is_value() and self.*.longest_road.value() == player::ORANGE {
                var name = player_to_name(self.*.longest_road.value());
                self.*.sendc_all(server_message::init_log_format(
                    "{} lost the longest road.",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(name)]](&name)]));
                self.*.longest_road = std::optional[[player]]::EMPTY;
            }
            # Cases where someone steals longest road.
            if not tied and r_longest_road == p_longest_road and (self.*.longest_road.is_empty() or self.*.longest_road.value() != player::RED) {
                self.*.longest_road = std::optional[[player]]::init_value(player::RED);
                var name = player_to_name(self.*.longest_road.value());
                self.*.sendc_all(server_message::init_log_format(
                    "{} has the longest road ({} segments).",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(name)]](&name),
                        std::formatter::init[[usize]](&r_longest_road)]));
            }
            if not tied and b_longest_road == p_longest_road and (self.*.longest_road.is_empty() or self.*.longest_road.value() != player::BLUE) {
                self.*.longest_road = std::optional[[player]]::init_value(player::BLUE);
                var name = player_to_name(self.*.longest_road.value());
                self.*.sendc_all(server_message::init_log_format(
                    "{} has the longest road ({} segments).",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(name)]](&name),
                        std::formatter::init[[usize]](&b_longest_road)]));
            }
            if not tied and w_longest_road == p_longest_road and (self.*.longest_road.is_empty() or self.*.longest_road.value() != player::WHITE) {
                self.*.longest_road = std::optional[[player]]::init_value(player::WHITE);
                var name = player_to_name(self.*.longest_road.value());
                self.*.sendc_all(server_message::init_log_format(
                    "{} has the longest road ({} segments).",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(name)]](&name),
                        std::formatter::init[[usize]](&w_longest_road)]));
            }
            if not tied and o_longest_road == p_longest_road and (self.*.longest_road.is_empty() or self.*.longest_road.value() != player::ORANGE) {
                self.*.longest_road = std::optional[[player]]::init_value(player::ORANGE);
                var name = player_to_name(self.*.longest_road.value());
                self.*.sendc_all(server_message::init_log_format(
                    "{} has the longest road ({} segments).",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(name)]](&name),
                        std::formatter::init[[usize]](&o_longest_road)]));
            }
        }
        else {
            if self.*.longest_road.is_value() {
                var name = player_to_name(self.*.longest_road.value());
                self.*.sendc_all(server_message::init_log_format(
                    "{} lost the longest road.",
                    (:[]std::formatter)[
                        std::formatter::init[[typeof(name)]](&name)]));
            }
            self.*.longest_road = std::optional[[player]]::EMPTY;
        }

        # TODO: Probably don't need to update every player's victory points
        # after every message. Once the structure of the server is a little bit
        # more stable, only update victory points when they would change (i.e.
        # road built, town built, dev card drawn, knight played, etc.).
        self.*.r_info.victory_points = self.*.hidden_victory_points(player::RED);
        self.*.b_info.victory_points = self.*.hidden_victory_points(player::BLUE);
        self.*.w_info.victory_points = self.*.hidden_victory_points(player::WHITE);
        self.*.o_info.victory_points = self.*.hidden_victory_points(player::ORANGE);

        # TODO: Checking for a winner after every message is a hack for not
        # having an end-of-game state. Remove this once such a state is added.
        let WINNING_VICTORY_POINTS: sint = 10;
        if self.*.r_info.victory_points >= WINNING_VICTORY_POINTS {
            var name = player_to_name(player::RED);
            self.*.sendc_all(server_message::init_log_format(
                "{} has {} victory points! {} wins the game!",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[sint]](&self.*.r_info.victory_points),
                    std::formatter::init[[typeof(name)]](&name)]));
            self.*.winner = std::optional[[player]]::init_value(player::RED);
            self.*.turn.phase = phase::GAME_FINI;
        }
        if self.*.b_info.victory_points >= WINNING_VICTORY_POINTS {
            var name = player_to_name(player::BLUE);
            self.*.sendc_all(server_message::init_log_format(
                "{} has {} victory points! {} wins the game!",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[sint]](&self.*.b_info.victory_points),
                    std::formatter::init[[typeof(name)]](&name)]));
            self.*.winner = std::optional[[player]]::init_value(player::BLUE);
            self.*.turn.phase = phase::GAME_FINI;
        }
        if self.*.w_info.victory_points >= WINNING_VICTORY_POINTS {
            var name = player_to_name(player::WHITE);
            self.*.sendc_all(server_message::init_log_format(
                "{} has {} victory points! {} wins the game!",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[sint]](&self.*.w_info.victory_points),
                    std::formatter::init[[typeof(name)]](&name)]));
            self.*.winner = std::optional[[player]]::init_value(player::WHITE);
            self.*.turn.phase = phase::GAME_FINI;
        }
        if self.*.o_info.victory_points >= WINNING_VICTORY_POINTS {
            var name = player_to_name(player::ORANGE);
            self.*.sendc_all(server_message::init_log_format(
                "{} has {} victory points! {} wins the game!",
                (:[]std::formatter)[
                    std::formatter::init[[typeof(name)]](&name),
                    std::formatter::init[[sint]](&self.*.o_info.victory_points),
                    std::formatter::init[[typeof(name)]](&name)]));
            self.*.winner = std::optional[[player]]::init_value(player::ORANGE);
            self.*.turn.phase = phase::GAME_FINI;
        }
    }
}

func server_update(sstate: *server_state) void {
    var r = (:public_player_info){
        .live = sstate.*.r_live,
        .victory_points = sstate.*.public_victory_points(player::RED),
        .resources = sstate.*.r_info.resource_count(),
        .dev_cards = sstate.*.r_info.unused_dev_card_count(),
        .discarded = sstate.*.r_discarded,
        .trade_submitted = sstate.*.r_trade_submitted,
    };
    var b = (:public_player_info){
        .live = sstate.*.b_live,
        .victory_points = sstate.*.public_victory_points(player::BLUE),
        .resources = sstate.*.b_info.resource_count(),
        .dev_cards = sstate.*.b_info.unused_dev_card_count(),
        .discarded = sstate.*.b_discarded,
        .trade_submitted = sstate.*.b_trade_submitted,
    };
    var w = (:public_player_info){
        .live = sstate.*.w_live,
        .victory_points = sstate.*.public_victory_points(player::WHITE),
        .resources = sstate.*.w_info.resource_count(),
        .dev_cards = sstate.*.w_info.unused_dev_card_count(),
        .discarded = sstate.*.w_discarded,
        .trade_submitted = sstate.*.w_trade_submitted,
    };
    var o = (:public_player_info){
        .live = sstate.*.o_live,
        .victory_points = sstate.*.public_victory_points(player::ORANGE),
        .resources = sstate.*.o_info.resource_count(),
        .dev_cards = sstate.*.o_info.unused_dev_card_count(),
        .discarded = sstate.*.o_discarded,
        .trade_submitted = sstate.*.o_trade_submitted,
    };
    sstate.*.sendc_all_unreliable(server_message::init_state(
        &sstate.*.board,
        sstate.*.turn_order,
        sstate.*.turn,
        sstate.*.trade,
        r,
        b,
        w,
        o));

    for i in sstate.*.connections.count() {
        if sstate.*.connections.data()[i].player.is_empty() {
            continue;
        }
        var info = sstate.*.p_info(sstate.*.connections.data()[i].player.value());
        sstate.*.connections.data()[i].sendc_unreliable(server_message::init_info(*info));
    }

    sstate.*.ticks +%= 1;
    sleep_sec(1.0 / 60.0);
}
